#Analyzing data and building linear models with mgPOM as response variable

#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
setwd("C:/Users/F004SPC/OneDrive-Dartmouth College/Desktop/GitHub/FracFarmVT") #erin
##call in the analytical data
data <- read.csv("data_pH.csv")
Frac23<- read.csv("Frac23.csv")

View(data)
#load your libraries
library(tidyverse)
library(ggplot2)
library(dplyr)
library(corrplot)
library(emmeans)
library(nlme)
library(ggeffects)
library (gmodels)
library(reshape2)
library(car) # for Levene's Test
library(ggpubr) # for easy plotting
library(multcomp) # for Tukey's HSD test
library(cowplot)
library(gridExtra)
library(grid)   # needed for textGrob and gpar

##call in the analytical data
data <- read.csv("data_pH.csv")
View(data)

summary(data$OM30)
summary(data$soil_texture_clay)
summary(data$tmeanC)
summary(data$ppt.cm)
summary(data)
view(data)
summary(data$Owned)
summary(data$Acres)
summary(data$ph)
hist(data$ph)
sum(data$ph > 7)
view(data)


data <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "perennial",
    Type.x %in% c("Veg", "Corn", "Field Crop") ~ "annual",
    TRUE ~ NA_character_  # Set to NA if none of the conditions match
  ))


# Replace 'Type.x' column values with 'Pasture' where 'Field_Code' is 'D7'
data$Type.x[data$Field_Code == "D7"] <- "Pasture"

# Assuming 'data' is your dataframe
subset_Type <- data$Type[data$Type.x == "Veg"]

# Print the subset of Field_Code values where Type.x is "Field Crop"
print(subset_Type)

# Count the number of fields with pH greater than 7
data$ph <- as.numeric(data$ph)

count <- sum(data$ph > 7.00, na.rm = TRUE)

# Print the result
print(count)

anova_result2 <- aov(ph ~ Type.x, data=data)

# test for differences in OM for field types

# Perform ANOVA
anova_result <- aov(OM30 ~ Type.x, data = data)

# Summary of ANOVA
summary(anova_result2)

# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result2, ~ Type.x)

# Print pairwise comparisons
print(posthoc, type = "compact")

# Use table() function to count occurrences of each field type
type_counts <- table(data$Type.x)

# Print the counts
print(type_counts)

# Use table() function to count occurrences of each field type
type_counts <- table(data$soil_texture_class)

# Print the counts
print(type_counts)

# Example ANOVA
anova_model <- aov(soil_texture_clay ~ Type.x, data = data)

# Summary of ANOVA
summary(anova_model)

# Example linear regression
lm_model <- lm(soil_texture_clay ~ Type.x, data = data)

# Summary of linear regression
summary(lm_model)

# Example Tukey's HSD test for post-hoc analysis
tukey_test <- TukeyHSD(anova_model)

# View Tukey's HSD test results
print(tukey_test)

# test for differences in soil texture class for field types
#all CIs overlap indicatin no sigficant difference
# Perform ANOVA
anova_result <- aov(soil_texture_clay ~ Type.x, data = data)
# Summary of ANOVA
summary(anova_result)
# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result, ~ Type.x)
# Print pairwise comparisons
print(posthoc, type = "compact")


# Example scatter plot with jitter
ggplot(data, aes(x = Type.x, y = soil_texture_clay)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  labs(x = "Field Type", y = "Soil Texture Clay") +
  ggtitle("Relationship between Soil Texture Clay and Field Type") +
  theme_minimal()

ggplot(data, aes(x = Type.x, y = soil_texture_clay)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +  # Boxplot without showing outliers
  geom_jitter(width = 0.2, height = 0, alpha = 0.5, color = "gray40") +  # Optional: still show individual points lightly
  labs(x = "Field Type", y = "Soil Texture Clay (%)") +
  ggtitle("Relationship between Soil Texture Clay and Field Type") +
  theme_minimal()

# Filter out "Field crops" first
data_filtered <- data %>% 
  filter(Type.x != "Field crops")

View(data_filtered)

# Now plot#######4.46.25  new SI Figure
ggplot(data_filtered, aes(x = Type.x, y = soil_texture_clay)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +  # Boxplot without showing outliers
  geom_jitter(width = 0.2, height = 0, alpha = 0.5, color = "gray40") +  # Optional: still show individual points lightly
  labs(x = "Crop Type", y = "Soil Texture Clay (%)") +  # Changed x-axis label
  ggtitle("") +  # Updated title
  theme_minimal()

data_filtered$Type.x <- dplyr::recode(data_filtered$Type.x, "Veg" = "Vegetable")
write.csv(data_filtered, "data_filtered.csv", row.names = FALSE)


###########SI Figure 9 #########################
#####################################################
data_filtered <- read.csv("data_filtered.csv")

# Define custom colors for each crop type
custom_colors <- c("Pasture" = "#8DA0CB",    # Purple
                   "Vegetable" = "#E78AC3",  # Pink
                   "Corn" = "#66C2A5",       # Green
                   "Hay" = "#FC8D62")        # Blue

# Create the plot
ggplot(data_filtered, aes(x = Type.x, y = soil_texture_clay, fill = Type.x)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, height = 0, alpha = 0.5, color = "gray40") +
  scale_fill_manual(values = custom_colors) +
  labs(x = "Crop Type", y = "Soil Texture Clay (%)") +
  ggtitle("") +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.line.x = element_line(color = "black", size = 0.5),
    axis.line.y = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    axis.text = element_text(color = "black")
  )




# Check normality (optional: check by group)
by(data_filtered$soil_texture_clay, data_filtered$Type.x, shapiro.test)

# Check homogeneity of variance
library(car)
leveneTest(soil_texture_clay ~ Type.x, data = data_filtered)

kruskal.test(soil_texture_clay ~ Type.x, data = data_filtered)
install.packages("FSA")
library(FSA)
dunnTest(soil_texture_clay ~ Type.x, data = data_filtered, method = "bonferroni")

# Example contingency table
cont_table <- table(data$Type.x, data$soil_texture_class)

# View the contingency table
cont_table
# Load necessary library
library(vcd)  # For mosaic plot

# Example mosaic plot
mosaicplot(cont_table, main = "Mosaic Plot of Field Type vs. Soil Texture Class")

# Summarize the data by soil_texture_class and Type.x
summary_data <- data %>%
  group_by(soil_texture_class, Type.x) %>%
  summarise(count = n()) %>%
  mutate(percent = count / sum(count) * 100)  # Calculate percentage within each soil_texture_class

# Plot stacked bar plot
library(ggplot2)
ggplot(summary_data, aes(x = soil_texture_class, y = percent, fill = Type.x)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(x = "Soil Texture Class", y = "Percentage", fill = "Field Type") +
  ggtitle("Distribution of Field Type across Soil Texture Classes") +
  theme_minimal()

# Plot grouped bar plot
ggplot(summary_data, aes(x = soil_texture_class, y = percent, fill = Type.x)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Soil Texture Class", y = "Percentage", fill = "Field Type") +
  ggtitle("Distribution of Field Type across Soil Texture Classes") +
  theme_minimal()

# Example of performing chi-square test
cont_table <- table(data$soil_texture_class, data$Type.x)
chi_square_test <- chisq.test(cont_table)

# View the contingency table
print(cont_table)

# View the chi-square test results
print(chi_square_test)

# Perform chi-square test
cont_table <- table(data$soil_texture_class, data$Type.x)
chi_square_test <- chisq.test(cont_table)

# Residual analysis
residuals <- residuals(chi_square_test)

# View residuals
print(residuals)

# Compute adjusted residuals
adjusted_res <- chisq.test(cont_table)$residuals

# View adjusted residuals
print(adjusted_res)

# Example of mosaic plot
library(vcd)
mosaicplot(cont_table, main = "Mosaic Plot of Field Type vs. Soil Texture Class")

# Use table() function to count occurrences of each field type
type_counts <- table(data$Type.x)

# Print the counts
print(type_counts)


# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)

# Print the contingency table
print(contingency_table)

# Perform chi-square test of independence
chi2_test <- chisq.test(contingency_table)

# Print the chi-square test results
print(chi2_test)

# chi test shows that this is a significant association between field typee and soil texture class

# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)

# Convert contingency table to data frame for plotting
contingency_df <- as.data.frame.matrix(contingency_table)

# Reshape data for plotting (optional, depending on how you want to visualize)

contingency_melted <- melt(contingency_df)

# Plot clustered bar plot
ggplot(contingency_melted, aes(x = soil_texture_class, y = value, fill = Type.x)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Soil Texture Class", y = "Count") +
  ggtitle("Distribution of Field Types by Soil Texture") +
  theme_minimal()

# Plot heatmap of contingency table
heatmap.2(as.matrix(contingency_table),
          trace = "none",
          col = heat.colors(length(unique(data$Type.x))),
          dendrogram = "row",
          main = "Association between Field Type and Soil Texture",
          xlab = "Soil Texture Class",
          ylab = "Field Type")

  # Load ggplot2 package if not already loaded
  library(ggplot2)


#soil health regression
# Perform linear regression POC
regression_model_POC <- lm(mgCpergSoilP ~ overall.score, data = data)
summary(regression_model_POC)

view(data)
  # Create a plot with the regression line
POC_health <- ggplot(data, aes(x = overall.score, y = mgCpergSoilP, color=AP)) +
    geom_point(alpha = 0.5) +
    stat_smooth(method = "lm", se = FALSE, color= "AP") +
    labs(x = "Soil Health Index",
         y = expression("mg POC g"^-1~"soil")) +
    theme_minimal()
POC_health

# Remove NA values from the AP column
data_clean <- data %>%
  filter(!is.na(AP))

# Replace 'pere' with 'perennial' in the AP column
data$AP[data$AP == "pere"] <- "perennial"
view(data_clean)
#Figure7
# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE) +
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Replace color1 and color2 with your desired colors
                     labels = c("perennial" = "pere")) +  # Change 'pere' to 'perennial'
  theme_minimal()

POC_health
# Replace 'pere' with 'perennial' in the AP column
data_clean$AP[data_clean$AP == "pere"] <- "perennial"
view(data_clean)

# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                               name = NULL) +  # Remove legend title
  theme_minimal()

# Display the plot
POC_health

# Create a plot with the regression line
MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal()

# Display the plot
MAOC_health

# Create a plot with the regression line
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal()

# Display the plot
PropMAOC_health



# Figure 7 to Line 400#######this one is side by side
# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = TRUE, color = "black", fill = "gray", alpha = 0.2) +  # Add shaded confidence interval
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Custom colors for AP categories
                     name = NULL) +  # Remove legend title
  theme_minimal() +  # Minimal theme to remove gray background
  theme(axis.title.x = element_text(size = 12),  # Increase x-axis label size
        axis.title.y = element_text(size = 12),  # Increase y-axis label size
        legend.text = element_text(size = 12))   # Increase legend text size

# Display the plot
POC_health

MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = TRUE, color = "black", fill = "gray", alpha = 0.2) +  # Add shaded confidence interval
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Custom colors for AP categories
                     name = NULL) +  # Remove legend title
  theme_minimal() +  # Minimal theme to remove gray background
  theme(axis.title.x = element_text(size = 14),  # Increase x-axis label size
        axis.title.y = element_text(size = 14),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
MAOC_health

# Create a plot with the regression line for Proportion of Carbon as MAOC
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = TRUE, color = "black", fill = "gray", alpha = 0.2) +  # Add shaded confidence interval
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 14),  # Increase x-axis label size
        axis.title.y = element_text(size = 14),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
PropMAOC_health



# This is the Final Final Actual Figure 4
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

# Create the plots without legends (remove individual legends)
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(
  POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = 1.08    # Adjust y position for labels
)

# Extract the legend from one of the plots (e.g., POC_health)
legend <- get_legend(
  POC_health + 
    guides(color = guide_legend(title = "Crop"))  # Add the legend title "Crop"
)

# Position the legend at the top-right of the figure
Figure_7dhealth_with_legend <- plot_grid(
  Figure_7dhealth,  # The grid with 3 plots
  legend,           # The shared legend
  ncol = 2,         # 2 columns: 1 for the plots and 1 for the legend
  rel_widths = c(1, 0.2)  # Adjust the relative widths to give more space for the plots
)

# Move the legend to the top right
Figure_7dhealth_final <- Figure_7dhealth_with_legend + 
  theme(legend.position = c(0.9, 0.95),  # Move the legend to the top right
        legend.justification = c("right", "top"),  # Align the legend to the top right
        legend.title = element_text(size = 12),  # Adjust legend title size
        legend.text = element_text(size = 10),   # Adjust legend text size
        legend.title.align = 1)  # Align the legend title with the text (right-aligned)

# Add a common x-axis label at the bottom (for all plots)
Figure_7dhealth_final <- Figure_7dhealth_final + 
  theme(axis.title.x = element_text(size = 14), 
        axis.text.x = element_text(size = 12), 
        axis.ticks.x = element_line(color = "black")) + 
  annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)

# Display the final figure
Figure_7dhealth_final


###########cleaned up figure 4 for final

# --- Step 1: Create two formatting functions ---

# For top two plots (no x-axis labels or ticks)
remove_legend_and_format <- function(plot) {
  plot +
    theme(
      legend.position = "none",
      axis.title.x = element_blank(),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks = element_line(color = "black", size = 0.5)
    )
}

# For bottom plot (keep x-axis labels and ticks)
keep_x_axis_format <- function(plot) {
  plot +
    theme(
      legend.position = "none",
      axis.title.x = element_text(size = 12),
      axis.text.x = element_text(size = 10),
      axis.ticks.x = element_line(color = "black", size = 0.5),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks = element_line(color = "black", size = 0.5)
    )
}

# --- Step 2: Apply formatting to your three plots ---

POC_health_no_legend <- remove_legend_and_format(POC_health)
MAOC_health_no_legend <- remove_legend_and_format(MAOC_health)
PropMAOC_health_no_legend <- keep_x_axis_format(PropMAOC_health)  # Bottom plot keeps x-axis

# --- Step 3: Combine the 3 plots vertically ---

Figure_7dhealth <- plot_grid(
  POC_health_no_legend,
  MAOC_health_no_legend,
  PropMAOC_health_no_legend,
  ncol = 1, nrow = 3,
  align = 'v',
  labels = c("a", "b", "c"),
  label_x = 0.05,
  label_y = 1.08
)

# --- Step 4: Extract a shared legend from original plot ---

shared_legend <- get_legend(
  POC_health +
    theme(
      legend.position = "top",
      legend.title = element_blank(),
      legend.text = element_text(size = 10)
    )
)

# --- Step 5: Stack the legend and combined plots ---

Figure_7dhealth_with_legend <- plot_grid(
  shared_legend,
  Figure_7dhealth,
  ncol = 1,
  rel_heights = c(0.08, 1)
)

# --- Step 6: Add a shared x-axis label below everything ---

final_plot <- plot_grid(
  Figure_7dhealth_with_legend,
  grid::textGrob("Soil Health Index", gp = gpar(fontsize = 14)),
  ncol = 1,
  rel_heights = c(1, 0.05)
)

# --- Step 7: Display the final plot ---

print(final_plot)


# --- Step 7: Save the final figure (optional) ---

ggsave("Fig.4health.jpeg", plot = final_plot, width = 15, height = 22, units = "cm", dpi = 600)


###########################################################Figure 4 Final
# Create the plots without legends (remove individual legends) but keep axis numbers
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Bring back the x-axis numbers
        axis.text.y = element_text(size = 12))  # Bring back the y-axis numbers

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Bring back the x-axis numbers
        axis.text.y = element_text(size = 12))  # Bring back the y-axis numbers

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Bring back the x-axis numbers
        axis.text.y = element_text(size = 12))  # Bring back the y-axis numbers

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(
  POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = 1.08    # Adjust y position for labels
)

# Extract the legend from one of the plots (e.g., POC_health)
legend <- get_legend(
  POC_health + 
    guides(color = guide_legend(title = "Crop"))  # Add the legend title "Crop"
)

# Position the legend at the top-right of the figure
Figure_7dhealth_with_legend <- plot_grid(
  Figure_7dhealth,  # The grid with 3 plots
  legend,           # The shared legend
  ncol = 2,         # 2 columns: 1 for the plots and 1 for the legend
  rel_widths = c(1, 0.2)  # Adjust the relative widths to give more space for the plots
)

# Move the legend to the top right
Figure_7dhealth_edit <- Figure_7dhealth_with_legend + 
  theme(legend.position = c(0.9, 0.95),  # Move the legend to the top right
        legend.justification = c("right", "top"),  # Align the legend to the top right
        legend.title = element_text(size = 12),  # Adjust legend title size
        legend.text = element_text(size = 10),   # Adjust legend text size
        legend.title.align = 1)  # Align the legend title with the text (right-aligned)

# Add a common x-axis label at the bottom (for all plots)
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(axis.title.x = element_text(size = 14), 
        axis.text.x = element_text(size = 12), 
        axis.ticks.x = element_line(color = "black")) + 
  annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(
    plot.margin = margin(t = 20, r = 20, b = 20, l = 20)  # Increase margins
  )

# Display the final figure
Figure_7dhealth_edit
ggsave("Figure_7dhealth_edit.jpeg", plot = Figure_7dhealth_edit, width = 20, height = 22, units = "cm", dpi = 300)

########################################################### Figure4abc Corrected
# Create the plots without legends but keep axis numbers for y-axis
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Keep x-axis numbers on the bottom plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(
  POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = c(1.08, 0.95, 1.1)    # Adjust y positions for labels (move 'b' down and 'c' up)
)

# Now, let's create a common x-axis label below the shared x-axis for all plots
Figure_7dhealth_edit <- Figure_7dhealth + 
  theme(
    axis.title.x = element_text(size = 14, vjust = -40),  # Move the x-axis title further down below the labels
    axis.text.x = element_text(size = 12),  # Keep the x-axis numbers
    axis.ticks.x = element_line(color = "black"),  # Keep the x-axis ticks
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)  # Increase bottom margin for the x-axis title
  ) + 
   annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)  # Add the x-axis title below the plots

# To ensure that the x-axis labels only appear once (on the bottom plot), 
# we need to remove the x-axis labels from the first two rows manually
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(
    axis.text.x = element_blank()  # Remove x-axis labels from the first two rows
  ) 

# Display the final figure
Figure_7dhealth_edit

# Save the figure as 'figure4abc.jpeg'
ggsave("figure4abcv.jpeg", plot = Figure_7dhealth_edit, width = 20, height = 22, units = "cm", dpi = 600)

###################################################################
# Ensure no x-axis labels on individual plots (POC_health_no_legend, MAOC_health_no_legend, PropMAOC_health_no_legend)
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

MAOC_health_no_legend <- MAOC_health + 
  theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = 1.08    # Adjust y position for labels
)

# Adjust the x-axis title to be positioned below the x-axis numbers
Figure_7dhealth_edit <- Figure_7dhealth + 
  theme(axis.title.x = element_text(size = 14, margin = margin(t = 40)),  # Increase top margin for the x-axis title
        axis.text.x = element_text(size = 12), 
        axis.ticks.x = element_line(color = "black")) +
  annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)  # Place the x-axis label below

# Adjust the margins of the plot to provide space for the x-axis title
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(
    plot.margin = margin(t = 30, r = 20, b = 60, l = 20)  # Increase bottom margin to give space for the title
  )

# Remove the first x-axis label (e.g., 0.00) using scale_x_continuous()
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5), labels = function(x) ifelse(x == 0, NA, x))  # Remove 0.00
scale_color_manual(values = c("#cd853f", "darkgreen"),  # Custom colors for AP categories
                   name = NULL) +  # Remove legend title
# Rename the entire figure
figure4abc <- Figure_7dhealth_edit

# Display the final figure
figure4abc

# Save the figure as 'figure4abc.jpeg'
ggsave("figure4abc.jpeg", plot = figure4abc, width = 20, height = 22, units = "cm", dpi = 300)







# Adjust the legend text size
Figure_7dhealth <- Figure_7dhealth + 
  theme(legend.text = element_text(size = 16),  # Increase legend text size
        legend.title = element_text(size = 18),  # Increase legend title size
        legend.key.size = unit(1.8, "cm"))  # Increase legend key size for better visibility

# Save the combined figure
ggsave("Figure_7dhealth.jpeg", width = 15, height = 8)

view (data_clean)

# Fit the linear model
lm_model <- lm(mean_mgCpergSoilP ~ overall.score, data = data_summary)

# Get predictions along with confidence intervals
predictions <- predict(lm_model, newdata = data_summary, interval = "confidence", level = 0.95)

# Combine predictions with data_summary
predictions_df <- as.data.frame(predictions)
data_summary <- cbind(data_summary, predictions_df)
colnames(data_summary)[3:5] <- c("fit", "lwr", "upr")  # Rename columns for clarity

# Create unique column names if needed
names(data_summary) <- make.unique(names(data_summary))

# Now create the plot with error bands
POC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_mgCpergSoilP - se_mgCpergSoilP, ymax = mean_mgCpergSoilP + se_mgCpergSoilP), width = 0.2) +  # Error bars for means
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2, fill = "black") +  # Error bands around regression line
  geom_line(aes(y = fit), color = "black") +  # Regression line
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Replace color1 and color2 with your desired colors
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
POC_health


# Calculate mean and standard error for mgCpergSoilP grouped by overall.score
data_summary <- data_clean %>%
  group_by(overall.score, AP) %>%
  summarise(
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),  # Calculate mean for each overall.score
    n = n(),  # Count total number of observations for each overall.score
    se_mgCpergSoilP = ifelse(n > 1, sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n), NA),  # Calculate SE
    .groups = 'drop'  # Avoid warnings about grouped data
  )

# View the summary to check for calculated values
print(data_summary)

# Create a plot with the regression line and error bars for POC
POC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilP)) +
  geom_point(data = data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP), alpha = 0.5) +  # Scatter plot of original data
  geom_errorbar(aes(ymin = mean_mgCpergSoilP - se_mgCpergSoilP, 
                    ymax = mean_mgCpergSoilP + se_mgCpergSoilP), 
                width = 0.2) +  # Use data_summary for error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Regression line
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Use your desired colors
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
POC_health




# Calculate means and standard errors for error bars
data_summary <- data_clean %>%
  group_by(overall.score, AP) %>%
  summarise(
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    se_mgCpergSoilP = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n()),
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n()),
    mean_propM = mean(propM, na.rm = TRUE),
    se_propM = sd(propM, na.rm = TRUE) / sqrt(n())
  )

# Create a plot with the regression line and error bars for POC
POC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_mgCpergSoilP - se_mgCpergSoilP, ymax = mean_mgCpergSoilP + se_mgCpergSoilP), width = 0.2) +  # Error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Replace color1 and color2 with your desired colors
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
POC_health

# Replace 'pere' with 'perennial' in the AP column
data_clean$AP[data_clean$AP == "pere"] <- "perennial"

# Create a plot with the regression line and error bars for MAOC
MAOC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_mgCpergSoilM - se_mgCpergSoilM, ymax = mean_mgCpergSoilM + se_mgCpergSoilM), width = 0.2) +  # Error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
MAOC_health

# Create a plot with the regression line and error bars for Proportion of Carbon as MAOC
PropMAOC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_propM, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_propM - se_propM, ymax = mean_propM + se_propM), width = 0.2) +  # Error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
PropMAOC_health

# Arrange the plots side by side with shared legend
Figure_7dhealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             labels = c("a", "b", "c"),  # Labels for each plot
                             label.x = c(0.02, 0.02, 0.02),  # Position labels on the left
                             label.y = c(1.05, 1.05, 1.05),  # Position labels above the plots
                             common.legend = TRUE,  # Share a legend
                             legend = "top")  # Position legend at the top

# Adjust the legend text size
Figure_7dhealth <- Figure_7dhealth + 
  theme(legend.text = element_text(size = 16),  # Increase legend text size
        legend.title = element_text(size = 18),  # Increase legend title size
        legend.key.size = unit(1.5, "cm"))  # Increase legend key size for better visibility

# Save the combined figure
ggsave("Figure_7dhealth.jpeg", width = 15, height = 8)
# Arrange the plots side by side with shared legend
Figure_7ehealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns











# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
POC_health

# Replace 'pere' with 'perennial' in the AP column
data_clean$AP[data_clean$AP == "pere"] <- "perennial"
view(data_clean)

# Create a plot with the regression line for MAOC
MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
MAOC_health

# Create a plot with the regression line for PropMAOC
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
PropMAOC_health



## Calculate overall mean and standard error for propM
data_summary <- data_clean %>%
  summarise(
    mean_propM = mean(propM, na.rm = TRUE),  # Calculate overall mean
    n = n(),  # Count total number of observations
    se_propM = ifelse(n > 1, sd(propM, na.rm = TRUE) / sqrt(n), NA)  # Calculate SE
  )

# View the summary to check for calculated values
print(data_summary)

# Calculate overall mean and standard error for propM
data_summary <- data_clean %>%
  summarise(
    mean_propM = mean(propM, na.rm = TRUE),  # Calculate overall mean
    n = n(),  # Count total number of observations
    se_propM = ifelse(n > 1, sd(propM, na.rm = TRUE) / sqrt(n), NA)  # Calculate SE
  )

# Calculate overall mean and standard error for y_variable
overall_mean <- mean(data_clean$mgCpergSoilP, na.rm = TRUE)
overall_se <- sd(data_clean$mgCpergSoilP, na.rm = TRUE) / sqrt(nrow(data_clean))

# Create a plot with a single point and error bars
ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP)) +
  geom_point(alpha = 0.5) +  # Original data points
  geom_errorbar(aes(ymin = overall_mean - overall_se, ymax = overall_mean + overall_se), 
                width = 0.2) +  # Error bars at the overall mean
  labs(x = "Soil Health Index", y = "Y Variable") +
  theme_minimal()


# Get a representative x value (e.g., the mean overall.score)
mean_x_value <- mean(data_clean$overall.score, na.rm = TRUE)

# Create a plot with the regression line for PropMAOC with error bars
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +  # Original data points
  geom_errorbar(data = data_summary, 
                aes(x = mean_x_value, ymin = mean_propM - se_propM, ymax = mean_propM + se_propM), 
                width = 0.2) +  # Error bars at the mean x value
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
PropMAOC_health



library(ggpubr)

# Arrange the plots side by side with shared legend
Figure_7ehealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             
                             


                             Figure_7ehealth



                             
                        
                             # Fit linear models for each response variable
                             model_POC <- lm(mgCpergSoilP ~ overall.score, data = data_clean)
                             model_MAOC <- lm(mgCpergSoilM ~ overall.score, data = data_clean)
                             model_PropMAOC <- lm(propM ~ overall.score, data = data_clean)
                             
                             # Summarize the models to extract coefficients and significance
                             summary_POC <- summary(model_POC)
                             summary_MAOC <- summary(model_MAOC)
                             summary_PropMAOC <- summary(model_PropMAOC)
                             
                             # Extract slopes (coefficients) and p-values for overall.score
                             slope_POC <- summary_POC$coefficients["overall.score", "Estimate"]
                             p_value_POC <- summary_POC$coefficients["overall.score", "Pr(>|t|)"]
                             
                             slope_MAOC <- summary_MAOC$coefficients["overall.score", "Estimate"]
                             p_value_MAOC <- summary_MAOC$coefficients["overall.score", "Pr(>|t|)"]
                             
                             slope_PropMAOC <- summary_PropMAOC$coefficients["overall.score", "Estimate"]
                             p_value_PropMAOC <- summary_PropMAOC$coefficients["overall.score", "Pr(>|t|)"]
                             
                             # Print slopes and p-values
                             cat("Slope and p-value for mgCpergSoilP:\n")
                             cat("Slope:", slope_POC, "P-value:", p_value_POC, "\n")
                             
                             cat("Slope and p-value for mgCpergSoilM:\n")
                             cat("Slope:", slope_MAOC, "P-value:", p_value_MAOC, "\n")
                             
                             cat("Slope and p-value for propM:\n")
                             cat("Slope:", slope_PropMAOC, "P-value:", p_value_PropMAOC, "\n")                           
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             

# Adjust the legend text size within each plot
POC_health <- POC_health + 
  theme(legend.text = element_text(size = 14),  # Increase legend item text size
        legend.title = element_blank())  # Ensure no legend title

MAOC_health <- MAOC_health + 
  theme(legend.text = element_text(size = 14),  # Increase legend item text size
        legend.title = element_blank())  # Ensure no legend title

PropMAOC_health <- PropMAOC_health + 
  theme(legend.text = element_text(size = 14),  # Increase legend item text size
        legend.title = element_blank())  # Ensure no legend title

# Arrange the plots side by side with shared legend
Figure_7dhealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             labels = c("a", "b", "c"),  # Labels for each plot
                             label.x = c(0.02, 0.02, 0.02),  # Position labels on the left
                             label.y = c(1.05, 1.05, 1.05),  # Position labels above the plots
                             common.legend = TRUE,  # Share a legend
                             legend = "top")  # Position legend at the top

# Save the combined figure
ggsave("Figure_7dhealth.jpeg", width = 15, height = 8)



# Arrange the plots side by side with shared legend
Figure_combined <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             labels = c("a", "b", "c"),  # Labels for each plot
                             label.x = c(0.1, 0.5, 0.9),  # Adjust x positions of labels
                             label.y = c(1, 1, 1),  # Keep labels at the top
                             common.legend = TRUE,  # Share a legend
                             legend = "top")  # Position legend at the top

# Adjust the legend position to overlap with the first plot
Figure_7.health <- annotate_figure(Figure_combined,
                                   top = text_grob("", vjust = 0.5),  # Add space for legend
                                   bottom = text_grob("", vjust = 0.5))

# Display the combined figure
print(Figure_7.health)
ggsave("Figure_7.health.jpeg", width = 15, height = 8)


# Remove rows with NA values in the relevant columns
data_clean <- na.omit(data[, c("overall.score", "mgCpergSoilP", "AP")])

POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE) +  # 'color' aesthetic in ggplot will be used
  labs(
    x = "Soil Health Index",
    y = expression("mg POC " * g^{-1} * " soil")
  ) +
  theme_minimal()

POC_health
# Remove rows with NA values in the relevant columns
data_clean <- na.omit(data[, c("overall.score", "mgCpergSoilM", "AP")])

MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE) +  # 'color' aesthetic in ggplot will be used
  labs(
    x = "Soil Health Index",
    y = expression("mg MAOC " * g^{-1} * " soil")
  ) +
  theme_minimal()

MAOC_health

ggsave("POC_health.jpeg", width = 15, height = 8)

   # Perform linear regression MAOC
  regression_model_MAOC <- lm(mgCpergSoilM ~ overall.score, data = data)
  summary
  

  # Create a plot with the regression line
  MAOC_health <- ggplot(data, aes(x = overall.score, y = mgCpergSoilM, color=AP)) +
    geom_point(alpha = 0.5) +
    stat_smooth(method = "lm", se = FALSE, color = "black") +
    labs(x = "Soil Health Index",
         y = expression("mg MAOC g"^-1~"soil")) +
    theme_minimal()
  ggsave("MAOC_health.jpeg", width = 15, height = 8)
  
   # Perform linear regression Prop MAOC
  regression_model_propMAOC <- lm(logitpropM ~ overall.score, data = data)
  summary(regression_model_propMAOC)
  
  # Create a plot with the regression line
  PropM_health <- ggplot(data, aes(x = overall.score, y = logitpropM, color=AP)) +
    geom_point(alpha = 0.5) +
    stat_smooth(method = "lm", se = FALSE, color = "black") +
    labs(x = "Soil Health Index",
         y = expression("Proportion of carbon as MAOC")) +
    theme_minimal()
  ggsave("PropM_health.jpeg", width = 15, height = 8)
  soilhealth3panel<- ggarrange(POC_health, MAOC_health, PropM_health,nrow=1,ncol=3, common.legend=T, legend="left", labels=c("a","b", "c"))
ggsave("soilhealth3panel.jpeg", width = 15, height = 8)
  
  # Define the coefficient for soil health regression (slopes)
  coef_POC <- .257  # in mg find in model summary
  coef_MAOC <- .377
  coef_PropM <- -.008
  # Define the mean values for each response variable
    mean_POC <- 8.17  
    mean_MAOC <- 16.77
    mean_PropM <- .76
  percentage_increase <- 10  #set a percentage increase of soil health based on data
    # Calculate the absolute increase in POC for the given percentage increase in aggregate stability
  absolute_increase_poc <- coef_POC * percentage_increase
  absolute_increase_maoc <- coef_MAOC * percentage_increase
  absolute_increase_propmaoc <- coef_PropM * percentage_increase
  # Calculate the percent increase in POC for a 1% increase in aggregate stability
  Onepercent_increase_poc <- (coef_POC / mean_POC) * 100
  Onepercent_increase_maoc <- (coef_MAOC / mean_MAOC) * 100
  Onepercent_increase_propmaoc <- (coef_PropM / mean_PropM) * 100
  # Calculate the percent increase in POC based on the mean value
  percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100
  percent_increase_maoc <- (absolute_increase_maoc / mean_MAOC) * 100
  percent_increase_propmaoc <- (absolute_increase_propmaoc / mean_PropM) * 100
    # Print the result POC
  print(paste("Absolute increase in POC for a 10 unit in soil health index is", round(absolute_increase_poc, 2), "mg"))
  print(paste("Percent increase in POC for a 1 unit increase in soil health index is", round(Onepercent_increase_poc, 2), "%"))
  print(paste("Percent increase in POC for a", percentage_increase, "% increase in soil health is", round(percent_increase_poc, 2), "%"))
  # Print the result MAOC
  print(paste("Absolute increase in MAOC for a 10 unit in soil health index is", round(absolute_increase_maoc, 2), "mg"))
  print(paste("Percent increase in MAOC for a 1 unit increase in soil health index is", round(Onepercent_increase_maoc, 2), "%"))
  print(paste("Percent increase in MAOC for a", percentage_increase, "% increase in soil health is", round(percent_increase_maoc, 2), "%"))
  # Print the result Prop MAOC
  print(paste("Absolute increase in Prop MAOC for a 10 unit in soil health index is", round(absolute_increase_propmaoc, 2), "%"))
  print(paste("Percent increase in Prop MAOC for a 1 unit increase in soil health index is", round(Onepercent_increase_propmaoc, 2), "%"))
  print(paste("Percent increase in Prop MAOC for a", percentage_increase, "% increase in soil health is", round(percent_increase_propmaoc, 2), "%"))
  


#Correlation plot
cordata <- cor(data[,c("mgCpergSoilP","overall.score","mgCpergSoilM","logitpropM")], use="pairwise.complete.obs", method="pearson")
corrplot(cordata)
cordata

#view na for ph: Z1, Z2 are truly NA
missing_ph <- subset(data, is.na(ph) | ph == "")
missing_field_codes <- missing_ph$Field_Code
print(missing_field_codes)

missing_mgCpergSoilP <- subset(data, is.na(mgCpergSoilP) | mgCpergSoilP == "")
missing_field_codes <- missing_mgCpergSoilP$Field_Code
print(missing_field_codes)

#First, graphically explore relationships among independent variables to look for interactions


data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=ppt.cm, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=ph, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=aggregate_stability, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

#more interactions with ph
summary(data$ph)

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=ppt.cm, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=aggregate_stability, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=soil_texture_clay, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

#interactions with ppt

data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")


data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=aggregate_stability, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")

summary(data$ppt.cm)
data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")


data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")

#interactions with aggregate stability
summary(data$aggregate_stability)

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=ph, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=ppt.cm, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=soil_texture_clay, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

#tmeanC and active carbon
summary(data$tmeanC)

data <- data %>% 
  mutate(tmeanCcategory=cut(tmeanC, breaks=c(-Inf,6.8, 7.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=tmeanC))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ tmeanCcategory, ncol=1, scales="free_x")

#Models
#Correlation plot
cordata <- cor(data[,c("mgCpergSoilP","ph","ppt.cm","tmeanC","aggregate_stability","soil_texture_clay","active_carbon")], use="pairwise.complete.obs", method="pearson")
corrplot(cordata)
print(cordata)

##Linear Mixed Model for dependent variable (mgCpergSoilP)
#test without random effect, because only one value per field

m1P=gls(mgCpergSoilP~ppt.cm*tmeanC+soil_texture_clay+
          aggregate_stability+active_carbon+ 
          ph, data=data, na.action=na.exclude, method="ML")
summary(m1P)

m2P=gls(mgCpergSoilP~ppt.cm*tmeanC+soil_texture_clay+
          +aggregate_stability+active_carbon, data=data, na.action=na.exclude, method="ML")
summary(m2P)
anova(m1P, m2P)
library(nlme)
m3P=gls(mgCpergSoilP~ppt.cm*tmeanC
           +aggregate_stability+active_carbon+ph, 
         data=data, na.action=na.exclude, method="ML")
summary(m3P)
anova(m2P,m3P)
anova(m3P)

n <- nobs(m3P)
print(n)


# Perform ANOVA on the model
anova_result <- anova(m3P)

# Print the ANOVA table
print(anova_result)

# Extract the degrees of freedom for each variable
num_df <- anova_result$"numDF"  # Numerator degrees of freedom
den_df <- anova_result$"denDF"  # Denominator degrees of freedom

# Print the degrees of freedom
print(num_df)
print(den_df)

#pseudo R squared calculation (fit between model predicted data and actual data)
data$mgCpergSoilP.pred=as.vector(fitted(m3P))
R4=lm(mgCpergSoilP~mgCpergSoilP.pred, data=data, na.action=na.omit)
summary(R4) #r2=.4825

#check assumptions, distrubution of residuals
#final model should use REML
m3P=gls(mgCpergSoilP~ppt.cm*tmeanC
        +aggregate_stability+active_carbon+ph,
        data=data, na.action=na.exclude, method="REML") 
summary(m3P)

n_obs_model <- nobs(m3P)
print(n_obs_model) 
####predict(x= aggregate_stability) percent increase over the range of value obererved. 

F_Final <- fitted(m3P)
R_Final <- residuals(m3P, type = "pearson", scaled = TRUE)
N = !is.na(data$mgCpergSoilP)
Rfull <- NA
Rfull[N] <- R_Final
op <- par(mfrow = c(2,2), mar = c(5,4,1,1))  
plot(F_Final, R_Final)
hist(Rfull)
plot(Rfull ~ data$aggregate_stability)
plot(Rfull ~ data$soil_texture_clay)
plot(Rfull ~ data$active_carbon)
plot(Rfull ~ data$tmeanC)
plot(Rfull ~ data$ppt.cm)
plot(Rfull ~ data$ph)
par(op)

#partial residuals to test that the relationship is linear
#do these for each of the significant predictors (do green and red lines match?)

op <- par(mfrow = c(2,2), mar = c(5,4,1,1)) #this makes it so all the graphs are plotted in the same window (a 2 x 2 grid)

ppt.cm.c <- summary(m3P)$coefficients[2] #predictor coefficient
ppt.cm.pr <- Rfull + ppt.cm.c*data$ppt.cm  #Residuals + pred coef * predictor value
{scatter.smooth(data$ppt.cm, ppt.cm.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(ppt.cm.c*data$ppt.cm ~ data$ppt.cm), col = "red")} 

soil_texture_clay.c <- summary(m3P)$coefficients[3] #predictor coefficient
soil_texture_clay.pr <- Rfull + soil_texture_clay.c*data$soil_texture_clay  #Residuals + pred coef * predictor value
{scatter.smooth(data$soil_texture_clay, soil_texture_clay.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(soil_texture_clay.c*data$soil_texture_clay ~ data$soil_texture_clay), col = "red")} 

aggregate_stability.c <- summary(m3P)$coefficients[5] #predictor coefficient
aggregate_stability.pr <- Rfull + aggregate_stability.c*data$aggregate_stability  #Residuals + pred coef * predictor value
{scatter.smooth(data$aggregate_stability, aggregate_stability.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(aggregate_stability.c*data$aggregate_stability ~ data$aggregate_stability), col = "red")} 

active_carbon.c <- summary(m3P)$coefficients[6] #predictor coefficient
active_carbon.pr <- Rfull + active_carbon.c*data$active_carbon  #Residuals + pred coef * predictor value
{scatter.smooth(data$active_carbon, active_carbon.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(active_carbon.c*data$active_carbon ~ data$active_carbon), col = "red")} 

par(op)

#Visualize significant relationships

#own_theme below sets ggplot parameters for how plots should look. 
own_theme <- theme_bw(base_size = 12) +
  theme(rect = element_blank(),
        axis.ticks = element_line(color = "black"),
        axis.text = element_text(color = "black"),
        axis.line = element_line(color = "black"),
        panel.grid.minor = element_blank())

#ppt and tmeanC, option 1
summary(data$ppt.cm)
summary(data$tmeanC)

pred_pptC <- ggpredict(m3P, terms = c("ppt.cm", "tmeanC[6.8,7.5]"))
pred_pptC$tmean_group <- pred_pptC$group
levels(pred_pptC$tmean_group) <- c("low (4.5-7.2)",  
                                   "high (7.2-8.6)")
data <- data %>%
  drop_na(tmeanC) %>% 
  dplyr::mutate(tmean_group = cut(tmeanC, breaks = c(4.5,7.2,8.6)))

levels(data$tmean_group) <- c("low (4.5-7.2)",  
                              "high (7.2-8.6)")

mgPOM_pptC <-data %>% 
  ggplot() +
  geom_point(aes(x = ppt.cm, y = mgCpergSoilP, col = tmean_group), #plot your data
             size = 1.5, alpha = 0.5) +
  geom_line(pred_pptC, mapping = aes(x=x, y=predicted, col = tmean_group), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  #theme(legend.position = "none") +
  scale_y_continuous(expression("mg C in POM per g soil")) +
  scale_x_continuous(expression("Mean Annual Precipitation (cm)"),
                     label = scales::comma) +
  scale_color_manual(values = c("blue", "red")) # adjust colors if needed

mgPOM_pptC

ggsave("mgPOM_ppt_tmeanC.jpeg", width = 4, height = 3)


#ppt and tmeanC, option 2, Figure 4 Final
summary(data$ppt.cm)
pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC","ppt.cm[101,110]"))
pred_tmeanppt$ppt_group <- pred_tmeanppt$group
levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                   "high (104-142)")
data <- data %>%
  drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 levels(data$ppt_group) <- c("low (92-104)",  
                            "high (104-142)")
  mgPOM_tmeanppt <-data %>% 
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), #plot your data
              size = 1.5, alpha = 0.5) +
   geom_line(pred_tmeanppt, mapping = aes(x=x, y=predicted, col = ppt_group), #plot the model's prediction (based on linear )
             lwd = 1) +
   own_theme+
   #theme(legend.position = "none") +
   scale_y_continuous(expression("mg POC g"^-1 * "soil")) +
   scale_x_continuous(expression("Mean Annual Temperature(C)"),
                      label = scales::comma) +
   scale_color_manual(name = "Mean Annual Precipitation (cm)", values = c("red", "blue"))+
    theme_minimal()
  theme(
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    axis.line = element_line(color = "black") 
  )
 mgPOM_tmeanppt
 ggsave("mgPOM_Figure4.jpeg", width = 10, height = 8)
 
 #add axes line for Figure4a
 #ppt and tmeanC, option 2, Figure 4 Final
 summary(data$ppt.cm)
 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC","ppt.cm[101,110]"))
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                      "high (104-142)")
 data <- data %>%
   drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 levels(data$ppt_group) <- c("low (92-104)",  
                             "high (104-142)")
 
 # Plot new Figure with axes labels
 mgPOM_tmeanppt <- data %>% 
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), # Plot your data
              size = 1.5, alpha = 0.5) +
   geom_line(pred_tmeanppt, mapping = aes(x = x, y = predicted, col = ppt_group), # Plot the model's prediction
             lwd = 1) +
   own_theme +  # Apply your custom theme
   scale_y_continuous(expression("mg POC g"^-1 * "soil")) +
   scale_x_continuous(expression("Mean Annual Temperature(C)"),
                      label = scales::comma) +
   scale_color_manual(name = "Mean Annual Precipitation (cm)", values = c("red", "blue")) +
   theme_minimal() +  # Use minimal theme
   theme(
     axis.title = element_text(size = 14),      # Font size for axis labels
     axis.text = element_text(size = 12),       # Font size for axis text
     legend.title = element_text(size = 14),    # Font size for legend title
     legend.text = element_text(size = 12),     # Font size for legend text
     axis.line = element_line(color = "black")  # Add black axis lines
   )
 
 # Show the plot
 mgPOM_tmeanppt
 
 
 # ppt and tmeanC, option 2, Figure 4 Final
 summary(data$ppt.cm)
 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC", "ppt.cm[101,110]"))
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                      "high (104-142)")
 
 data <- data %>%
   drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 levels(data$ppt_group) <- c("low (92-104)",  
                             "high (104-142)")
 
 # Plot
 mgPOM_tmeanppt <- data %>% 
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), # Plot your data
              size = 1.5, alpha = 0.5) +
   geom_line(pred_tmeanppt, mapping = aes(x = x, y = predicted, col = ppt_group), # Plot the model's prediction
             lwd = 1) +
   own_theme +  # Apply your custom theme
   scale_y_continuous(expression("mg POC g"^-1 * "soil")) +
   scale_x_continuous(expression("Mean Annual Temperature(C)"),
                      label = scales::comma) +
   scale_color_manual(name = "Mean Annual Precipitation (cm)", values = c("red", "blue")) +
   theme_minimal() +  # Apply minimal theme
   theme(
     axis.title = element_text(size = 11),    # Font size for axis labels
     axis.text = element_text(size = 11),     # Font size for axis tick labels
     legend.title = element_text(size = 11),  # Font size for legend title
     legend.text = element_text(size = 11),   # Font size for legend text
     axis.line = element_line(color = "black")  # Add black axis lines
   )
 
 # Show the plot
 mgPOM_tmeanppt
 
 
 #fix font
 library(ggplot2)
 library(dplyr)
 library(ggeffects)  # Ensure ggeffects is loaded for ggpredict function
 
 # Generate predictions
 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC", "ppt.cm[101,110]"))
 
 # Assign and update the ppt_group levels in pred_tmeanppt
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 pred_tmeanppt$ppt_group <- factor(pred_tmeanppt$ppt_group, 
                                   levels = c("low", "high"),
                                   labels = c("low (92-104)", "high (104-142)"))
 
 # Prepare the data
 data <- data %>%
   drop_na(ppt.cm) %>%
   mutate(ppt_group = cut(ppt.cm, breaks = c(92, 104, 142),
                          labels = c("low (92-104)", "high (104-142)")))
 
 # Plot the data
 mgPOM_tmeanppt <- ggplot(data) +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, color = ppt_group), 
              size = 1.5, alpha = 0.5) +
   geom_line(data = pred_tmeanppt, aes(x = x, y = predicted, color = ppt_group), 
             size = 1) +
   labs(
     title = "Relationship between Mean Annual Temperature and mg POC per g Soil",
     x = "Mean Annual Temperature (C)",
     y = expression("mg POC g"^-1 * "soil"),
     color = "Mean Annual Precipitation (cm)"
   ) +
   scale_color_manual(values = c("low (92-104)" = "red", "high (104-142)" = "blue")) +
   theme_minimal() +
   theme(
     axis.title = element_text(size = 14),
     axis.text = element_text(size = 12),
     legend.title = element_text(size = 12),
     legend.text = element_text(size = 10)
   )
 
 # Display the plot
 print(mgPOM_tmeanppt)
 
 # Save the plot
 ggsave("mgPOM_Figure4.jpeg", plot = mgPOM_tmeanppt, width = 10, height = 8)
 ``
 
 
 
 
 #tying to get line to end
 #ppt and tmeanC, option 2
 # Ensure predictions are within the range of observed tmeanC values
 # Identify the range of observed data

  # Determine the range of observed data for both factors
 range_tmeanC <- range(data$tmeanC, na.rm = TRUE)
 range_ppt_cm <- range(data$ppt.cm, na.rm = TRUE)
 
 # Generate predictions across a grid within the range of observed data
 tmeanC_seq <- seq(from = range_tmeanC[1], to = range_tmeanC[2], length.out = 100)
 ppt_cm_seq <- seq(from = range_ppt_cm[1], to = range_ppt_cm[2], length.out = 100)
 
 # Create a data frame for prediction
 prediction_data <- expand.grid(tmeanC = tmeanC_seq, ppt.cm = ppt_cm_seq)
 
 # Generate predictions using the model
 predictions <- predict(m3P, newdata = prediction_data, interval = "confidence")

 
summary(m3P)
 # Combine predictions with the prediction data
 pred_tmeanppt <- cbind(prediction_data, predicted = predictions)
 

 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC","ppt.cm[101,110]"))
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                      "high (104-142)")
 data <- data %>%
   drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 
 levels(data$ppt_group) <- c("low (92-104)",  
                             "high (104-142)")
 
 
 # Plot the data and the fitted line
 mgPOM_tmeanppt <- data %>%
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), size = 1.5, alpha = 0.5) +
   geom_line(data = pred_tmeanppt, aes(x = x, y = predicted, col = ppt_group), lwd = 1) +
   own_theme +
   scale_y_continuous(expression("mg POC g"^-1~"soil")) +
   scale_x_continuous(expression("Mean Annual Temperature (C)"),
                      label = scales::comma) +
   scale_color_manual(values = c("red", "blue")) +
   labs(color = "Precipitation Group")
 
 print(mgPOM_tmeanppt)
 
 ggsave(" mgPOM_tmeanppt.jpeg", width = 10, height = 8)
view(data)

#for agg stability color by AP()
pred_aggregate_stability <- ggpredict(m3P, terms = c"aggregate_stability","AP"))
mgPOM_aggregate_stability <-data %>% 
  ggplot() +
  geom_point(aes(x = aggregate_stability, y = mgCpergSoilP,color=AP),
                     size = 1.5, alpha = 0.5) +
  geom_line(pred_aggregate_stability, mapping = aes(x=x, y=predicted,color=group), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  #theme(legend.position = "none") +
  scale_y_continuous(
    name = expression("mg POC " * g^{-1} * " soil")
  )
scale_x_continuous(expression("Aggregate Stability (%)"),
                     label = scales::comma) 

mgPOM_aggregate_stability
ggsave("mgPOM_aggregate_stability.jpeg", width = 15, height = 8, units="cm")

library(ggplot2)
library(ggeffects)
library(dplyr)

# Define the coefficient for active carbon
coef_activecarbon <-  0.01317  # in ppm
# Define the mean value of POC (baseline POC)
mean_POC <- 8.17  # Replace with the actual mean value from your data
# Define the ppm increase in active carbon
ppm_increase <- 100  # For a 100 ppm increase in active carbon

# Calculate the absolute increase in POC for the given ppm increase in active carbon
absolute_increase_poc <- coef_activecarbon * ppm_increase

# Calculate the percent increase in POC based on the mean value
percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100

# Print the result
print(paste("Percent increase in POC for a", ppm_increase, "ppm in active carbon is", round(percent_increase_poc, 2), "%"))


# Assuming 'data' is your data frame and 'mgCpergSoilP' is the column name for POC
mean_poc <- mean(data$mgCpergSoilP, na.rm = TRUE)

# Print the mean POC value
print(paste("The mean POC is", round(mean_poc, 2), "mg"))



# Generate predictions from the model
pred_aggregate_stability <- ggpredict(m3P, terms = c("aggregate_stability"))
# Convert the ggpredict object to a data frame
pred_df <- as.data.frame(pred_aggregate_stability)

# Create the plot

  View(data)
  mgPOM_aggregate_stability <- data %>%
    ggplot(aes(x = aggregate_stability, y = mgCpergSoilP)) +
    geom_point(size = 1.5, alpha = 0.5) +
    geom_line(data = pred_df, aes(x = x, y = predicted), color = "black", lwd = 1) +  # Plot the model's prediction
    own_theme +  # Ensure 'own_theme' is defined or remove it
    theme(legend.position = "none") +
    scale_y_continuous(name = expression("mg POC " * g^{-1} * " soil")) +
    scale_x_continuous(name = expression("Aggregate Stability (%)"),
                       labels = scales::comma)
  
  mgPOM_aggregate_stability
  
ggsave("mgPOM_aggregate_stability.jpeg", width = 4, height = 3)

# Define the coefficient for aggregate stability
coef_aggregate_stability <- 0.06799  # in mg find in model summary
# Define the mean value of POC 
mean_POC <- 8.17  # Replace with the actual mean value from data
percentage_increase <- 10  #set a percentage increase of agg stability based on data

# Calculate the absolute increase in POC for the given percentage increase in aggregate stability
absolute_increase_poc <- coef_aggregate_stability * percentage_increase
# Calculate the percent increase in POC for a 1% increase in aggregate stability
Onepercent_increase_poc <- (coef_aggregate_stability / mean_POC) * 100
# Calculate the percent increase in POC based on the mean value
percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100

# Print the result
print(paste("Absolute increase in POC for a 10% increase in aggregate stability is", round(absolute_increase_poc, 2), "mg"))
# Print the result
print(paste("Percent increase in POC for a 1% increase in aggregate stability is", round(Onepercent_increase_poc, 2), "%"))
# Print the result
print(paste("Percent increase in POC for a", percentage_increase, "% increase in aggregate stability is", round(percent_increase_poc, 2), "%"))


# Define the coefficient for active carbon
coef_activecarbon <-  0.01317  # in ppm
# Define the mean value of POC (baseline POC)
mean_POC <- 8.17  # Replace with the actual mean value from your data
# Define the ppm increase in active carbon
ppm_increase <- 100  # For a 100 ppm increase in active carbon

# Calculate the absolute increase in POC for the given ppm increase in active carbon
absolute_increase_poc <- coef_activecarbon * ppm_increase

# Calculate the percent increase in POC based on the mean value
percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100

# Print the result
print(paste("Percent increase in POC for a", ppm_increase, "ppm in active carbon is", round(percent_increase_poc, 2), "%"))


# Assuming 'data' is your data frame and 'mgCpergSoilP' is the column name for POC
mean_poc <- mean(data$mgCpergSoilP, na.rm = TRUE)

# Print the mean POC value
print(paste("The mean POC is", round(mean_poc, 2), "mg"))

#Figure 3b

# Generate predictions from the model
pred_active_carbon <- ggpredict(m3P, terms = c("active_carbon"))
# Convert the ggpredict object to a data frame
pred_df <- as.data.frame(pred_active_carbon)

# Create the plot
mgPOM_active_carbon <- data %>%
  ggplot(aes(x = active_carbon, y = mgCpergSoilP)) +
  geom_point(size = 1.5, alpha = 0.5) +
  geom_line(data = pred_df, aes(x = x, y = predicted), color = "black", lwd = 1) +  # Change color of the line
  own_theme +  
  theme(legend.position = "none") +
  scale_y_continuous(
    name = expression("mg POC " * g^{-1} * " soil")
  ) +
  scale_x_continuous(
    name = expression("Active Carbon (ppm)"),
    labels = scales::comma
  )

mgPOM_active_carbon
ggarrange(mgPOM_aggregate_stability,mgPOM_active_carbon,nrow=1, common.legend=T, legend="left", labels=c("a","b"))

# Arrange plots in a 2x2 layout without a legend
Figure2Final<- ggarrange(mgPOM_aggregate_stability, mgPOM_active_carbon, 
          mgMAOM_aggregate_stability, mgMAOM_active_carbon, 
          nrow = 2, ncol = 2, 
          labels = c("a", "b", "c", "d"), 
          common.legend = FALSE)
# Save the plot using ggsave
ggsave("Figure2Final.jpeg", plot = Figure2Final, width = 10, height = 8, dpi = 300)



#ppt on own
pred_ppt <- ggpredict(m3P, terms = c("ppt.cm"))
mgPOM_ppt <-data %>% 
  ggplot() +
  geom_point(aes(x = ppt.cm, y = mgCpergSoilP), #plot your data
             size = 1.5, alpha = 0.5) +
  geom_line(pred_ppt, mapping = aes(x=x, y=predicted), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  theme(legend.position = "none") +
  scale_y_continuous(expression("mg C in POM per g soil"))+
  scale_x_continuous(expression("mean annual precipitation (cm)"),
                     label = scales::comma) 

mgPOM_ppt

#tmeanC on own
pred_temp <- ggpredict(m3P, terms = c("tmeanC"))
mgPOM_temp <-data %>% 
  ggplot() +
  geom_point(aes(x = tmeanC, y = mgCpergSoilP), #plot your data
             size = 1.5, alpha = 0.5) +
  geom_line(pred_temp, mapping = aes(x=x, y=predicted), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  theme(legend.position = "none") +
  scale_y_continuous(expression("mg C in POM per g soil"))+
  scale_x_continuous(expression("mean annual temperature (C)"),
                     label = scales::comma) 

mgPOM_temp


# Create a violin plot with individual data points
ggplot(data, aes(x = Type.x, y = mgCpergSoilP)) +
  geom_violin(trim = FALSE, fill = "lightblue") +  # Create the violin plot
  geom_jitter(width = 0.2, size = 1, color = "darkblue") +  # Add jittered points
  labs(title = "Distribution of mg POM by Field Type",
       x = "Field Type",
       y = "mgC per g Soil POM") +
  theme_minimal()  # Apply a minimal theme for a clean look   

# Create a violin plot with individual data points and mean line
ggplot(data, aes(x = Type.x, y = mgCpergSoilP, color = Type.x, fill = Type.x)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1) +  # Add jittered points
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
  labs(title = "Distribution of mgCpergSoilP by Field Type",
       x = "Field Type",
       y = "mgC per g Soil POM") +
  theme_minimal()  # Apply a minimal theme for a clean look

# Create a violin plot with individual data points and mean line for soil texture class
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, color = soil_texture_class, fill = soil_texture_class)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1) +  # Add jittered points
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
  labs(title = "Distribution of mgCpergSoilP by Field Type",
       x = "Soil Texture Class",
       y = "mgC per g Soil POM") +
  theme_minimal()  # Apply a minimal theme for a clean look

# Create a violin plot with individual data points and mean line for soil texture class
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, color = soil_texture_class, fill = soil_texture_class)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1) +  # Add jittered points
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
  labs(title = "Distribution of mgCpergSoilP by Soil Texture Class",
       x = "Soil Texture Class",
       y = "mgC per g Soil POM") +
  theme_minimal() +  # Apply a minimal theme for a clean look
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),  # Adjust text angle, justification, and size
        plot.margin = margin(5, 5, 10, 5))  # Increase the bottom margin to give more space to labels

# Load necessary library
library(ggplot2)  # For plotting


# Get unique options in soil_texture_class
unique_soil_texture <- unique(data$soil_texture_class)

# Print the unique options
print(unique_soil_texture)

view(data$soil_texture_clay)

# Soil texture and field type
set.seed(123)
data <- data.frame(
  soil_texture_class = sample(c("Sandy", "Loam", "Clayey"), 100, replace = TRUE),
  Type.x = sample(c("Corn", "field crops", "hay", "pasture", "Veg", "corn"), 100, replace = TRUE),
  mgCpergSoilP = rnorm(100, mean = 10, sd = 2)
)

# Create a boxplot or violin plot
ggplot(data, aes(x = cut(soil_texture_clay, breaks = 5), y = Type.x)) +
  geom_boxplot() +  # or geom_violin() for a violin plot
  labs(x = "Soil Texture Clay Levels", y = "Field Type") +
  ggtitle("Comparison of Field Types across Soil Texture Clay Levels")


# Create a violin plot with individual data points and mean line for soil texture and field type
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, fill = Type.x)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1, position = position_jitterdodge()) +  # Add jittered points, dodge by Type.x
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow", position = position_dodge(width = 0.2)) +  # Add mean points, dodge by Type.x
  labs(title = "Distribution of mgCpergSoilP by Soil Texture and Field Type",
       x = "Soil Texture Class",
       y = "mgC per g Soil POM",
       fill = "Field Type") +
  theme_minimal() +  # Apply a minimal theme for a clean look
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),  # Adjust text angle, justification, and size
        plot.margin = margin(5, 5, 10, 5))  # Increase the bottom margin to give more space to labels


#anova by field type to see differences 
field_anova<- aov(mgCpergSoilP~Type.x, data=data)
summary(field_anova)  

TukeyHSD(field_anova)


library(dplyr)

# Remove rows where Type.x is "Wheat"
data_filtered <- data %>% filter(Type.x != "Wheat")
# Remove rows where Type.x is "Wheat"
data_filtered <- filter(data, Type.x != "Field crops")

View(data_filtered)
# Run the ANOVA
field_anova <- aov(mgCpergSoilP ~ Type.x, data = data_filtered)

# Display the summary of the ANOVA
summary(field_anova)
# Run the ANOVA
field_anova <- aov(mgCpergSoilM ~ Type.x, data = data_filtered)

# Display the summary of the ANOVA
summary(field_anova)

# Run the ANOVA
field_anovaProp <- aov(logitpropM ~ Type.x, data = data_filtered)

# Display the summary of the ANOVA
summary(field_anovaProp)


# Calculate means by field type
means_by_field_type <- data %>%
  group_by(Type.x) %>%
  summarise(mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE))

print(means_by_field_type)

#anova by field type to see differences 
field_anova<- aov(mgCpergSoilM~Type.x, data=data)

summary(field_anova)  

TukeyHSD(field_anova)

# Calculate means by field type
means_by_field_type <- data %>%
  group_by(Type.x) %>%
  summarise(mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

print(means_by_field_type)


#anova by field type to see differences 
field_anova<- aov(propM~Type.x, data=data)
summary(field_anova)  
# Calculate means by field type
TukeyHSD(field_anova)
means_by_field_type <- data %>%
  group_by(Type.x) %>%
  summarise(mean_propM = mean(propM, na.rm = TRUE))

print(means_by_field_type)


# Create the new column 'AP'
data <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "Perennial",
    Type.x %in% c("Corn", "Veg") ~ "Annual",
    TRUE ~ NA_character_ # This handles any values not specified in the conditions
  ))

# View the updated dataframe
print(data)
view(data)

#anova by AP to see differences 
AP_anova<- aov(mgCpergSoilP~AP, data=data)
summary(AP_anova)  

TukeyHSD(AP_anova)

# Calculate the means and standard errors
# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    se_mgCpergSoilP = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#AP data for MAOC
#anova by AP to see differences 
APM_anova<- aov(mgCpergSoilM~AP, data=data)
summary(APM_anova)  

TukeyHSD(APM_anova)
summary(APM_anova)

# Calculate the means and standard errors
library(dplyr)

# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#AP data for logitprop MAOC
#anova by AP to see differences 
APPM_anova<- aov(logitpropM~AP, data=data)
summary(APPM_anova)  

TukeyHSD(APM_anova)
summary(APM_anova)

# Calculate the means and standard errors
library(dplyr)

# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_logitpropM = mean(logitpropM, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_logitpropM = mean(logitpropM, na.rm = TRUE),
    se_logitproplM = sd(logitpropM, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)

#AP data for soil health score
#anova by AP to see differences 
APSH_anova<- aov(overall.score~AP, data=data)
summary(APSH_anova)  

TukeyHSD(APSH_anova)
summary(APSH_anova)

# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_overall.score = mean(overall.score, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_overall.score = mean(overall.score, na.rm = TRUE),
    se_overall.score = sd(overall.score, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#anova by field type to see differences MAOC
field_anova<- aov(logitpropM~Type.x, data=data)
summary(field_anova)  

TukeyHSD(field_anova)

# Calculate means
means <- data %>%
  group_by(Type.x) %>%
  summarise(mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(Type.x) %>%
  summarise(
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#anova by soil texture class to see differences 
texture_anova<- aov(mgCpergSoilP~soil_texture_class, data=data)
summary(texture_anova)  

TukeyHSD(texture_anova)
# Create a new column Tillage_Category with descriptive labels
data <- data %>%
  mutate(Tillage_Category = factor(Tillage_1to4,
                                   levels = c(1, 2, 3, 4),
                                   labels = c("No Till", 
                                              "1-7 inch Till", 
                                              "7-9 inch Till", 
                                              ">9 inch Till")))

# Filter perennial crops (hay + pasture)
perennial_data <- data %>%
  filter(Type.x %in% c("Hay"))

# Calculate % that are no-till
percent_no_till <- perennial_data %>%
  summarize(
    pct_no_till = mean(Tillage_1to4 == "1", na.rm = TRUE) * 100
  )

percent_no_till

# Filter hay fields
hay_data <- data %>%
  filter(Type.x %in% c("Hay"))

# Percentage of no-till (Tillage_1to4 == "1")
percent_no_till <- hay_data %>%
  summarize(
    pct_no_till = mean(Tillage_1to4 == 1, na.rm = TRUE) * 100
  )

percent_no_till

# Filter hay fields
hay_data <- data %>%
  filter(Type.x %in% c("Hay"))

# Percentage of no-till (Tillage_1to4 == "1")
percent_no_till <- hay_data %>%
  summarize(
    pct_no_till = mean(Tillage_1to4 == 1, na.rm = TRUE) * 100
  )

percent_no_till

#  Count of fields in each tillage category
tillage_counts <- hay_data %>%
  count(Tillage_1to4)

tillage_counts
hay_data %>%
  group_by(Tillage_1to4) %>%
  summarise(
    Fields = list(Field_Code),
    .groups = "drop"
  )

View(
  hay_data %>%
    group_by(Tillage_1to4) %>%
    summarise(
      Fields = list(Field_Code),
      .groups = "drop"
    )
)






# Check the new column
summary(data$Tillage_Category)


# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = recode(Type.x, "Field crops" = "Wheat"))

# Check the result to ensure the changes were applied correctly
table(data$Type.x)
library(dplyr)

# Convert Type.x to character if it is a factor
data <- data %>%
  mutate(Type.x = as.character(Type.x))

# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = recode(Type.x, "Field crops" = "Wheat"))

library(dplyr)

# Inspect the data type and unique values in Type.x
str(data$Type.x)  # Check the structure of the column
unique(data$Type.x)  # Check unique values

# Convert Type.x to character if it is a factor
data <- data %>%
  mutate(Type.x = as.character(Type.x))

# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = ifelse(Type.x == "Field crops", "Wheat", Type.x))

# Optionally convert back to factor
data$Type.x <- factor(data$Type.x)

# Check the result to ensure the changes were applied correctly
table(data$Type.x)




# Check the result to ensure the changes were applied correctly
table(data$Type.x)

# Create the stacked bar plot

ggplot(data, aes(x = Type.x, fill = factor(Tillage_Category))) +
  geom_bar(position = "stack") +
  labs(title = "",
       x = "Crop Type",
       y = "Number of Fields",
       fill = "Tillage Category") +
  theme_minimal()

library(dplyr)

# Inspect the data type and unique values in Type.x
str(data$Type.x)  # Check the structure of the column
unique(data$Type.x)  # Check unique values

# Convert Type.x to character if it is a factor
data <- data %>%
  mutate(Type.x = as.character(Type.x))

# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = ifelse(Type.x == "Field crops", "Wheat", Type.x))

# Reorder and convert Type.x to factor with the desired levels
data$Type.x <- factor(data$Type.x,
                      levels = c("Hay", "Pasture", "Corn", "Veg", "Wheat"))

# Check the result to ensure the changes were applied correctly
table(data$Type.x)


# Create the stacked bar plot
ggplot(data, aes(x = Type.x, fill = factor(till.passes))) +
  geom_bar(position = "stack") +
  labs(title = "Distribution of Tillage Passes by Field Type",
       x = "Field Type",
       y = "Count",
       fill = "Tillage Category") +
  theme_minimal()


# Perform linear regression
regression_modelPM <- lm(mgCpergSoilM ~ mgCpergSoilP, data = data)

# Perform linear regression
regression_modelMAOC <- lm(mgCpergSoilM ~ Type.x, data = data)
anova(regression_modelMAOC)
# Summarize the regression model
summary(regression_modelPM)

data
regression_modelPOC <- lm(mgCpergSoilP ~ Type.x, data = data)
anova(regression_modelPOC)



#Figure 8 Final This is now Figure 5 submit

Figure8d <- ggplot(data, aes(x = mgCpergSoilP, y = mgCpergSoilM, color= AP)) +
  geom_point(alpha = 0.5) +  # Explicitly set all points to black
  stat_smooth(method = "lm", se = FALSE, color = "black", lwd = 1) +  # Keep the line black
  own_theme +  
  theme(legend.title = element_blank(),
        legend.position = c(0.8, 0.8),# Remove legend
       # axis.title = element_text(size = 12),  # Axis title size
       # axis.text = element_text(size = 12),   # Axis text size
        axis.line = element_line(color = "black"),  # Add axis lines
        axis.ticks = element_line(color = "black"),  # Optional: Add ticks
        strip.background = element_blank()) +  # Remove facet strip background if it's present
  labs(
    x = expression(paste("mg POC ", g^{-1}, " soil")),  # X-axis label
    y = expression(paste("mg MAOC ", g^{-1}, " soil"))) +
  scale_color_manual(values = c("Annual" = "#cd853f", "Perennial" = "darkgreen"))  # Custom colors for annual and perennial



Figure8d



# Save the plot
ggsave("FinalFigures/Figure5_submit.jpeg", plot= Figure8d, width = 4, height = 3, dpi= 600) 


Figure8a
# Fit the linear model
lm_model <- lm(mgCpergSoilM ~ mgCpergSoilP, data = data)

# Get the summary of the model
model_summary <- summary(lm_model)

# Extract slope and p-value
slope <- model_summary$coefficients[2, 1]  # Slope (the coefficient of mgCpergSoilP)
p_value <- model_summary$coefficients[2, 4]  # P-value for the slope

# Print the results
print(paste("Slope:", slope))
print(paste("P-value:", p_value))

# Display the plot
Figure8a

 Figure8a<-ggplot(data, aes(x = mgCpergSoilP, y = mgCpergSoilM)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +
  labs(
    x = expression(paste("mg POC ", g^{-1}, " soil")),
    y = expression(paste("mg MAOC ", g^{-1}, " soil"))
  ) +
  theme_minimal()

# Adjust the legend text size
Figure8a <- Figure8a + 
  theme(legend.text = element_text(size = 16),  # Increase legend text size
        legend.title = element_text(size = 18)) +  # Increase legend title size
  theme(legend.key.size = unit(1.5, "cm"))  # Increase legend key size for better visibility
Figure8a
ggsave("Figure8a.jpeg", width = 15, height = 8)  
  
  

# Subset the data frame to get only the rows where Type.x is 'Field_crops'
  field_crops_samples <- subset(data, Type.x == "Field crops")

# Extract the Field_code for those samples
  field_crops_codes <- field_crops_samples$Field_Code
  
  # Print the result
  print(field_crops_codes)
  
  library(ggplot2)
  library(dplyr)
  library(car) # for Levene's Test
  library(ggpubr) # for easy plotting
  
  # Check the distribution of pH for each Type.x using boxplots
  ggboxplot(data, x = "Type.x", y = "ph", 
            color = "Type.x", palette = "jco",
            ylab = "pH", xlab = "Field Type")
  
  # Check the normality assumption
  shapiro_test <- data %>%
    group_by(Type.x) %>%
    summarise(shapiro_p = shapiro.test(ph)$p.value)
  
  print(shapiro_test)
  
  # Check the homogeneity of variances assumption
  levene_test <- leveneTest(ph ~ Type.x, data = data)
  
  print(levene_test)
  
  # If p-value of Shapiro-Wilk test and Levene's test are greater than 0.05, proceed with ANOVA
  if (all(shapiro_test$shapiro_p > 0.05) && levene_test$p.value > 0.05) {
    # Perform ANOVA
    anova_result <- aov(ph ~ Type.x, data = data)
    summary(anova_result)
    
    # Post-hoc test if ANOVA is significant
    if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
      tukey_result <- TukeyHSD(anova_result)
      print(tukey_result)
    }
  } else {
    # If assumptions are not met, perform the Kruskal-Wallis test
    kruskal_result <- kruskal.test(ph ~ Type.x, data = data)
    print(kruskal_result)
  }
  
  
  # Post-hoc test if ANOVA is significant
  if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
    tukey_result <- TukeyHSD(anova_result)
    print(tukey_result)
    
    # Plot the Tukey HSD results
    plot(tukey_result)
  }
  } else {
    # If assumptions are not met, perform the Kruskal-Wallis test
    kruskal_result <- kruskal.test(ph ~ Type.x, data = data)
    print(kruskal_result)
    
    # If Kruskal-Wallis test is significant, perform post-hoc Dunn test
    if (kruskal_result$p.value < 0.05) {
      library(FSA) # For Dunn test
      dunn_result <- dunnTest(pH ~ Type.x, data = data, method = "bh")
      print(dunn_result)
    }
  }




# test for differences in pH for field types
#all CIs overlap indicatin no sigficant difference
# Perform ANOVA
anova_result <- aov(ph ~ Type.x, data = data)
# Summary of ANOVA
summary(anova_result)
# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result, ~ Type.x)
# Print pairwise comparisons
print(posthoc, type = "compact")

# Example scatter plot with jitter
ggplot(data, aes(x = Type.x, y = ph)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  labs(x = "Field Type", y = "pH") +
  ggtitle("Relationship between pH and Field Type") +
  theme_minimal()

# look at the normality of each variable within each group
shapiro_test_results <- data %>%
  group_by(Type.x) %>%
  summarise(
    K = shapiro.test(k)$p.value,
    Mn = shapiro.test(mn)$p.value,
    Fe = shapiro.test(fe)$p.value,
    Mg = shapiro.test(mg)$p.value,
    Zn = shapiro.test(zn)$p.value
  )
print(shapiro_test_results)

# Perform MANOVA
manova_result <- manova(cbind(k, mn, fe, mg, zn) ~ Type.x, data = data)
summary(manova_result)

# If MANOVA is significant, perform post-hoc tests
summary.aov(manova_result)

# Perform separate ANOVAs with Bonferroni correction
anova_results <- list(
  K = aov(k ~ Type.x, data = data),
  Mn = aov(mn ~ Type.x, data = data),
  Fe = aov(fe ~ Type.x, data = data),
  Mg = aov(mg ~ Type.x, data = data),
  Zn = aov(zn ~ Type.x, data = data)
)

# Print ANOVA summaries
lapply(anova_results, summary)

# Apply Bonferroni correction (or other corrections) to p-values
p_values <- sapply(anova_results, function(x) summary(x)[[1]]$`Pr(>F)`[1])
p_values_adjusted <- p.adjust(p_values, method = "bonferroni")

print(data.frame(Variable = names(p_values), P_value = p_values, Adjusted_P_value = p_values_adjusted))
}

# Perform ANOVAs for each cation
anova_results <- list(
  K = aov(k ~ Type.x, data = data),
  Mn = aov(mn ~ Type.x, data = data),
  Fe = aov(fe ~ Type.x, data = data),
  Mg = aov(mg ~ Type.x, data = data),
  Zn = aov(zn ~ Type.x, data = data)
)

# Print ANOVA summaries
anova_summaries <- lapply(anova_results, summary)
print(anova_summaries)

# Perform Tukey's HSD test if ANOVA is significant
tukey_results <- lapply(anova_results, function(x) {
  if (summary(x)[[1]]$`Pr(>F)`[1] < 0.05) {
    TukeyHSD(x)
  } else {
    NULL
  }
})

# Print Tukey's HSD results
print(tukey_results)

# Optionally plot Tukey's HSD results
par(mfrow = c(3, 2))
for (i in 1:length(tukey_results)) {
  if (!is.null(tukey_results[[i]])) {
    plot(tukey_results[[i]], main = names(tukey_results)[i])
  }
}

#regression of MAOM and tillage

regression_model <- lm(mgCpergSoilM ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)

#graph the regression

# Create a new data frame with predictions
data_with_predictions <- data %>%
  mutate(predicted = predict(regression_model, newdata = data))

library(ggplot2)
library(dplyr)

# Assuming regression_model is already created and data_with_predictions is calculated

# Create a new data frame with predictions for plotting
data_with_predictions <- data %>%
  mutate(predicted = predict(regression_model, newdata = data)) %>%
  group_by(Tillage_1to4) %>%
  summarize(mean_predicted = mean(predicted), 
            mean_mgCpergSoilP = mean(mgCpergSoilP), 
            .groups = 'drop')

# Plot the data
ggplot(data, aes(x = Tillage_1to4, y = mgCpergSoilM)) +
  geom_jitter(width = 0.2, size = 2, alpha = 0.5) +  # Scatter plot with jitter to avoid overplotting
  geom_point(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted), color = "red", size = 3, shape = 1) +  # Predicted values
  geom_line(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted, group = 1), color = "blue", size = 1) +  # Regression line
  labs(title = "Regression of mgCpergSoilP on Tillage_1to4",
       x = "Tillage Category",
       y = "POC mg C per g Soil",
       color = "Legend") +
  scale_x_discrete(labels = c("1" = "No Till", "2" = "1-7inch Till", "3" = "7-9inch Till", "4" = ">9inch Till")) +  # Customize x-axis labels
  theme_minimal()


# Create the data
tillMAOC <- data.frame(
  Tillage_Category = c("No-till", "1-7 inch", "7-9 inch", "> 9 inch"),
  MAOC = c(18.9, 15.9, 15.1, 17.7),
  se = c(1.20, 1.08, 1.66, 2.02)
)

# Perform one-way ANOVA
anova_result <- aov(MAOC ~ Tillage_Category, data = tillMAOC)

# Tukey's post hoc test
tukey_result <- TukeyHSD(anova_result, "Tillage_Category")

# View Tukey's test results
print(tukey_result)

#Supplement Table 1 significance of differences
# Values for No-Till
mean_no_till <- 18.9
se_no_till <- 1.2

# Values for other tillage levels
means_other <- c(15.9, 15.1, 17.7)
ses_other <- c(1.08, 1.66, 2.02)

# Calculate the mean and SE for the comparison group
mean_other <- mean(means_other)
se_other <- sqrt(sum(ses_other^2) / length(ses_other))  # Pooled SE

# Calculate the t-statistic
mean_diff <- mean_no_till - mean_other
t_stat <- mean_diff / sqrt(se_no_till^2 + se_other^2)

# Degrees of freedom for the comparison (approximation)
df <- length(means_other) - 1

# Calculate the p-value
p_value <- 2 * pt(-abs(t_stat), df)

# Output results
mean_other
mean_diff
t_stat
p_value


# Example scatter plot with jitter
library(ggplot2)

ggplot(data, aes(x = as.factor(Tillage_1to4), y = mgCpergSoilP)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "POC") +
  ggtitle("Relationship between Tillage and POC") +
  theme_minimal()

#Ensure Tillage_1to4 is a factor
data <- data %>%
  mutate(Tillage_1to4 = as.factor(Tillage_1to4))

#Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_1to4, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)

# Optionally, plot the Tukey HSD results
plot(tukey_result)


# Load necessary libraries
library(ggplot2)
library(dplyr)
library(multcomp)

# Create a new variable that combines Tillage_1to4 = 2, 3, and 4 into a single group
data <- data %>%
  mutate(Tillage_Grouped = ifelse(Tillage_1to4 == 1, "1", "2, 3, 4"))

# Ensure the new variable is a factor
data$Tillage_Grouped <- as.factor(data$Tillage_Grouped)

View(data)
# Perform ANOVA
anova_result <- aov(mgCpergSoilM ~ Tillage_Grouped, data = data)
summary(anova_result)
# Perform ANOVA
anova_result <- aov(aggregate_stability ~ Tillage_Grouped, data = data)
summary(anova_result)
# Perform ANOVA
anova_result <- aov(aggregate_stability ~ AP, data = data)
summary(anova_result)


# Calculate mean, standard error, and sample size for mgCpergSoilP and mgCpergSoilM by Tillage_Grouped
summary_stats <- data %>%
  group_by(Tillage_Grouped) %>%
  summarize(
    n = n(),  # Sample size
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),  # Mean for mgCpergSoilP
    se_mgCpergSoilP = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n()),  # SE for mgCpergSoilP
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),  # Mean for mgCpergSoilM
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())   # SE for mgCpergSoilM
  )

# View the summary statistics
print(summary_stats)

# Conduct a t-test for mgCpergSoilP
t_test_P <- t.test(mgCpergSoilP ~ Tillage_Grouped, data = data)

# Print the results
print(t_test_P)
# Filter the data to remove NAs in mgCpergSoilP and mgCpergSoilM
data_filtered <- data %>%
  filter(!is.na(mgCpergSoilP), !is.na(mgCpergSoilM))

# Conduct a t-test for mgCpergSoilP
t_test_P <- t.test(mgCpergSoilP ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_P)

# Conduct a t-test for mgCpergSoilM
t_test_M <- t.test(mgCpergSoilM ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_M)




# Filter the data to remove NAs in mgCpergSoilP and mgCpergSoilM
data_filtered <- data %>%
  filter(!is.na(mgCpergSoilP), !is.na(mgCpergSoilM))

# Conduct a t-test for mgCpergSoilP
t_test_P <- t.test(mgCpergSoilP ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_P)

# Conduct a t-test for mgCpergSoilM
t_test_M <- t.test(mgCpergSoilM ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_M)

# Calculate mean and standard error for each group in Tilled_Grouped
summary_stats <- data %>%
  group_by(Tilled_Grouped) %>%
  summarize(
    mean_value = mean(your_column, na.rm = TRUE),  # Replace 'your_column' with the name of the column you want the mean and SE for
    se_value = sd(your_column, na.rm = TRUE) / sqrt(n())  # Standard error calculation
  )

# View the summary statistics
print(summary_stats)


# percent greater POC in notill
mean_P_notill <- 12.5 
mean_p_till <- 7.58

# Calculate the percent increase in POC based on the mean value
percent_increase_poc_till <- (mean_P_notill-mean_p_till) / mean_p_till

percent_increase_poc_till

# percent greater MAOC in notill
mean_M_notill <- 18.9 
mean_m_till <- 16.1

# Calculate the percent increase in POC based on the mean value
percent_increase_maoc_till <- (mean_M_notill-mean_m_till) / mean_m_till

percent_increase_maoc_till

# Means, standard errors, and sample sizes
means <- c(15.9, 15.1, 17.7)
ses <- c(1.08, 1.66, 2.02)
sample_sizes <- c(39, 17, 13)

# Calculate the weighted mean for the non-no-till categories
weighted_mean_non_notill <- sum(means * sample_sizes) / sum(sample_sizes)
weighted_mean_non_notill
combined_se_non_notill <- sqrt(sum((ses^2) * sample_sizes) / sum(sample_sizes))
combined_se_non_notill

# No-till values
mean_notill <- 18.9
se_notill <- 1.20
n_notill <- 34

# Combined non-no-till values
mean_till <- weighted_mean_non_notill
se_till <- combined_se_non_notill
n_till <- sum(sample_sizes)

# Calculate the pooled standard error
pooled_se <- sqrt((se_notill^2 / n_notill) + (se_till^2 / n_till))

# Calculate the t statistic
t_stat <- (mean_notill - mean_till) / pooled_se
t_stat

# Degrees of freedom (approximation for unequal variances)
df <- (se_notill^2 / n_notill + se_till^2 / n_till)^2 / 
  (((se_notill^2 / n_notill)^2 / (n_notill - 1)) + ((se_till^2 / n_till)^2 / (n_till - 1)))

# Calculate the p-value
p_value <- 2 * pt(-abs(t_stat), df)
p_value



# If ANOVA is significant, perform Tukey's HSD test
if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
  tukey_result <- TukeyHSD(anova_result)
  print(tukey_result)
  plot(tukey_result)
} else {
  print("No significant difference between tillage groups.")
}

#compare the means
# Calculate means of mgCpergSoilP for each Tillage Group
means <- data %>%
  group_by(Tillage_Grouped) %>%
  summarise(Mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE))

print(means)

# Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_Grouped, data = data)
summary(anova_result)

# If ANOVA is significant, perform Tukey's HSD test
if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
  tukey_result <- TukeyHSD(anova_result)
  print(tukey_result)
  plot(tukey_result)
} else {
  print("No significant difference between tillage groups.")
}

#compare the means
# Calculate means of mgCpergSoilM for each Tillage Group
means <- data %>%
  group_by(Tillage_Grouped) %>%
  summarise(Mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

print(means)

# Create box plot with means
ggplot(data, aes(x = Tillage_Grouped, y = mgCpergSoilM)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage Grouped", y = "MAOM") +
  ggtitle("Relationship between Tillage and MAOM") +
  theme_minimal()

#Aggregrate stabiity by field type

#Perform ANOVA
anova_result <- aov(aggregate_stability ~ Type.x, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)


#Perform ANOVA
anova_result <- aov(aggregate_stability ~ Tillage_Grouped, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)


# Create box plot with means
ggplot(data, aes(x = Tillage_1to4, y = aggregate_stability)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "Aggregate Stability") +
  ggtitle("Relationship between Tillage and Aggregate Stability") +
  theme_minimal()

# Create scatter plot with regression line and slope
ggplot(data, aes(x = Tillage_Grouped, y = aggregate_stability)) +
  geom_point(alpha = 0.7) +  # Scatter plot of the data points
  geom_smooth(method = "lm", se = TRUE, color = "blue") +  # Add regression line with confidence interval
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Mark means in red
  labs(x = "Tillage", y = "Aggregate Stability") +
  ggtitle("Regression of Tillage vs. Aggregate Stability") +
  theme_minimal() +
  annotate("text", x = Inf, y = Inf, hjust = 1.1, vjust = 1.5, size = 4,
           label = paste("Slope:", round(coef(lm(aggregate_stability ~ Tillage_1to4, data = data))[2], 2)))



#Create the new dataframe 'data_clean' with the necessary filters and grouping
data_clean <- data %>%
  # Remove NAs in Tillage_Grouped, AP, and aggregate_stability
  filter(!is.na(Tillage_Grouped), !is.na(AP), !is.na(aggregate_stability)) %>%
  
  # Create the new column 'AP' based on Type.x
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "perennial",
    Type.x %in% c("Corn", "Veg") ~ "annual",
    TRUE ~ NA_character_  # Handles any unspecified values
  )) %>%
  
  # Reclassify Tillage_Grouped variable as "No-Till" and "Till"
  mutate(Tillage_Grouped = factor(ifelse(Tillage_Grouped == 1, "No-Till", "Till")))

#Supplement Figure
ggplot(data, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Tillage", y = "Aggregate Stability", fill = NULL) +  # Remove legend title
  guides(fill = "none") +  # Remove the legend
  theme_minimal()
# Conduct a two-sample t-test
t_test_result <- t.test(aggregate_stability ~ Tillage_Grouped, data = data_clean)

# Extract the mean difference and p-value
mean_diff <- t_test_result$estimate[1] - t_test_result$estimate[2]
p_value <- t_test_result$p.value

print(mean_diff)
print(p_value)
# Calculate the mean for the No-Till group
mean_no_till <- mean(data_clean$aggregate_stability[data_clean$Tillage_Grouped == "No-Till"], na.rm = TRUE)
# Calculate the mean for the No-Till group
mean_till <- mean(data_clean$aggregate_stability[data_clean$Tillage_Grouped == "Till"], na.rm = TRUE)

# Print the mean
mean_till
# Print the mean
mean_no_till
mean_no_till <- 68.01775  # Mean in No-Till group
mean_till <- 38.63691         # Example mean in Till group, replace with your value

percent_increase <- ((mean_no_till - mean_till) / mean_till) * 100
percent_increase

# Calculate the mean for the Annual and Pere
mean_pere<- mean(data_clean$aggregate_stability[data_clean$AP == "perennial"], na.rm = TRUE)
mean_annual <- mean(data_clean$aggregate_stability[data_clean$AP == "annual"], na.rm = TRUE)
print(mean_pere)
mean_annual
mean_pere <-  66.52411 # Replace
mean_annual <-   36.32961      # Replace

percent_increase <- ((mean_pere - mean_annual) / mean_annual) * 100
percent_increase

# Conduct a two-sample t-test
t_test_result <- t.test(aggregate_stability ~ AP, data = data_clean)

# Extract the mean difference and p-value
mean_diff <- t_test_result$estimate[1] - t_test_result$estimate[2]
p_value <- t_test_result$p.value
p_value

# Determine the y-axis limits from the data
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Remove rows where aggregate_stability is NA (but keep all Tillage_Grouped values)
data_clean <- data_clean[!is.na(data_clean$aggregate_stability), ]

# Rename Tillage_Grouped categories: 1 = "No-Till", 2, 3, 4 = "Till"
data_clean$Tillage_Grouped <- factor(data_clean$Tillage_Grouped, 
                                     levels = c(1, 2, 3, 4), 
                                     labels = c("No-Till", "Till", "Till", "Till"))

# Check that the factor levels are correctly assigned
table(data_clean$Tillage_Grouped)

# Plot for Tillage_Grouped
plot_AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Tillage Type", y = "Aggregate Stability", fill = NULL) +  # Set labels for axes
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

# Print the plot
print(plot_AgTill)



# Plot for AP (Perennial vs Annual)
# Ensure that the levels for AP are in the correct order: "Perennial", "Annual"
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = NULL, y = NULL) +  # Remove y-axis label for this plot
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Set specific colors for the bars
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Ensure correct order of x-axis labels
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

# Combine the two plots side by side with shared y-axis
combined_plot <- ggarrange(plot_AgTill, plot_AgAP,
                           labels = c("a", "b"),  # Add labels A and B
                           ncol = 2, nrow = 1,
                           align = "hv")  # Align both horizontally and vertically

# Print the combined plot
print(combined_plot)

# Optional: Perform a t-test to compare means of aggregate stability between the two groups
t_test_result <- t.test(aggregate_stability ~ Tillage_Grouped, data = data_clean)
print(t_test_result)
# Optionally, plot the Tukey HSD results
plot(tukey_result)

# Create box plot with means
ggplot(data, aes(x = Type.x, y = aggregate_stability)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Field Type", y = "Aggregate Stability") +
  ggtitle("Relationship between Field Type and Aggregate Stability") +
  theme_minimal()

#Active Carbon by field type

#Perform ANOVA
anova_result <- aov(active_carbon ~ Type.x, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)

# Optionally, plot the Tukey HSD results
plot(tukey_result)

# Create box plot with means
ggplot(data, aes(x = Type.x, y = active_carbon)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Field Type", y = "Active Carbon") +
  ggtitle("Relationship between Field Type and Active Carbon") +
  theme_minimal()


# Create box plot with means
ggplot(data, aes(x = Type.x, y = mgCpergSoilP)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Crop Type", y = "mg C POM") +
   theme_minimal()


ggplot(data) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
  geom_jitter(aes(x = Type.x, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
  geom_jitter(aes(x = Type.x, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
  stat_summary(aes(x = Type.x, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  stat_summary(aes(x = Type.x, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
  labs(x = "Crop Type", y = "mg POC(blue) and MAOC (green) g"^-1~"soil") +
  theme_minimal()

library(dplyr)
library(ggplot2)

# Filter out wheat data
filtered_data <- data %>%
  filter(Type.x != "Wheat")

# Create the plot with the filtered data
ggplot(filtered_data) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
  geom_jitter(aes(x = Type.x, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
  geom_jitter(aes(x = Type.x, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
  stat_summary(aes(x = Type.x, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  stat_summary(aes(x = Type.x, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
  labs(x = "Crop Type", y = "mg POC(blue) and MAOC (green) g"^-1~"soil" +
  theme_minimal()

  # Filter out wheat data
  filtered_data <- data %>%
    filter(Type.x != "Wheat")  # Adjust to match the exact value in your dataset
  
  # Create the plot with the filtered data
  ggplot(filtered_data) +
    geom_boxplot(aes(x = Type.x, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
    geom_boxplot(aes(x = Type.x, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
    geom_jitter(aes(x = Type.x, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
    geom_jitter(aes(x = Type.x, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
    stat_summary(aes(x = Type.x, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
    stat_summary(aes(x = Type.x, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
    labs(x = "Crop Type", y = expression("mg POC (blue) and MAOC (green) g"^{-1}~"soil")) +  # Fixed y-axis label
    theme_minimal()
  
  # Create the plot with the filtered data
  ggplot(filtered_data) +
    geom_boxplot(aes(x = AP, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
    geom_boxplot(aes(x = AP, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
    geom_jitter(aes(x = AP, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
    geom_jitter(aes(x = AP, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
    stat_summary(aes(x = AP, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
    stat_summary(aes(x = AP, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
    labs(x = "Crop Type", y = expression("mg POC (blue) and MAOC (green) g"^{-1}~"soil")) +  # Fixed y-axis label
    theme_minimal()

#POM and MAOM
# Perform linear regression
regression_model <- lm(mgCpergSoilM ~ mgCpergSoilP, data = data)

# Summarize the regression model
summary(regression_model)

# Create a plot with the regression line
ggplot(data, aes(x = mgCpergSoilP, y = mgCpergSoilM)) +
  geom_point() +
  geom_smooth(method = "lm", col = "blue") +
  labs(title = "Linear Regression of MAOM on POM",
       x = "POM",
       y = "MAOM") +
  theme_minimal()

#compost
# Count occurrences of "compost" in the column
count_compost <- sum(grepl("compost", data$Soil.amendments, ignore.case = TRUE))

# Output the count
count_compost

#tillage and active carbon


regression_model <- lm(active_carbon ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)

library(ggplot2)
library(dplyr)

# Assuming regression_model is already created

# Create a data frame with predictions for plotting
data_with_predictions <- data %>%
  mutate(predicted = predict(regression_model, newdata = data)) %>%
  group_by(Tillage_1to4) %>%
  summarize(mean_predicted = mean(predicted), 
            mean_active_carbon = mean(active_carbon), 
            .groups = 'drop')

# Plot the data
ggplot(data, aes(x = Tillage_1to4, y = active_carbon)) +
  geom_jitter(width = 0.2, size = 2, alpha = 0.5) +  # Scatter plot with jitter to avoid overplotting
  geom_point(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted), color = "red", size = 3, shape = 1) +  # Predicted values
  geom_line(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted, group = 1), color = "blue", size = 1) +  # Regression line
  labs(title = "Regression of Active Carbon on Tillage Category",
       x = "Tillage Category",
       y = "Active Carbon",
       color = "Legend") +
  scale_x_discrete(labels = c("1" = "No Till", "2" = "1-7inch Till", "3" = "7-9inch Till", "4" = ">9inch Till")) +  # Customize x-axis labels
  theme_minimal()

#tillage and POC


regression_model <- lm(mgCpergSoilP ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)


library(ggplot2)

# Plot with regression line
ggplot(data, aes(x = as.factor(Tillage_1to4), y = mgCpergSoilP)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +  # Scatter plot with jitter
  geom_smooth(method = "lm", se = FALSE, color = "blue", size = 1) +  # Linear regression line
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Mean points
  labs(x = "Tillage", y = "mgCpergSoilP") +
  ggtitle("Relationship between Tillage and mgCpergSoilP") +
  theme_minimal()

# Plot with regression line
ggplot(data, aes(x = as.factor(Tillage_Grouped), y = mgCpergSoilP)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +  # Scatter plot with jitter
  geom_smooth(method = "lm", se = FALSE, color = "blue", size = 1) +  # Linear regression line
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Mean points
  labs(x = "Tillage", y = "mgCpergSoilP") +
  ggtitle("Relationship between Tillage and mgCpergSoilP") +
  theme_minimal()


# Example scatter plot with jitter
library(ggplot2)

ggplot(data, aes(x = as.factor(Tillage_1to4), y = active_carbon)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "PoxC") +
  ggtitle("Relationship between Tillage and PoxC") +
  theme_minimal()

summary(Tillage_1to4)

#tillage and agg stability
# Assuming 'data' is your dataframe
count_by_tillage <- data %>%
  group_by(Tillage_1to4) %>%
  count(Type.x)

# Print the result
print(count_by_tillage)

regression_model <- lm(agg_stability ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)

# Example scatter plot with jitter
library(ggplot2)

ggplot(data, aes(x = as.factor(Tillage_1to4), y = active_carbon)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "PoxC") +
  ggtitle("Relationship between Tillage and PoxC") +
  theme_minimal()

# Calculate means and standard errors of mgCpergSoilP for each Tillage Category
means_and_se <- data %>%
  group_by(Tillage_1to4) %>%
  summarise(
    Mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    Std_Error = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n())  # Standard Error
  )

print(means_and_se)
# Calculate means and standard errors of mgCpergSoilM for each Tillage Category
means_and_se <- data %>%
  group_by(Tillage_1to4) %>%
  summarise(
    Mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    Std_Error = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())  # Standard Error
  )

print(means_and_se)


# Calculate means, standard errors, and sample sizes of mgCpergSoilP for each Tillage Category
means_and_stats <- data %>%
  group_by(Tillage_1to4) %>%
  summarise(
    Mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    Std_Error = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n()),  # Standard Error
    n = n()  # Sample size
  )

print(means_and_stats)

# Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_1to4, data = data)

# Summarize the ANOVA result
summary(anova_result)

# Convert Tillage_1to4 to a factor
data$Tillage_1to4 <- as.factor(data$Tillage_1to4)

# Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_1to4, data = data)

# Summarize the ANOVA result
summary(anova_result)

# Apply Tukey's HSD test
tukey_result <- TukeyHSD(anova_result)

# Print the Tukey HSD result
print(tukey_result)

# Optionally, convert Tukey result to a data frame for better readability
tukey_df <- as.data.frame(tukey_result$`Tillage_1to4`)
print(tukey_df)


# Convert Tillage_1to4 to a factor
data$Tillage_1to4 <- as.factor(data$Tillage_1to4)

# Perform ANOVA
anova_result <- aov(mgCpergSoilM ~ Tillage_1to4, data = data)

# Summarize the ANOVA result
summary(anova_result)

# Apply Tukey's HSD test
tukey_result <- TukeyHSD(anova_result)

# Print the Tukey HSD result
print(tukey_result)

# Optionally, convert Tukey result to a data frame for better readability
tukey_df <- as.data.frame(tukey_result$`Tillage_1to4`)
print(tukey_df)

view (data)
# Using base R with grepl
search_term <- "manure"
result <- data[grepl(search_term, data$column_name, ignore.case = TRUE), ]

# Using dplyr
library(dplyr)
result <- data %>%
  filter(grepl(search_term, column_name, ignore.case = TRUE))

# Print the result
print(result)


# Supplement Figure 2 Final
# Determine the y-axis limits from the data
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Plot for Tillage_Grouped
plot_AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "", y = "Aggregate Stability", fill = NULL) +  # Remove legend title
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

# Plot for AP (Perennial vs Annual)
# Ensure that the levels for AP are in the correct order: "Perennial", "Annual"
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

plot_AgAP <- ggplot(data, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = NULL, y = NULL) +  # Remove y-axis label for this plot
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Set specific colors for the bars
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Ensure correct order of x-axis labels
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

plot_AgAP


# Remove rows where AP is NA (to exclude "NA" category)
data_clean <- data[!is.na(data$AP), ]

# Ensure 'AP' is a factor and levels are set correctly
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

# Determine the y-axis limits from the data (if needed)
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Plot for AP on x-axis and Aggregate Stability on y-axis
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot with no outliers
  geom_jitter(width = 0.2, alpha = 0.7) +  # Add jittered points for better visibility
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Crop Type", y = "Aggregate Stability") +  # Label x and y axes
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Color for Perennial and Annual
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Set labels for x-axis
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +  # Use minimal theme for better aesthetics
  ylim(y_limits)  # Set the same y-limits

# Display the plot
plot_AgAP






# Combine the two plots side by side with shared y-axis
combined_plot <- ggarrange(plot_AgTill, plot_AgAP,
                           labels = c("a", "b"),  # Add labels A and B
                           ncol = 2, nrow = 1,
                           align = "hv")  # Align both horizontally and vertically

# Print the combined plot
print(combined_plot)




#############################NewCode Updated Final Supplement Figure2#########

# Remove rows where Tillage_Grouped is NA
data_clean <- data[!is.na(data$Tillage_Grouped), ]

# Convert Tillage_Grouped to a factor and rename the levels
data_clean$Tillage_Grouped <- factor(data_clean$Tillage_Grouped,
                                     levels = c(1, 2, 3, 4), 
                                     labels = c("No-Till", "Till", "Till", "Till"))

# Create the plot
AgTill<-ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot with no outliers
  geom_jitter(width = 0.2, alpha = 0.7) +  # Add jittered points
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "", y = "Aggregate Stability", fill = NULL) +  # Axis labels and remove legend title
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +  # Use a minimal theme
  scale_x_discrete(labels = c("No-Till", "Till"))  # Rename x-axis labels


# Remove rows where AP is NA (to exclude "NA" category)
data_clean <- data[!is.na(data$AP), ]

# Ensure 'AP' is a factor and levels are set correctly
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

# Determine the y-axis limits from the data (if needed)
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Plot for AP on x-axis and Aggregate Stability on y-axis
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot with no outliers
  geom_jitter(width = 0.2, alpha = 0.7) +  # Add jittered points for better visibility
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Crop Type", y = "Aggregate Stability") +  # Label x and y axes
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Color for Perennial and Annual
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Set labels for x-axis
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +  # Use minimal theme for better aesthetics
  ylim(y_limits)  # Set the same y-limits

# Display the plot
plot_AgAP


############################# NewCode Updated Final Supplement Figure2 #########

# RECREATE the AP column based on Type.x
# (because your AP column is broken / inconsistent across all versions)
data_clean <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "Perennial",
    Type.x %in% c("Veg", "Corn", "Field Crop") ~ "Annual",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(Tillage_Grouped), !is.na(AP))  # Remove NAs in Tillage_Grouped and AP

# Make factors with correct capitalization
data_clean <- data_clean %>%
  mutate(
    Tillage_Grouped = factor(Tillage_Grouped, levels = c(1, 2, 3, 4),
                             labels = c("No-Till", "Till", "Till", "Till")),
    AP = factor(AP, levels = c("Perennial", "Annual"))  # Correct levels
  )

# --- Step 2: Set color schemes ---

fill_colors_Till <- c("No-Till" = "pink", "Till" = "darkgrey")
fill_colors_AP <- c("Perennial" = "pink", "Annual" = "darkgrey")

# --- Step 3: Set y-axis limits ---

y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# --- Step 4: Create the plots ---

# Plot 1: Tillage_Grouped
AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +  # BLACK points
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +  # Red means
  scale_fill_manual(values = fill_colors_Till) +
  scale_x_discrete(labels = c("No-Till", "Till")) +
  labs(x = "", y = "Aggregate Stability", fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black")
  ) +
  ylim(y_limits)

# Plot 2: AP (Perennial vs Annual)
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +  # BLACK points
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +  # Red means
  scale_fill_manual(values = fill_colors_AP) +
  scale_x_discrete(labels = c("Perennial", "Annual")) +
  labs(x = "", y = NULL, fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  ylim(y_limits)

# --- Step 5: Arrange and save plots ---

SF2 <- grid.arrange(AgTill, plot_AgAP,
                    ncol = 2, nrow = 1,
                    widths = c(1, 1),
                    heights = c(1))
SF2

# Save the plot
ggsave("SF2.jpeg", plot = SF2, width = 10, height = 6, dpi = 300)


###########NEW 4.26.25 percent CLAY 
# --- Step 1: Clean and set up your data ---

# RECREATE the AP column based on Type.x
data_clean <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "Perennial",
    Type.x %in% c("Veg", "Corn", "Field Crop") ~ "Annual",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(Tillage_Grouped), !is.na(AP))  # Remove NAs

# Make factors
data_clean <- data_clean %>%
  mutate(
    Tillage_Grouped = factor(Tillage_Grouped, levels = c(1, 2, 3, 4),
                             labels = c("No-Till", "Till", "Till", "Till")),
    AP = factor(AP, levels = c("Perennial", "Annual"))
  )

# --- Step 2: Set color schemes ---

fill_colors_Till <- c("No-Till" = "pink", "Till" = "darkgrey")
fill_colors_AP <- c("Perennial" = "pink", "Annual" = "darkgrey")

# --- Step 3: Set y-axis limits for soil_texture_clay ---

y_limits <- range(data_clean$soil_texture_clay, na.rm = TRUE)

# --- Step 4: Create the plots ---

# Plot 1: Tillage_Grouped
AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = soil_texture_clay, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +
  scale_fill_manual(values = fill_colors_Till) +
  scale_x_discrete(labels = c("No-Till", "Till")) +
  labs(x = "", y = "Soil Texture Clay (%)", fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black")
  ) +
  ylim(y_limits)

# Plot 2: AP (Perennial vs Annual)
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = soil_texture_clay, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +
  scale_fill_manual(values = fill_colors_AP) +
  scale_x_discrete(labels = c("Perennial", "Annual")) +
  labs(x = "", y = NULL, fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  ylim(y_limits)

# --- Step 5: Arrange the two plots ---

SF3 <- grid.arrange(
  AgTill, plot_AgAP,
  ncol = 2,
  widths = c(1, 1),
  heights = c(1),
  top = ""  # optional title space
)
SF3
# Save the plot
ggsave("SF3_soil_texture_clay.jpeg", plot = SF3, width = 10, height = 6, dpi = 300)


#revisions looking at the relationship between crop type and climate:
view(data)
library(ggplot2)

# Temperature by Type
ggplot(data, aes(x = Type.x, y = tmeanC, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Mean Temperature (C)") +
  theme_minimal()

# Precipitation by Type
ggplot(data, aes(x = Type.x, y = ppt.cm, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Precipitation (cm)") +
  theme_minimal()

# For temperature
anova_temp <- aov(tmeanC ~ Type.x, data = data)
summary(anova_temp)

# For precipitation
anova_ppt <- aov(ppt.cm ~ Type.x, data = data)
summary(anova_ppt)

TukeyHSD(anova_ppt)
TukeyHSD(anova_temp)

version
pkgbuild::find_rtools()
###Spatial Analysis 

install.packages("sf", type = "binary")
install.packages("sp")
install.packages("gstat")
# Install (only need to do once)
install.packages("sf", type = "binary")
install.packages("sp")
install.packages("gstat")

# Load libraries
library(sf)       # for spatial data handling
library(sp)       # for compatibility with gstat
library(gstat)    # for semivariogram analysis

# ---- Convert your data to spatial format ----
# Make sure your dataframe has: Latitude, Longitude, mgCpergSoilP, mgCpergSoilM
# Example structure: data <- data.frame(Longitude = ..., Latitude = ..., mgCpergSoilP = ..., mgCpergSoilM = ...)

# Convert to sf object (WGS84 coordinate system, EPSG:4326)
data_sf <- st_as_sf(data, coords = c("Longitude", "Latitude"), crs = 4326)

# Convert sf to sp (gstat requires sp objects)
data_sp <- as(data_sf, "Spatial")

# ---- Semivariogram for mgCpergSoilP ----
vgm_p <- variogram(mgCpergSoilP ~ 1, data_sp)   # empirical semivariogram
plot(vgm_p, main = "Semivariogram of mgCpergSoilP")

# ---- Semivariogram for mgCpergSoilM ----
vgm_m <- variogram(mgCpergSoilM ~ 1, data_sp)
plot(vgm_m, main = "Semivariogram of mgCpergSoilM")

# ---- (Optional) Fit models to the semivariograms ----
fit_p <- fit.variogram(vgm_p, model = vgm("Sph"))
fit_m <- fit.variogram(vgm_m, model = vgm("Sph"))

plot(vgm_p, model = fit_p, main = "Fitted Semivariogram - mgCpergSoilP")
plot(vgm_m, model = fit_m, main = "Fitted Semivariogram - mgCpergSoilM")


##############CREATE TABLE fore revisons#############

# Temperature by Type
ggplot(data, aes(x = Type.x, y = tmeanC, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Mean Temperature (C)") +
  theme_minimal()

# Precipitation by Type
ggplot(data, aes(x = Type.x, y = ppt.cm, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Precipitation (cm)") +
  theme_minimal()

# For temperature
anova_temp <- aov(tmeanC ~ Type.x, data = data)
summary(anova_temp)

# For precipitation
anova_ppt <- aov(ppt.cm ~ Type.x, data = data)
summary(anova_ppt)

TukeyHSD(anova_ppt)
TukeyHSD(anova_temp)

####Table to respond to revisions################

# Load libraries

library(dplyr)
library(emmeans)
library(multcompView)
responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

results_list <- list()

for (var in responses) {
  
  # Fit ANOVA
  model <- aov(as.formula(paste(var, "~ Type.x")), data = data)
  
  # Mean and range per crop type
  summary_stats <- data %>%
    group_by(Type.x) %>%
    summarise(
      mean = mean(.data[[var]], na.rm = TRUE),
      range = paste0(range(.data[[var]], na.rm = TRUE), collapse = ""),
      .groups = "drop"
    )
  
  # Tukey HSD
  tukey <- TukeyHSD(model)
  
  # Get significance letters
  tukey_letters <- multcompView::multcompLetters(tukey$Type.x[, "p adj"])
  groups_df <- data.frame(
    Type.x = names(tukey_letters$Letters),
    .group = tukey_letters$Letters
  )
  
  # Merge
  result <- summary_stats %>%
    left_join(groups_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- result
}

# Combine all
final_results <- bind_rows(results_list)
print(final_results)

library(dplyr)
library(tidyr)
library(knitr)

# Combine mean + range + significance
final_results_clean <- final_results %>%
  mutate(
    mean = round(mean, 2),
    range = sapply(strsplit(range, ""), function(x) {
      paste(round(as.numeric(x), 2), collapse = "")
    }),
    mean_range_sig = paste0(mean, " (", range, ", ", .group, ")")
  )

# Pivot: one row per variable, one column per crop type
final_wide <- final_results_clean %>%
  select(response, `Crop Type` = Type.x, mean_range_sig) %>%
  pivot_wider(
    names_from = `Crop Type`,
    values_from = mean_range_sig
  ) %>%
  arrange(response) %>%
  rename(Variable = response)

# Display nicely
final_wide %>%
  kable(caption = "Mean, range, and significance letters by crop type for each variable")


library(dplyr)
library(tidyr)
library(openxlsx)
# Step 1: Prepare data
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    mean_sig = paste0(mean_rounded, " (", .group, ")")
  )

# Step 2: Compute overall range per variable
ranges <- final_results_clean %>%
  group_by(response) %>%
  summarise(Full_Range = paste0(round(min(mean), 2), "", round(max(mean), 2)), .groups = "drop")

# Step 3: Pivot to wide format: rows = Crop Type, columns = Variable
final_wide <- final_results_clean %>%
  select(Crop = Type.x, Variable = response, mean_sig) %>%
  pivot_wider(names_from = Variable, values_from = mean_sig)

# Step 4: Create a proper data frame for the range row
range_row <- data.frame(Crop = "Full Range", t(ranges$Full_Range))
names(range_row)[-1] <- ranges$response

# Step 5: Bind the range row on top of the crop rows
final_wide <- bind_rows(range_row, final_wide)

# Now you can continue with writing to Excel and coloring


# Step 4: Create workbook and write data
wb <- createWorkbook()
addWorksheet(wb, "Summary")

writeData(wb, "Summary", final_wide, startCol = 1, startRow = 1)

# Step 5: Define colors for letters
letters_colors <- c(
  "a" = "#D6EAF8",  # light blue
  "b" = "#F9E79F",  # light yellow
  "c" = "#F5B7B1",  # light red
  "ab" = "#D5F5E3", # light green
  "ac" = "#FADBD8", # light pink
  "bc" = "#FCF3CF"  # light cream
)

# Step 6: Apply coloring based on letters in each cell
for(col in 2:ncol(final_wide)) {  # skip first column (Crop)
  for(row in 2:nrow(final_wide)) {  # skip first row (range row)
    cell_val <- final_wide[row, col] %>% as.character()
    if(!is.na(cell_val) && grepl("\\(", cell_val)) {
      # Extract letters from cell
      letter <- sub(".*\\((.*)\\)", "\\1", cell_val)
      # If multiple letters, choose first for color (optional)
      first_letter <- strsplit(letter, "")[[1]][1]
      color <- letters_colors[first_letter]
      if(!is.na(color)) {
        addStyle(wb, "Summary",
                 style = createStyle(fgFill = color),
                 rows = row+1, cols = col, gridExpand = TRUE)
      }
    }
  }
}

# Step 7: Save workbook
saveWorkbook(wb, "CropType_as_Rows_Colored.xlsx", overwrite = TRUE)

###revised code
# Load libraries
library(dplyr)
library(emmeans)
library(multcompView)
library(tidyr)
library(openxlsx)
library(knitr)

responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

results_list <- list()

for (var in responses) {
  
  # Fit ANOVA
  model <- aov(as.formula(paste(var, "~ Type.x")), data = data)
  
  # Mean, range, SEM per crop type
  summary_stats <- data %>%
    group_by(Type.x) %>%
    summarise(
      mean = mean(.data[[var]], na.rm = TRUE),
      sem  = sd(.data[[var]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[var]]))),
      range = paste0(range(.data[[var]], na.rm = TRUE), collapse = ""),
      .groups = "drop"
    )
  
  # Tukey HSD
  tukey <- TukeyHSD(model)
  
  # Get significance letters
  tukey_letters <- multcompView::multcompLetters(tukey$Type.x[, "p adj"])
  groups_df <- data.frame(
    Type.x = names(tukey_letters$Letters),
    .group = tukey_letters$Letters
  )
  
  # Merge
  result <- summary_stats %>%
    left_join(groups_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- result
}

# Combine all
final_results <- bind_rows(results_list)

# Clean + prepare display
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    sem_rounded  = round(sem, 2),
    # Include SEM + significance in parentheses
    mean_sem_sig = paste0(mean_rounded, " ", sem_rounded, " (", .group, ")")
  )

# Compute overall range per variable
ranges <- final_results_clean %>%
  group_by(response) %>%
  summarise(Full_Range = paste0(round(min(mean), 2), "", round(max(mean), 2)), 
            .groups = "drop")

# Pivot to wide format
final_wide <- final_results_clean %>%
  select(Crop = Type.x, Variable = response, mean_sem_sig) %>%
  pivot_wider(names_from = Variable, values_from = mean_sem_sig)

# Add range row
range_row <- data.frame(Crop = "Full Range", t(ranges$Full_Range))
names(range_row)[-1] <- ranges$response
final_wide <- bind_rows(range_row, final_wide)

# Write to Excel
wb <- createWorkbook()
addWorksheet(wb, "Summary")
writeData(wb, "Summary", final_wide, startCol = 1, startRow = 1)

# Colors for significance letters
letters_colors <- c(
  "a" = "#D6EAF8",
  "b" = "#F9E79F",
  "c" = "#F5B7B1",
  "ab" = "#D5F5E3",
  "ac" = "#FADBD8",
  "bc" = "#FCF3CF"
)

# Apply coloring
for(col in 2:ncol(final_wide)) {  # skip Crop column
  for(row in 2:nrow(final_wide)) {  # skip range row
    cell_val <- as.character(final_wide[row, col])
    if(!is.na(cell_val) && grepl("\\(", cell_val)) {
      # Extract significance letters
      letter <- sub(".*\\((.*)\\)", "\\1", cell_val)
      first_letter <- strsplit(letter, "")[[1]][1]
      color <- letters_colors[first_letter]
      if(!is.na(color)) {
        addStyle(wb, "Summary",
                 style = createStyle(fgFill = color),
                 rows = row+1, cols = col, gridExpand = TRUE)
      }
    }
  }
}

saveWorkbook(wb, "CropType_as_Rows_Colored_SEM.xlsx", overwrite = TRUE)

###########Adjusted Script #############
library(nlme)
library(emmeans)
library(multcomp)
library(multcompView)
library(dplyr)
library(tidyr)
library(openxlsx)
# Load libraries
library(nlme)
library(emmeans)
library(multcomp)
library(multcompView)
library(dplyr)
library(tidyr)
library(openxlsx)

# Response variables
responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

# Filter data once and convert Type.x to factor
data_filtered <- data %>%
  filter(Type.x != "Field crops") %>%
  mutate(Type.x = factor(Type.x))

results_list <- list()

for (var in responses) {
  
  # 1 Fit GLS model with variance structure
  model <- gls(as.formula(paste(var, "~ Type.x")),
               data = data_filtered,
               method = "REML",
               weights = varIdent(form = ~1 | Type.x),
               na.action = na.exclude)
  
  # 2 Estimated marginal means
  emm <- emmeans(model, specs = "Type.x", mode = "df.error")
  
  # 3 Tukey pairwise comparisons via glht
  tukey <- glht(model, linfct = mcp(Type.x = "Tukey"))
  tukey_sum <- summary(tukey)
  
  # 4 Named p-values for multcompLetters
  pvals_named <- tukey_sum$test$pvalues
  names(pvals_named) <- rownames(tukey_sum$linfct)
  
  # 5 Generate compact letters
  letters_vec <- multcompLetters(pvals_named)$Letters
  letters_df <- data.frame(Type.x = names(letters_vec), .group = letters_vec)
  
  # 6 Summary table: mean, SE, range, letters
  summary_stats <- as.data.frame(emm)[, c("Type.x", "emmean", "SE")]
  colnames(summary_stats) <- c("Type.x", "mean", "SE")
  
  summary_stats <- summary_stats %>%
    mutate(
      range = paste0(
        round(tapply(data_filtered[[var]], data_filtered$Type.x, min, na.rm = TRUE), 2), "",
        round(tapply(data_filtered[[var]], data_filtered$Type.x, max, na.rm = TRUE), 2)
      )
    ) %>%
    left_join(letters_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- summary_stats
}

# 7 Combine all variables
final_results <- bind_rows(results_list)

# 8 Format columns
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    SE_rounded   = round(SE, 2),
    mean_SE_sig  = paste0(mean_rounded, "  ", SE_rounded, " (", .group, ")"),
    mean_range   = paste0(mean_SE_sig, " | Range: ", range)
  )

# 9 Pivot to wide format
final_wide <- final_results_clean %>%
  dplyr::select(Crop = Type.x, Variable = response, mean_range) %>%
  pivot_wider(names_from = Variable, values_from = mean_range)

#  Write to Excel
wb <- createWorkbook()
addWorksheet(wb, "Summary")
writeData(wb, "Summary", final_wide, startCol = 1, startRow = 1)
saveWorkbook(wb, "CropType_Table.xlsx", overwrite = TRUE)
# Load libraries
library(nlme)
library(emmeans)
library(multcomp)
library(multcompView)
library(dplyr)
library(tidyr)
library(openxlsx)

 
  # Pre-filter NAs for current variable
  data_var <- data_filtered %>% filter(!is.na(.data[[var]]))
  
  # Skip variable if less than 2 levels remain
  if(length(unique(data_var$Type.x)) < 2) next
  
  # 1 Fit GLS model with variance structure
  model <- gls(as.formula(paste(var, "~ Type.x")),
               data = data_var,
               method = "REML",
               weights = varIdent(form = ~1 | Type.x),
               na.action = na.exclude)
  
  # 2 Estimated marginal means
  emm <- emmeans(model, specs = "Type.x", mode = "df.error")
  
  # 3 Tukey pairwise comparisons via glht
  tukey <- glht(model, linfct = mcp(Type.x = "Tukey"))
  tukey_sum <- summary(tukey)
  
  
  # 4 Named p-values for letters
  pvals_named <- tukey_sum$test$pvalues
  names(pvals_named) <- rownames(tukey_sum$linfct)
  
  # 5 Generate compact letters safely
  if(length(pvals_named) > 0 && !all(is.na(pvals_named))) {
    letters_vec <- multcompLetters(pvals_named)$Letters
    letters_df <- data.frame(Type.x = names(letters_vec), .group = letters_vec)
  } else {
    letters_df <- data.frame(Type.x = levels(data_var$Type.x), .group = NA)
  }
  
  # 6 Summary table: mean, SE, range, letters
  summary_stats <- as.data.frame(emm)[, c("Type.x", "emmean", "SE")]
  colnames(summary_stats) <- c("Type.x", "mean", "SE")
  
  summary_stats <- summary_stats %>%
    mutate(
      range = paste0(
        round(tapply(data_var[[var]], data_var$Type.x, min, na.rm = TRUE), 2), "",
        round(tapply(data_var[[var]], data_var$Type.x, max, na.rm = TRUE), 2)
      )
    ) %>%
    left_join(letters_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- summary_stats
}

# 7 Combine all variables
final_results <- bind_rows(results_list)

# 8 Format columns
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    SE_rounded   = round(SE, 2),
    mean_SE_sig  = paste0(mean_rounded, "  ", SE_rounded, " (", .group, ")"),
    mean_range   = paste0(mean_SE_sig, " | Range: ", range)
  )

# 9 Pivot to wide format
final_wide <- final_results_clean %>%
  dplyr::select(Crop = Type.x, Variable = response, mean_range) %>%
  pivot_wider(names_from = Variable, values_from = mean_range)

#  Write to Excel
wb <- createWorkbook()
addWorksheet(wb, "Summary")
writeData(wb, "Summary", final_wide, startCol = 1, startRow = 1)
saveWorkbook(wb, "CropType_Tablev20.xlsx", overwrite = TRUE)

# Response variables




responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

# Filter data once and convert Type.x to factor
data_filtered <- data %>%
  filter(Type.x != "Field crops") %>%
  mutate(Type.x = factor(Type.x))

results_list <- list()

for (var in responses) {
 
###########################################
#new tble with signif diff
library(nlme)
library(emmeans)
library(dplyr)
library(tidyr)

# Filter data and convert Type.x to factor
data_filtered <- data %>%
  filter(Type.x != "Field crops") %>%
  mutate(Type.x = factor(Type.x))

responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

sig_list <- list()

for(var in responses){
  
  # Pre-filter NAs
  data_var <- data_filtered %>% filter(!is.na(.data[[var]]))
  
  if(length(unique(data_var$Type.x)) < 2) next
  
  # Fit GLS with variance structure
  model <- gls(as.formula(paste(var, "~ Type.x")),
               data = data_var,
               method = "REML",
               weights = varIdent(form = ~1 | Type.x),
               na.action = na.exclude)
  
  # Estimated marginal means
  emm <- emmeans(model, specs = "Type.x", mode = "df.error")
  
  # Tukey pairwise comparisons
  pw <- pairs(emm, adjust = "tukey") %>% summary()
  
  # Keep only significant comparisons (p < 0.05)
  sig_pw <- pw %>% as.data.frame() %>% filter(p.value < 0.05)
  
  if(nrow(sig_pw) > 0){
    sig_pw$response <- var
    sig_list[[var]] <- sig_pw
  }
}

# Combine all significant pairwise differences
sig_differences <- bind_rows(sig_list)

# View results
sig_differences
############################




#revisions model code to add variance structure ##

m3P=gls(mgCpergSoilP~ppt.cm*tmeanC
        +aggregate_stability+active_carbon+ph,
        data=data, na.action=na.exclude, method="REML") 

m3P_var <- gls(mgCpergSoilP ~ ppt.cm * tmeanC
               + aggregate_stability + active_carbon + ph,
               data = data,
               na.action = na.exclude,
               method = "REML",
               weights = varIdent(form = ~ 1 | Type.x))

anova(m3P_var)

# Example GLS with heterogeneous variances by crop type
m3P_gls <- gls(
  m3P,
  data = data,
  weights = varIdent(form = ~ 1 | Type.x)
)
summary(m3P)
###MAOC
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC + 
             active_carbon, 
           data = data, 
           na.action = na.exclude, 
           method = "ML")


m4M_var <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC + 
                 active_carbon,
               data = data,
               na.action = na.exclude,
               method = "REML",
               weights = varIdent(form = ~ 1 | Type.x))

anova(m4M_var)

# Example GLS with heterogeneous variances by crop type
m4M_gls <- gls(
  m4M,
  data = data,
  weights = varIdent(form = ~ 1 | Type.x)
)
summary(m4M)

m3P_var <- gls(mgCpergSoilP ~ ppt.cm * tmeanC
               + aggregate_stability + active_carbon + ph,
               data = data,
               na.action = na.exclude,
               method = "REML",
               weights = varIdent(form = ~ 1 | Type.x))

anova(m3P_var)

# Example GLS with heterogeneous variances by crop type
m3P_gls <- gls(
  m3P,
  data = data,
  weights = varIdent(form = ~ 1 | Type.x)
)
summary(m3P)

##Cleanedup Revised Code

library(nlme)
library(dplyr)

# Base model (homogeneous variance)
m3P <- gls(
  mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  na.action = na.exclude,
  method = "REML"
)

# Model with heterogeneous variance by Type.x
m3P_var <- gls(
  mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  na.action = na.exclude,
  method = "REML",
  weights = varIdent(form = ~ 1 | Type.x)
)

# Extract coefficient tables
coef_base <- summary(m3P)$tTable %>%
  as.data.frame() %>%
  tibble::rownames_to_column("term") %>%
  rename_with(~paste0(.x, "_base"), -term)

coef_var <- summary(m3P_var)$tTable %>%
  as.data.frame() %>%
  tibble::rownames_to_column("term") %>%
  rename_with(~paste0(.x, "_var"), -term)

# Combine side-by-side
comparison <- full_join(coef_base, coef_var, by = "term")

# Show results
comparison

coef_base <- summary(m3P)$tTable
coef_var  <- summary(m3P_var)$tTable

sig_diff <- data.frame(
  term = rownames(coef_base),
  sig_base = coef_base[, "p-value"] < 0.05,
  sig_var  = coef_var[, "p-value"] < 0.05
)

# Add a column that tells if significance status changed
sig_diff$changed <- sig_diff$sig_base != sig_diff$sig_var
sig_diff
#####variance structures

library(emmeans)
library(dplyr)

modelP <- gls(mgCpergSoilP ~ Type.x,
               data = data,
               na.action = na.exclude,
               method = "REML",
               weights = varIdent(form = ~ 1 | Type.x))

modelP2 <- gls(mgCpergSoilP ~ Type.x,
              data = data,
              na.action = na.exclude,
              method = "REML")
anova (modelP, modelP2)

class(data)


emm <- emmeans(modelP2, specs = "Type.x", mode = "df.error")
emm


# Table of estimated means with SE
emm_table <- as.data.frame(emm) %>%
  select(Type.x = Type.x, mean_POC = emmean, SE = SE)
emm_table

# Pairwise comparisons (Tukey-adjusted)
pairs(emm, adjust = "tukey")





modelMprop <- gls(propM~ Type.x,
              data = data,
              na.action = na.exclude,
              method = "REML",
              weights = varIdent(form = ~ 1 | Type.x))

modelM2prop<- gls(propM ~ Type.x,
               data = data,
               na.action = na.exclude,
               method = "REML")
anova (modelMprop, modelM2prop)

class(data)


emm <- emmeans(modelP2, specs = "Type.x", mode = "df.error")
emm


# Table of estimated means with SE
emm_table <- as.data.frame(emm) %>%
  select(Type.x = Type.x, mean_POC = emmean, SE = SE)
emm_table

# Pairwise comparisons (Tukey-adjusted)
pairs(emm, adjust = "tukey")


################Spatial stuff
# Install and load required packages
install.packages(c("nlme", "gstat", "sp"))
library(nlme)
library(gstat)
library(sp)

# Your GLS model
m3P <- gls(mgCpergSoilP ~ ppt.cm * tmeanC +
             aggregate_stability + active_carbon + ph,
           data = data, 
           na.action = na.exclude, 
           method = "REML")

# 1 Extract standardized residuals
data$resid_std <- resid(m3P, type = "normalized")

# 2 Create a data frame with residuals and coordinates
resid_df <- data.frame(
  Longitude = data$Longitude,
  Latitude = data$Latitude,
  resid_std = data$resid_std
)

# Remove missing coordinates (if any)
resid_df <- na.omit(resid_df)

# 3 Add a color column: black for negative, grey for positive
resid_df$col <- ifelse(resid_df$resid_std < 0, "black", "grey70")

# 3 Set spatial coordinates
coordinates(resid_df) <- ~ Longitude + Latitude

# 4 Define color scheme: black = negative, grey = positive residuals
#col_vec <- ifelse(resid_df$resid_std < 0, "black", "grey70")

# 5 Bubble plot of standardized residuals
bubble(
  resid_df,
  "resid_std",
  col = col_vec,
  main = "Spatial Distribution of Standardized Residuals",
  xlab = "Longitude",
  ylab = "Latitude"
)
library(ggplot2)

# Create a ggplot-compatible dataframe
resid_df <- data.frame(
  Longitude = data$Longitude,
  Latitude = data$Latitude,
  resid_std = resid(m3P, type = "normalized")
)
resid_df <- na.omit(resid_df)

# ggplot bubble plot
ggplot(resid_df, aes(x = Longitude, y = Latitude)) +
  geom_point(aes(size = abs(resid_std),
                 fill = ifelse(resid_std > 0, "Positive", "Negative")),
             shape = 21, color = "black", alpha = 0.8) +
  scale_fill_manual(values = c("Negative" = "black", "Positive" = "grey70")) +
  scale_size_continuous(name = "|Standardized residual|") +
  labs(title = "Spatial Distribution of Standardized Residuals",
       x = "Longitude", y = "Latitude", fill = "Residual sign") +
  theme_bw()
##########MAOC
m3 = gls(mgCpergSoilM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC + 
           active_carbon + aggregate_stability,
         data = data, 
         na.action = na.exclude, 
         method = "REML")


# 1 Extract standardized residuals
data$resid_std <- resid(m3, type = "normalized")

# 2 Create a data frame with residuals and coordinates
resid_df <- data.frame(
  Longitude = data$Longitude,
  Latitude = data$Latitude,
  resid_std = data$resid_std
)

# Remove missing coordinates (if any)
resid_df <- na.omit(resid_df)

# 3 Add a color column: black for negative, grey for positive
resid_df$col <- ifelse(resid_df$resid_std < 0, "black", "grey70")

# 3 Set spatial coordinates
coordinates(resid_df) <- ~ Longitude + Latitude

# 4 Define color scheme: black = negative, grey = positive residuals
#col_vec <- ifelse(resid_df$resid_std < 0, "black", "grey70")

# 5 Bubble plot of standardized residuals
bubble(
  resid_df,
  "resid_std",
  col = col_vec,
  main = "Spatial Distribution of Standardized Residuals",
  xlab = "Longitude",
  ylab = "Latitude"
)
library(ggplot2)

# Create a ggplot-compatible dataframe
resid_df <- data.frame(
  Longitude = data$Longitude,
  Latitude = data$Latitude,
  resid_std = resid(m3, type = "normalized")
)
resid_df <- na.omit(resid_df)

# ggplot bubble plot
ggplot(resid_df, aes(x = Longitude, y = Latitude)) +
  geom_point(aes(size = abs(resid_std),
                 fill = ifelse(resid_std > 0, "Positive", "Negative")),
             shape = 21, color = "black", alpha = 0.8) +
  scale_fill_manual(values = c("Negative" = "black", "Positive" = "grey70")) +
  scale_size_continuous(name = "|Standardized residual|") +
  labs(title = "Spatial Distribution of Standardized Residuals",
       x = "Longitude", y = "Latitude", fill = "Residual sign") +
  theme_bw()

library(nlme)

# Exponential spatial correlation
m3P_exp <- gls(mgCpergSoilP ~ ppt.cm * tmeanC +
                 aggregate_stability + active_carbon + ph,
               data = data,
               correlation = corExp(form = ~ Longitude + Latitude, nugget = TRUE),
               na.action = na.exclude,
               method = "REML")

# Gaussian spatial correlation
m3P_gaus <- update(m3P_exp, correlation = corGaus(form = ~ Longitude + Latitude, nugget = TRUE))

# Spherical spatial correlation
m3P_spher <- update(m3P_exp, correlation = corSpher(form = ~ Longitude + Latitude, nugget = TRUE))

AIC(m3P, m3P_exp, m3P_gaus, m3P_spher)

data$Longitude_j <- jitter(data$Longitude, factor = 0.000001)
data$Latitude_j  <- jitter(data$Latitude,  factor = 0.000001)

library(spdep)

# Create spatial weights based on nearest neighbors (e.g., 5 neighbors)
coords <- cbind(data$Longitude, data$Latitude)
nb <- knearneigh(coords, k = 5)
nb <- knn2nb(nb)
lw <- nb2listw(nb, style = "W")

# Morans I test
moran_test <- moran.test(data$resid_std, lw)
moran_test

library(nlme)

m3P_spatial <- gls(
  mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  correlation = corExp(form = ~ Longitude + Latitude, nugget = TRUE),
  method = "REML",
  na.action = na.exclude
)

dup_coords <- data[duplicated(data[, c("Longitude", "Latitude")]), c("Longitude", "Latitude")]
dup_coords

data$Longitude_j <- jitter(data$Longitude, factor = 0.0001)
data$Latitude_j  <- jitter(data$Latitude, factor = 0.0001)

m3P_spatial <- gls(
  mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
  method = "REML",
  na.action = na.exclude
)
m3P_nospat <- gls(
  mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  method = "REML",
  na.action = na.exclude
)

AIC(m3P_nospat, m3P_spatial)
anova(m3P_spatial)
summary(m3P_spatial)
correlation = corExp(form = ~ Longitude + Latitude, nugget = TRUE),
method = "REML"

m3P_nospat_ML <- update(m3P_nospat, method = "ML")
m3P_spatial_ML <- update(m3P_spatial, method = "ML")

anova(m3P_nospat_ML, m3P_spatial_ML)

# Standardized residuals
resid_std <- resid(m3P_spatial, type = "normalized")

data$resid_std <- resid(m3P_spatial, type = "normalized")
bubble(data, "resid_std", col = c("black", "grey"), main = "Residuals by Space")


# Compare with non-spatial model
AIC (m3P, m3P_spatial)

#########TEST SHMP
t.test(Frac23$extra, mu = 0)

mean_val <- mean(Frac23$extra, na.rm = TRUE)
sd_val   <- sd(Frac23$extra, na.rm = TRUE)
cohen_d  <- mean_val / sd_val
cohen_d

ggplot(Frac23, aes(x = extra)) +
  geom_histogram(binwidth = 0.05, fill = "grey70", color = "black") +
  geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
  theme_minimal() +
  labs(x = "extra", y = "Count", title = "Distribution of 'extra' values")

# Number of positive and non-positive values
n_pos <- sum(Frac23$extra > 0)
n_total <- length(Frac23$extra)

# Binomial test
binom.test(n_pos, n_total, p = 0.5, alternative = "greater")

library(effsize)
library(ggplot2)

Frac23$sign <- ifelse(Frac23$extra > 0, "Positive", "Zero/Negative")

ggplot(Frac23, aes(x = sign)) +
  geom_bar(fill = c("grey", "black")) +
  labs(y = "Number of samples", x = "Residual sign") +
  theme_minimal()

###############semivarograms with models that include both spatial and non ###########
# Packages
library(nlme)
library(gstat)
library(sp)

# Refit models (if not already loaded)
m3_spatial <- gls(
  mgCpergSoilM ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
  method = "REML",
  na.action = na.exclude
)
m3_nospat <- gls(
  mgCpergSoilM ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  method = "REML",
  na.action = na.exclude
)

# Compare AICs
AIC(m3_nospat, m3_spatial)

# Residuals
data$resid_nospat <- resid(m3_nospat, type = "normalized")
data$resid_spat   <- resid(m3_spatial, type = "normalized")

# Ensure coords numeric
data$Longitude_j <- as.numeric(data$Longitude_j)
data$Latitude_j  <- as.numeric(data$Latitude_j)

# Remove rows with missing residuals or coordinates
data_clean <- na.omit(data[, c("Longitude_j", "Latitude_j", "resid_nospat", "resid_spat")])

# Remove duplicate coordinates (small jitter helps variogram)
data_clean$Longitude_j <- jitter(data_clean$Longitude_j)
data_clean$Latitude_j  <- jitter(data_clean$Latitude_j)

# Make spatial object
sp::coordinates(data_clean) <- ~ Longitude_j + Latitude_j

# Compute variograms
vg_nospat <- variogram(resid_nospat ~ 1, data_clean)
vg_spat   <- variogram(resid_spat ~ 1, data_clean)

# Check
cat("nospat:", nrow(vg_nospat), " | spat:", nrow(vg_spat), "\n")

if (nrow(vg_nospat) == 0 | nrow(vg_spat) == 0) {
  stop(" Variogram failed  likely due to missing or duplicate coordinates.")
}

# Plot safely
dev.new(width = 10, height = 5)
par(mfrow = c(1, 2))
plot(vg_nospat, main = "No spatial correlation", col = "red", pch = 19)
plot(vg_spat, main = "With spatial correlation", col = "blue", pch = 19)
par(mfrow = c(1, 1))

dev.new(width = 6, height = 5)
plot(vg_nospat, main = "Comparison of semivariograms", col = "red", pch = 19)
plot(vg_spat, add = TRUE, col = "blue", pch = 19)
legend("bottomright", legend = c("No spatial", "Spatial (corExp)"),
       col = c("red", "blue"), pch = 19)

summary(data[, c("Longitude_j", "Latitude_j", "resid_nospat", "resid_spat")])

##############POC semivariogram comparison

# Your GLS models
m3P_spatial <- gls(
  mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
  method = "REML",
  na.action = na.exclude
)

m3P_nospat <- gls(
  mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
  data = data,
  method = "REML",
  na.action = na.exclude
)

# Standardized residuals
data$resid_spat   <- resid(m3P_spatial, type = "normalized")
data$resid_nospat <- resid(m3P_nospat,  type = "normalized")

#  DO NOT reset coordinates  your data already has them
# Just confirm they exist:
head(coordinates(data))
# If this returns numeric coordinates, you're good!

# Compute semivariograms
vg_nospat <- variogram(resid_nospat ~ 1, data)
vg_spat   <- variogram(resid_spat ~ 1, data)

# Check they actually have data
nrow(vg_nospat); nrow(vg_spat)

# Plot both side-by-side
par(mfrow = c(1, 2))
plot(vg_nospat, main = "No Spatial Correlation Model", col = "red", pch = 19)
plot(vg_spat, main = "With Spatial Correlation (corExp)", col = "blue", pch = 19)
par(mfrow = c(1, 1))

# Overlay comparison
plot(vg_nospat, main = "Semivariogram Comparison", col = "red", pch = 19)
plot(vg_spat, add = TRUE, col = "blue", pch = 19)
legend("bottomright",
       legend = c("No Spatial", "With corExp Spatial Structure"),
       col = c("red", "blue"), pch = 19)

nrow(vg_nospat); nrow(vg_spat)


# Plot side-by-side comparison
par(mfrow = c(1, 2))

plot(vg_nospat$dist, vg_nospat$gamma,
     main = "No Spatial Correlation Model",
     xlab = "Distance", ylab = "Semivariance",
     pch = 19, col = "red")
lines(lowess(vg_nospat$dist, vg_nospat$gamma), col = "red", lwd = 2)

plot(vg_spat$dist, vg_spat$gamma,
     main = "With Spatial Correlation (corExp)",
     xlab = "Distance", ylab = "Semivariance",
     pch = 19, col = "blue")
lines(lowess(vg_spat$dist, vg_spat$gamma), col = "blue", lwd = 2)

# Reset layout
par(mfrow = c(1, 1))

# Overlay both in one plot for direct comparison
plot(vg_nospat$dist, vg_nospat$gamma,
     main = "Semivariogram Comparison",
     xlab = "Distance", ylab = "Semivariance",
     pch = 19, col = "red", ylim = range(c(vg_nospat$gamma, vg_spat$gamma)))
lines(lowess(vg_nospat$dist, vg_nospat$gamma), col = "red", lwd = 2)
points(vg_spat$dist, vg_spat$gamma, pch = 19, col = "blue")
lines(lowess(vg_spat$dist, vg_spat$gamma), col = "blue", lwd = 2)
legend("bottomright", legend = c("No Spatial", "With corExp"), col = c("red", "blue"), pch = 19)


###########MAOC

# Your GLS models
m3_spatial <- gls(
  mgCpergSoilM ~ ppt.cm *soil_texture_clay * tmeanC + aggregate_stability + active_carbon,
  data = data,
  correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
  method = "ML",
  na.action = na.exclude
)

m3_nospat <- gls(
  mgCpergSoilM ~ ppt.cm *soil_texture_clay * tmeanC + aggregate_stability + active_carbon,
  data = data,
  method = "ML",
  na.action = na.exclude
)
AIC (m3_nospat, m3_spatial)
# Standardized residuals
data$resid_spat   <- resid(m3_spatial, type = "normalized")
data$resid_nospat <- resid(m3_nospat,  type = "normalized")

#  DO NOT reset coordinates  your data already has them
# Just confirm they exist:
head(coordinates(data))
# If this returns numeric coordinates, you're good!

# Compute semivariograms
# Maximum distance = 0.5 (same units as your coordinates, likely degrees)
max_dist <- 0.5

# Compute variograms with cutoff
vg_nospat <- variogram(resid_nospat ~ 1, data, cutoff = max_dist)
vg_spat   <- variogram(resid_spat   ~ 1, data, cutoff = max_dist)


#vg_nospat <- variogram(resid_nospat ~ 1, data)
#vg_spat   <- variogram(resid_spat   ~ 1, data)

# Check they actually have data
nrow(vg_nospat); nrow(vg_spat)

# Plot both side-by-side
par(mfrow = c(1, 2))
plot(vg_nospat, main = "No Spatial Correlation Model", col = "red", pch = 19)
plot(vg_spat, main = "With Spatial Correlation (corExp)", col = "blue", pch = 19)
par(mfrow = c(1, 1))

# Overlay comparison
plot(vg_nospat, main = "Semivariogram Comparison", col = "red", pch = 19)
plot(vg_spat, add = TRUE, col = "blue", pch = 19)
legend("bottomright",
       legend = c("No Spatial", "With corExp Spatial Structure"),
       col = c("red", "blue"), pch = 19)

nrow(vg_nospat); nrow(vg_spat)


# Plot side-by-side comparison
par(mfrow = c(1, 2))

plot(vg_nospat$dist, vg_nospat$gamma,
     main = "No Spatial Correlation Model",
     xlab = "Distance", ylab = "Semivariance",
     pch = 19, col = "red")
lines(lowess(vg_nospat$dist, vg_nospat$gamma), col = "red", lwd = 2)

plot(vg_spat$dist, vg_spat$gamma,
     main = "With Spatial Correlation (corExp)",
     xlab = "Distance", ylab = "Semivariance",
     pch = 19, col = "blue")
lines(lowess(vg_spat$dist, vg_spat$gamma), col = "blue", lwd = 2)

# Reset layout
par(mfrow = c(1, 1))

# Overlay both in one plot for direct comparison
plot(vg_nospat$dist, vg_nospat$gamma,
     main = "Semivariogram Comparison",
     xlab = "Distance", ylab = "Semivariance",
     pch = 19, col = "red", ylim = range(c(vg_nospat$gamma, vg_spat$gamma)))
lines(lowess(vg_nospat$dist, vg_nospat$gamma), col = "red", lwd = 2)
points(vg_spat$dist, vg_spat$gamma, pch = 19, col = "blue")
lines(lowess(vg_spat$dist, vg_spat$gamma), col = "blue", lwd = 2)
legend("bottomright", legend = c("No Spatial", "With corExp"), col = c("red", "blue"), pch = 19)




vg_spat_cloud <- variogram(resid_spat ~ 1, data, cutoff = 0.5, cloud = TRUE)
head(vg_spat_cloud)

plot(vg_spat_cloud$dist, vg_spat_cloud$gamma,
     pch = 19, col = rgb(0,0,1,0.5),
     xlab = "Distance", ylab = "Semivariance",
     main = "Variogram Cloud (All Pairs)")

######Spatial distr of residuals with spatial correlation

# Your GLS model
m3P <- gls(mgCpergSoilP ~ ppt.cm * tmeanC +
             aggregate_stability + active_carbon + ph,
           data = data, 
           correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
           na.action = na.exclude, 
           method = "REML")

# 1 Extract standardized residuals
data$resid_std <- resid(m3P, type = "normalized")

# 2 Create a data frame with residuals and coordinates
resid_df <- data.frame(
  Longitude = data$Longitude_j,
  Latitude = data$Latitude_j,
  resid_std = data$resid_std
)

# Remove missing coordinates (if any)
resid_df <- na.omit(resid_df)

# 3 Add a color column: black for negative, grey for positive
resid_df$col <- ifelse(resid_df$resid_std < 0, "black", "grey70")

# 3 Set spatial coordinates
coordinates(resid_df) <- ~ Longitude + Latitude

# 4 Define color scheme: black = negative, grey = positive residuals
#col_vec <- ifelse(resid_df$resid_std < 0, "black", "grey70")

# 5 Bubble plot of standardized residuals
bubble(
  resid_df,
  "resid_std",
  col = col_vec,
  main = "Spatial Distribution of Standardized Residuals",
  xlab = "Longitude",
  ylab = "Latitude"
)

# Create a ggplot-compatible dataframe
resid_df <- data.frame(
  Longitude = data$Longitude_j,
  Latitude = data$Latitude_j,
  resid_std = resid(m3P, type = "normalized")
)
resid_df <- na.omit(resid_df)

# ggplot bubble plot
ggplot(resid_df, aes(x = Longitude, y = Latitude)) +
  geom_point(aes(size = abs(resid_std),
                 fill = ifelse(resid_std > 0, "Positive", "Negative")),
             shape = 21, color = "black", alpha = 0.8) +
  scale_fill_manual(values = c("Negative" = "black", "Positive" = "grey70")) +
  scale_size_continuous(name = "|Standardized residual|") +
  labs(title = "Spatial Distribution of Standardized Residuals",
       x = "Longitude", y = "Latitude", fill = "Residual sign") +
  theme_bw()
##########MAOC
m3 = gls(mgCpergSoilM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC + 
           active_carbon + aggregate_stability,
         data = data, 
         correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
         na.action = na.exclude, 
         method = "REML")


library(nlme)

## Spatial model (your existing one)
m3 <- gls(mgCpergSoilM ~ ppt.cm * soil_texture_clay * tmeanC +
            ppt.cm * tmeanC +
            active_carbon + aggregate_stability,
          data = data,
          correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
          na.action = na.exclude,
          method = "REML")

## Non-spatial model (same fixed effects, no correlation structure)
m3_nospatial <- gls(mgCpergSoilM ~ ppt.cm * soil_texture_clay * tmeanC +
                      ppt.cm * tmeanC +
                      active_carbon + aggregate_stability,
                    data = data,
                    na.action = na.exclude,
                    method = "REML")

## Compare AIC
AIC(m3, m3_nospatial)

## Optional: likelihood-ratio test (using ML instead of REML)
m3_ML <- update(m3, method = "ML")
m3_nospatial_ML <- update(m3_nospatial, method = "ML")
anova(m3_nospatial_ML, m3_ML)



# 1 Extract standardized residuals
data$resid_std <- resid(m3, type = "normalized")

# 2 Create a data frame with residuals and coordinates
resid_df <- data.frame(
  Longitude = data$Longitude_j,
  Latitude = data$Latitude_j,
  resid_std = data$resid_std
)

# Remove missing coordinates (if any)
resid_df <- na.omit(resid_df)

# 3 Add a color column: black for negative, grey for positive
resid_df$col <- ifelse(resid_df$resid_std < 0, "black", "grey70")

# 3 Set spatial coordinates
coordinates(resid_df) <- ~ Longitude + Latitude

bubble(
  resid_df,
  "resid_std",
  col = col_vec,
  main = "Spatial Distribution of Standardized Residuals",
  xlab = "Longitude",
  ylab = "Latitude"
)

# Create a ggplot-compatible dataframe
resid_df <- data.frame(
  Longitude = data$Longitude_j,
  Latitude = data$Latitude_j,
  resid_std = resid(m3P, type = "normalized")
)
resid_df <- na.omit(resid_df)

# ggplot bubble plot
ggplot(resid_df, aes(x = Longitude, y = Latitude)) +
  geom_point(aes(size = abs(resid_std),
                 fill = ifelse(resid_std > 0, "Positive", "Negative")),
             shape = 21, color = "black", alpha = 0.8) +
  scale_fill_manual(values = c("Negative" = "black", "Positive" = "grey70")) +
  scale_size_continuous(name = "|Standardized residual|") +
  labs(title = "Spatial Distribution of Standardized Residuals",
       x = "Longitude", y = "Latitude", fill = "Residual sign") +
  theme_bw()

citation ("gstat")

library(nlme)

## --- Semivariogram for the spatial model (m3P) ---
var_m3P <- Variogram(m3P,
                     form = ~ Longitude_j + Latitude_j,
                     resType = "normalized")

## --- Fit the non-spatial version of the model ---
m3P_nospatial <- gls(mgCpergSoilP ~ ppt.cm * tmeanC +
                       aggregate_stability + active_carbon + ph,
                     data = data,
                     na.action = na.exclude,
                     method = "REML")

## --- Semivariogram for the non-spatial model ---
var_m3P_nospatial <- Variogram(m3P_nospatial,
                               form = ~ Longitude_j + Latitude_j,
                               resType = "normalized")

####compare semivariograms

plot(var_m3P, main = "Semivariogram  Spatial Model (m3P)")
library(nlme)
library(gstat)
library(sp)

#----------------------------------------------------------
# 1. Residuals from m3P (non-spatial model)
#----------------------------------------------------------
data$resid_m3P <- residuals(m3P)

# Drop rows with missing residuals
data_m3P <- data[!is.na(data$resid_m3P), ]

# Empirical semivariogram
vgm_m3P <- variogram(resid_m3P ~ 1, data_m3P)
plot(vgm_m3P, main = "Residual Semivariogram  m3P (non-spatial)")

# Optional fitted model
fit_m3P <- fit.variogram(vgm_m3P, vgm("Sph"))
plot(vgm_m3P, model = fit_m3P,
     main = "Fitted Residual Semivariogram  m3P")

#----------------------------------------------------------
# 2. Residuals from m3P_spatial (spatial GLS model)
#----------------------------------------------------------
data$resid_m3P_spatial <- residuals(m3P_spatial, type = "normalized")

# Drop rows with missing residuals
data_m3P_spatial <- data[!is.na(data$resid_m3P_spatial), ]

# Empirical semivariogram
vgm_m3P_spatial <- variogram(resid_m3P_spatial ~ 1, data_m3P_spatial)
plot(vgm_m3P_spatial, main = "Residual Semivariogram  m3P_spatial")

# Optional fitted model
fit_m3P_spatial <- fit.variogram(vgm_m3P_spatial, vgm("Sph"))
plot(vgm_m3P_spatial, model = fit_m3P_spatial,
     main = "Fitted Residual Semivariogram  m3P_spatial")


############Same but for MAOC

#----------------------------------------------------------
# 1. Residuals from m3 (non-spatial model)
#----------------------------------------------------------
data$resid_m3 <- residuals(m3)

# Drop rows with missing residuals
data_m3 <- data[!is.na(data$resid_m3), ]

# Empirical semivariogram
vgm_m3 <- variogram(resid_m3 ~ 1, data_m3)
plot(vgm_m3, main = "Residual Semivariogram  m3 (non-spatial)")

# Optional fitted model
fit_m3 <- fit.variogram(vgm_m3, vgm("Sph"))
plot(vgm_m3, model = fit_m3,
     main = "Fitted Residual Semivariogram  m3")

#----------------------------------------------------------
# 2. Residuals from m3_spatial (spatial GLS model)
#----------------------------------------------------------
data$resid_m3_spatial <- residuals(m3_spatial, type = "normalized")

# Drop rows with missing residuals
data_m3_spatial <- data[!is.na(data$resid_m3_spatial), ]

# Empirical semivariogram
vgm_m3_spatial <- variogram(resid_m3_spatial ~ 1, data_m3_spatial)
plot(vgm_m3_spatial, main = "Residual Semivariogram  m3_spatial")

# Optional fitted model
fit_m3_spatial <- fit.variogram(vgm_m3_spatial, vgm("Sph"))
plot(vgm_m3_spatial, model = fit_m3_spatial,
     main = "Fitted Residual Semivariogram  m3_spatial")



####testing

# Response variables
responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

# Filter data once
data_filtered <- data %>%
  filter(Type.x != "Field crops") %>%
  mutate(Type.x = factor(Type.x))

results_list <- list()
results_list_f <- list()   # <---- new

for (var in responses) {
  
  # GLS model
  model <- gls(as.formula(paste(var, "~ Type.x")),
               data = data_filtered,
               method = "REML",
               weights = varIdent(form = ~1 | Type.x),
               na.action = na.exclude)
  
  # Extract F and p
  an_out <- anova(model)
  results_list_f[[var]] <- data.frame(
    response = var,
    F_value = an_out$`F-value`[2],
    p_value = an_out$`p-value`[2]
  )
  
  # Estimated marginal means
  emm <- emmeans(model, specs = "Type.x", mode = "df.error")
  
  # Tukey contrasts
  tukey <- glht(model, linfct = mcp(Type.x = "Tukey"))
  tukey_sum <- summary(tukey)
  
  # P-values for letters
  pvals_named <- tukey_sum$test$pvalues
  names(pvals_named) <- rownames(tukey_sum$linfct)
  
  letters_vec <- multcompLetters(pvals_named)$Letters
  letters_df <- data.frame(Type.x = names(letters_vec), .group = letters_vec)
  
  summary_stats <- as.data.frame(emm)[, c("Type.x", "emmean", "SE")]
  colnames(summary_stats) <- c("Type.x", "mean", "SE")
  
  summary_stats <- summary_stats %>%
    mutate(
      range = paste0(
        round(tapply(data_filtered[[var]], data_filtered$Type.x, min, na.rm = TRUE), 2), "",
        round(tapply(data_filtered[[var]], data_filtered$Type.x, max, na.rm = TRUE), 2)
      )
    ) %>%
    left_join(letters_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- summary_stats
}

# Combine and clean summary table
final_results <- bind_rows(results_list)
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    SE_rounded   = round(SE, 2),
    mean_SE_sig  = paste0(mean_rounded, "  ", SE_rounded, " (", .group, ")"),
    mean_range   = paste0(mean_SE_sig, " | Range: ", range)
  )

final_wide <- final_results_clean %>%
  dplyr::select(Crop = Type.x, Variable = response, mean_range) %>%
  pivot_wider(names_from = Variable, values_from = mean_range)

# Combine Fp table
F_results <- bind_rows(results_list_f) %>%
  mutate(
    F_value = round(F_value, 3),
    p_value = signif(p_value, 3)
  )

# Write to Excel
wb <- createWorkbook()
addWorksheet(wb, "Summary")
writeData(wb, "Summary", final_wide)

addWorksheet(wb, "Model_F_P")
writeData(wb, "Model_F_P", F_results)

saveWorkbook(wb, "CropType_TablevA.xlsx", overwrite = TRUE)

#####CReate a table with F and P 

# Filter data and convert Type.x to factor
data_filtered <- data %>%
   filter(Type.x != "Field crops") %>%
   mutate(Type.x = factor(Type.x))
 
  responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
                                  "active_carbon", "ph", "overall.score", "soil_texture_clay")
 
 sig_list <- list()
 
 for(var in responses){
   
   # Pre-filter NAs
   data_var <- data_filtered %>% filter(!is.na(.data[[var]]))
   
   if(length(unique(data_var$Type.x)) < 2) next
   
   # Fit GLS with variance structure
   model <- gls(as.formula(paste(var, "~ Type.x")),
                                         data = data_var,
                                        method = "REML",
                                         weights = varIdent(form = ~1 | Type.x),
                                         na.action = na.exclude)
        
             # Estimated marginal means
             emm <- emmeans(model, specs = "Type.x", mode = "df.error")
             
             # Tukey pairwise comparisons
             pw <- pairs(emm, adjust = "tukey") %>% summary()
             
             # Keep only significant comparisons (p < 0.05)
             sig_pw <- pw %>% as.data.frame() %>% filter(p.value < 0.05)
             
             if(nrow(sig_pw) > 0){
               sig_pw$response <- var
               sig_list[[var]] <- sig_pw
             }
           }
 # Combine all significant pairwise differences
 sig_differences <- bind_rows(sig_list)
 
 # View results
 sig_differences

 #####show all, even without significance
 # Filter data and convert Type.x to factor
 data_filtered <- data %>%
   filter(Type.x != "Field crops") %>%
   mutate(Type.x = factor(Type.x))
 
 responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
                "active_carbon", "ph", "overall.score", "soil_texture_clay")
 
 all_pw_list <- list()
 
 for (var in responses) {
   
   # Remove NAs for this variable
   data_var <- data_filtered %>% filter(!is.na(.data[[var]]))
   
   # If only one level left, skip
   if (length(unique(data_var$Type.x)) < 2) next
   
   # Fit GLS
   model <- gls(
     as.formula(paste(var, "~ Type.x")),
     data = data_var,
     method = "REML",
     weights = varIdent(form = ~1 | Type.x),
     na.action = na.exclude
   )
   
   anova (model)
   
   # Estimated marginal means
   emm <- emmeans(model, specs = "Type.x", mode = "df.error")
   
   # Tukey comparisons for *all* pairs
   pw <- pairs(emm, adjust = "tukey") %>% summary()
   
   # Convert to dataframe and add response label
   pw_df <- pw %>% as.data.frame() %>% mutate(response = var)
   
   all_pw_list[[var]] <- pw_df
 }
 
 # Combine all into one dataframe
 all_pairwise <- bind_rows(all_pw_list)
 
 # View
 all_pairwise
 
 library(dplyr)
 library(emmeans)
 library(nlme)
 library(multcomp)
 library(openxlsx)
 
 # ------------------------
 # Filter data
 # ------------------------
 data_filtered <- data %>%
   filter(Type.x != "Field crops") %>%
   mutate(Type.x = factor(Type.x))
 
 responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
                "active_carbon", "ph", "overall.score", "soil_texture_clay")
 
 all_pw_list <- list()
 
 # ------------------------
 # Loop through all variables
 # ------------------------
 for (var in responses) {
   
   # Remove NAs only for the current variable
   data_var <- data_filtered %>%
     filter(!is.na(.data[[var]]))
   
   # Skip if only one crop type remains
   if (length(unique(data_var$Type.x)) < 2) next
   
   # GLS model
   model <- gls(
     as.formula(paste(var, "~ Type.x")),
     data = data_var,
     method = "REML",
     weights = varIdent(form = ~1 | Type.x),
     na.action = na.exclude
   )
   
   # Estimated marginal means
   emm <- emmeans(model, specs = "Type.x", mode = "df.error")
   
   # Tukey comparisons (all)
   pw <- pairs(emm, adjust = "tukey") %>% summary()
   
   pw_df <- pw %>% as.data.frame()
   
   # ------------------------
   # Format statistics: t(df) = value, p = value
   # ------------------------
   pw_df$stat_formatted <- paste0(
     "t(df = ", round(pw_df$df, 2), 
     ") = ", round(pw_df$t.ratio, 2),
     ", p = ", signif(pw_df$p.value, 3)
   )
   
   pw_df$response <- var
   
   all_pw_list[[var]] <- pw_df
 }
 
 # Combine results
 all_pairwise <- bind_rows(all_pw_list)
 
 # ------------------------
 # Reorder columns neatly
 # ------------------------
 all_pairwise_clean <- all_pairwise %>%
   select(response, contrast, estimate, SE, df, t.ratio, p.value, stat_formatted)
 
 # ------------------------
 # Write to Excel
 # ------------------------
 wb <- createWorkbook()
 addWorksheet(wb, "Tukey_All")
 
 writeData(wb, "Tukey_All", all_pairwise_clean)
 
 saveWorkbook(wb, "Tukey_All_Comparisonsv2.xlsx", overwrite = TRUE)
 
 # GLS model
 modelSH <- gls(
   overall.score ~ Type.x,
   data = data_var,
   method = "REML",
   weights = varIdent(form = ~1 | Type.x),
   na.action = na.exclude
 )
 
 anova(modelSH)
 
 
 ##SidebySide spatial and non ts compare
 m3P_spatial <- gls(
   mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
   data = data,
   correlation = corExp(form = ~ Longitude_j + Latitude_j, nugget = TRUE),
   method = "ML",
   na.action = na.exclude
 )
 m3P_nospat <- gls(
   mgCpergSoilP ~ ppt.cm * tmeanC + aggregate_stability + active_carbon + ph,
   data = data,
   method = "ML",
   na.action = na.exclude
 )
 library(MuMIn)
 r.squaredGLMM(m3P_nospat, m3P_spatial)
 
 AIC(m3P_nospat, m3P_spatial)
 anova(m3P_spatial)
 summary (m3P_nospat)
 summary(m3P_spatial)
 install.packages("performance")
 library(performance)
 
 r2(m3P_spatial)
 r2(m3P_nospat)
 
 correlation = corExp(form = ~ Longitude + Latitude, nugget = TRUE),
 method = "REML"
 
 

 
 m3P_nospat_ML <- update(m3P_nospat, method = "ML")
 m3P_spatial_ML <- update(m3P_spatial, method = "ML")
 
 anova(m3P_nospat_ML, m3P_spatial_ML)
 
  ##data AP 
 data$AP
 library(dplyr)
 
 summary_df <- data %>%
   group_by(AP) %>%
   summarise(
     n = n(),
     mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
     se_mgCpergSoilP   = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(sum(!is.na(mgCpergSoilP))),
     
     mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
     se_mgCpergSoilM   = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(sum(!is.na(mgCpergSoilM)))
   )
 summary_df
 
 