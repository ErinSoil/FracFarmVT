#Analyzing data and building linear models with mgPOM as response variable

#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
setwd("C:/Users/F004SPC/OneDrive-Dartmouth College/Desktop/GitHub/FracFarmVT") #erin
##call in the analytical data
data <- read.csv("data_pH.csv")

install.packages("gmodels")

View(data)
#load your libraries
library(tidyverse)
library(ggplot2)
library(dplyr)
library(corrplot)
library(emmeans)
library(nlme)
library(ggeffects)
library (gmodels)
library(reshape2)
library(car) # for Levene's Test
library(ggpubr) # for easy plotting
library(multcomp) # for Tukey's HSD test
library(cowplot)
library(gridExtra)
library(grid)   # needed for textGrob and gpar

##call in the analytical data
data <- read.csv("data_pH.csv")
View(data)

summary(data$OM30)
summary(data$soil_texture_clay)
summary(data$tmeanC)
summary(data$ppt.cm)
summary(data)
view(data)
summary(data$Owned)
summary(data$Acres)
summary(data$ph)
hist(data$ph)
sum(data$ph > 7)
view(data)


data <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "perennial",
    Type.x %in% c("Veg", "Corn", "Field Crop") ~ "annual",
    TRUE ~ NA_character_  # Set to NA if none of the conditions match
  ))


# Replace 'Type.x' column values with 'Pasture' where 'Field_Code' is 'D7'
data$Type.x[data$Field_Code == "D7"] <- "Pasture"

# Assuming 'data' is your dataframe
subset_Type <- data$Type[data$Type.x == "Veg"]

# Print the subset of Field_Code values where Type.x is "Field Crop"
print(subset_Type)

# Count the number of fields with pH greater than 7
data$ph <- as.numeric(data$ph)

count <- sum(data$ph > 7.00, na.rm = TRUE)

# Print the result
print(count)

anova_result2 <- aov(ph ~ Type.x, data=data)

# test for differences in OM for field types

# Perform ANOVA
anova_result <- aov(OM30 ~ Type.x, data = data)

# Summary of ANOVA
summary(anova_result2)

# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result2, ~ Type.x)

# Print pairwise comparisons
print(posthoc, type = "compact")

# Use table() function to count occurrences of each field type
type_counts <- table(data$Type.x)

# Print the counts
print(type_counts)

# Use table() function to count occurrences of each field type
type_counts <- table(data$soil_texture_class)

# Print the counts
print(type_counts)

# Example ANOVA
anova_model <- aov(soil_texture_clay ~ Type.x, data = data)

# Summary of ANOVA
summary(anova_model)

# Example linear regression
lm_model <- lm(soil_texture_clay ~ Type.x, data = data)

# Summary of linear regression
summary(lm_model)

# Example Tukey's HSD test for post-hoc analysis
tukey_test <- TukeyHSD(anova_model)

# View Tukey's HSD test results
print(tukey_test)

# test for differences in soil texture class for field types
#all CIs overlap indicatin no sigficant difference
# Perform ANOVA
anova_result <- aov(soil_texture_clay ~ Type.x, data = data)
# Summary of ANOVA
summary(anova_result)
# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result, ~ Type.x)
# Print pairwise comparisons
print(posthoc, type = "compact")


# Example scatter plot with jitter
ggplot(data, aes(x = Type.x, y = soil_texture_clay)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  labs(x = "Field Type", y = "Soil Texture Clay") +
  ggtitle("Relationship between Soil Texture Clay and Field Type") +
  theme_minimal()

ggplot(data, aes(x = Type.x, y = soil_texture_clay)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +  # Boxplot without showing outliers
  geom_jitter(width = 0.2, height = 0, alpha = 0.5, color = "gray40") +  # Optional: still show individual points lightly
  labs(x = "Field Type", y = "Soil Texture Clay (%)") +
  ggtitle("Relationship between Soil Texture Clay and Field Type") +
  theme_minimal()

# Filter out "Field crops" first
data_filtered <- data %>% 
  filter(Type.x != "Field crops")

View(data_filtered)

# Now plot#######4.46.25  new SI Figure
ggplot(data_filtered, aes(x = Type.x, y = soil_texture_clay)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +  # Boxplot without showing outliers
  geom_jitter(width = 0.2, height = 0, alpha = 0.5, color = "gray40") +  # Optional: still show individual points lightly
  labs(x = "Crop Type", y = "Soil Texture Clay (%)") +  # Changed x-axis label
  ggtitle("") +  # Updated title
  theme_minimal()

data_filtered$Type.x <- dplyr::recode(data_filtered$Type.x, "Veg" = "Vegetable")
write.csv(data_filtered, "data_filtered.csv", row.names = FALSE)


###########SI Figure 9 #########################
#####################################################
data_filtered <- read.csv("data_filtered.csv")

# Define custom colors for each crop type
custom_colors <- c("Pasture" = "#8DA0CB",    # Purple
                   "Vegetable" = "#E78AC3",  # Pink
                   "Corn" = "#66C2A5",       # Green
                   "Hay" = "#FC8D62")        # Blue

# Create the plot
ggplot(data_filtered, aes(x = Type.x, y = soil_texture_clay, fill = Type.x)) +
  geom_boxplot(alpha = 0.7, outlier.shape = NA) +
  geom_jitter(width = 0.2, height = 0, alpha = 0.5, color = "gray40") +
  scale_fill_manual(values = custom_colors) +
  labs(x = "Crop Type", y = "Soil Texture Clay (%)") +
  ggtitle("") +
  theme_minimal() +
  theme(
    legend.position = "none",
    axis.line.x = element_line(color = "black", size = 0.5),
    axis.line.y = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black"),
    axis.text = element_text(color = "black")
  )




# Check normality (optional: check by group)
by(data_filtered$soil_texture_clay, data_filtered$Type.x, shapiro.test)

# Check homogeneity of variance
library(car)
leveneTest(soil_texture_clay ~ Type.x, data = data_filtered)

kruskal.test(soil_texture_clay ~ Type.x, data = data_filtered)
install.packages("FSA")
library(FSA)
dunnTest(soil_texture_clay ~ Type.x, data = data_filtered, method = "bonferroni")

# Example contingency table
cont_table <- table(data$Type.x, data$soil_texture_class)

# View the contingency table
cont_table
# Load necessary library
library(vcd)  # For mosaic plot

# Example mosaic plot
mosaicplot(cont_table, main = "Mosaic Plot of Field Type vs. Soil Texture Class")

# Summarize the data by soil_texture_class and Type.x
summary_data <- data %>%
  group_by(soil_texture_class, Type.x) %>%
  summarise(count = n()) %>%
  mutate(percent = count / sum(count) * 100)  # Calculate percentage within each soil_texture_class

# Plot stacked bar plot
library(ggplot2)
ggplot(summary_data, aes(x = soil_texture_class, y = percent, fill = Type.x)) +
  geom_bar(stat = "identity", position = "stack") +
  labs(x = "Soil Texture Class", y = "Percentage", fill = "Field Type") +
  ggtitle("Distribution of Field Type across Soil Texture Classes") +
  theme_minimal()

# Plot grouped bar plot
ggplot(summary_data, aes(x = soil_texture_class, y = percent, fill = Type.x)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Soil Texture Class", y = "Percentage", fill = "Field Type") +
  ggtitle("Distribution of Field Type across Soil Texture Classes") +
  theme_minimal()

# Example of performing chi-square test
cont_table <- table(data$soil_texture_class, data$Type.x)
chi_square_test <- chisq.test(cont_table)

# View the contingency table
print(cont_table)

# View the chi-square test results
print(chi_square_test)

# Perform chi-square test
cont_table <- table(data$soil_texture_class, data$Type.x)
chi_square_test <- chisq.test(cont_table)

# Residual analysis
residuals <- residuals(chi_square_test)

# View residuals
print(residuals)

# Compute adjusted residuals
adjusted_res <- chisq.test(cont_table)$residuals

# View adjusted residuals
print(adjusted_res)

# Example of mosaic plot
library(vcd)
mosaicplot(cont_table, main = "Mosaic Plot of Field Type vs. Soil Texture Class")

# Use table() function to count occurrences of each field type
type_counts <- table(data$Type.x)

# Print the counts
print(type_counts)


# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)

# Print the contingency table
print(contingency_table)

# Perform chi-square test of independence
chi2_test <- chisq.test(contingency_table)

# Print the chi-square test results
print(chi2_test)

# chi test shows that this is a significant association between field typee and soil texture class

# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)

# Convert contingency table to data frame for plotting
contingency_df <- as.data.frame.matrix(contingency_table)

# Reshape data for plotting (optional, depending on how you want to visualize)

contingency_melted <- melt(contingency_df)

# Plot clustered bar plot
ggplot(contingency_melted, aes(x = soil_texture_class, y = value, fill = Type.x)) +
  geom_bar(stat = "identity", position = "dodge") +
  labs(x = "Soil Texture Class", y = "Count") +
  ggtitle("Distribution of Field Types by Soil Texture") +
  theme_minimal()

# Plot heatmap of contingency table
heatmap.2(as.matrix(contingency_table),
          trace = "none",
          col = heat.colors(length(unique(data$Type.x))),
          dendrogram = "row",
          main = "Association between Field Type and Soil Texture",
          xlab = "Soil Texture Class",
          ylab = "Field Type")

  # Load ggplot2 package if not already loaded
  library(ggplot2)


#soil health regression
# Perform linear regression POC
regression_model_POC <- lm(mgCpergSoilP ~ overall.score, data = data)
summary(regression_model_POC)

view(data)
  # Create a plot with the regression line
POC_health <- ggplot(data, aes(x = overall.score, y = mgCpergSoilP, color=AP)) +
    geom_point(alpha = 0.5) +
    stat_smooth(method = "lm", se = FALSE, color= "AP") +
    labs(x = "Soil Health Index",
         y = expression("mg POC g"^-1~"soil")) +
    theme_minimal()
POC_health

# Remove NA values from the AP column
data_clean <- data %>%
  filter(!is.na(AP))

# Replace 'pere' with 'perennial' in the AP column
data$AP[data$AP == "pere"] <- "perennial"
view(data_clean)
#Figure7
# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE) +
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Replace color1 and color2 with your desired colors
                     labels = c("perennial" = "pere")) +  # Change 'pere' to 'perennial'
  theme_minimal()

POC_health
# Replace 'pere' with 'perennial' in the AP column
data_clean$AP[data_clean$AP == "pere"] <- "perennial"
view(data_clean)

# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                               name = NULL) +  # Remove legend title
  theme_minimal()

# Display the plot
POC_health

# Create a plot with the regression line
MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal()

# Display the plot
MAOC_health

# Create a plot with the regression line
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal()

# Display the plot
PropMAOC_health



# Figure 7 to Line 400#######this one is side by side
# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = TRUE, color = "black", fill = "gray", alpha = 0.2) +  # Add shaded confidence interval
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Custom colors for AP categories
                     name = NULL) +  # Remove legend title
  theme_minimal() +  # Minimal theme to remove gray background
  theme(axis.title.x = element_text(size = 12),  # Increase x-axis label size
        axis.title.y = element_text(size = 12),  # Increase y-axis label size
        legend.text = element_text(size = 12))   # Increase legend text size

# Display the plot
POC_health

MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = TRUE, color = "black", fill = "gray", alpha = 0.2) +  # Add shaded confidence interval
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Custom colors for AP categories
                     name = NULL) +  # Remove legend title
  theme_minimal() +  # Minimal theme to remove gray background
  theme(axis.title.x = element_text(size = 14),  # Increase x-axis label size
        axis.title.y = element_text(size = 14),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
MAOC_health

# Create a plot with the regression line for Proportion of Carbon as MAOC
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = TRUE, color = "black", fill = "gray", alpha = 0.2) +  # Add shaded confidence interval
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 14),  # Increase x-axis label size
        axis.title.y = element_text(size = 14),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
PropMAOC_health



# This is the Final Final Actual Figure 4
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

# Create the plots without legends (remove individual legends)
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.text.x = element_blank(), axis.ticks.x = element_blank())

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(
  POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = 1.08    # Adjust y position for labels
)

# Extract the legend from one of the plots (e.g., POC_health)
legend <- get_legend(
  POC_health + 
    guides(color = guide_legend(title = "Crop"))  # Add the legend title "Crop"
)

# Position the legend at the top-right of the figure
Figure_7dhealth_with_legend <- plot_grid(
  Figure_7dhealth,  # The grid with 3 plots
  legend,           # The shared legend
  ncol = 2,         # 2 columns: 1 for the plots and 1 for the legend
  rel_widths = c(1, 0.2)  # Adjust the relative widths to give more space for the plots
)

# Move the legend to the top right
Figure_7dhealth_final <- Figure_7dhealth_with_legend + 
  theme(legend.position = c(0.9, 0.95),  # Move the legend to the top right
        legend.justification = c("right", "top"),  # Align the legend to the top right
        legend.title = element_text(size = 12),  # Adjust legend title size
        legend.text = element_text(size = 10),   # Adjust legend text size
        legend.title.align = 1)  # Align the legend title with the text (right-aligned)

# Add a common x-axis label at the bottom (for all plots)
Figure_7dhealth_final <- Figure_7dhealth_final + 
  theme(axis.title.x = element_text(size = 14), 
        axis.text.x = element_text(size = 12), 
        axis.ticks.x = element_line(color = "black")) + 
  annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)

# Display the final figure
Figure_7dhealth_final


###########cleaned up figure 4 for final

# --- Step 1: Create two formatting functions ---

# For top two plots (no x-axis labels or ticks)
remove_legend_and_format <- function(plot) {
  plot +
    theme(
      legend.position = "none",
      axis.title.x = element_blank(),
      axis.text.x = element_blank(),
      axis.ticks.x = element_blank(),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks = element_line(color = "black", size = 0.5)
    )
}

# For bottom plot (keep x-axis labels and ticks)
keep_x_axis_format <- function(plot) {
  plot +
    theme(
      legend.position = "none",
      axis.title.x = element_text(size = 12),
      axis.text.x = element_text(size = 10),
      axis.ticks.x = element_line(color = "black", size = 0.5),
      axis.line = element_line(color = "black", size = 0.5),
      axis.ticks = element_line(color = "black", size = 0.5)
    )
}

# --- Step 2: Apply formatting to your three plots ---

POC_health_no_legend <- remove_legend_and_format(POC_health)
MAOC_health_no_legend <- remove_legend_and_format(MAOC_health)
PropMAOC_health_no_legend <- keep_x_axis_format(PropMAOC_health)  # Bottom plot keeps x-axis

# --- Step 3: Combine the 3 plots vertically ---

Figure_7dhealth <- plot_grid(
  POC_health_no_legend,
  MAOC_health_no_legend,
  PropMAOC_health_no_legend,
  ncol = 1, nrow = 3,
  align = 'v',
  labels = c("a", "b", "c"),
  label_x = 0.05,
  label_y = 1.08
)

# --- Step 4: Extract a shared legend from original plot ---

shared_legend <- get_legend(
  POC_health +
    theme(
      legend.position = "top",
      legend.title = element_blank(),
      legend.text = element_text(size = 10)
    )
)

# --- Step 5: Stack the legend and combined plots ---

Figure_7dhealth_with_legend <- plot_grid(
  shared_legend,
  Figure_7dhealth,
  ncol = 1,
  rel_heights = c(0.08, 1)
)

# --- Step 6: Add a shared x-axis label below everything ---

final_plot <- plot_grid(
  Figure_7dhealth_with_legend,
  grid::textGrob("Soil Health Index", gp = gpar(fontsize = 14)),
  ncol = 1,
  rel_heights = c(1, 0.05)
)

# --- Step 7: Display the final plot ---

print(final_plot)


# --- Step 7: Save the final figure (optional) ---

ggsave("Fig.4health.jpeg", plot = final_plot, width = 15, height = 22, units = "cm", dpi = 600)


###########################################################Figure 4 Final
# Create the plots without legends (remove individual legends) but keep axis numbers
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Bring back the x-axis numbers
        axis.text.y = element_text(size = 12))  # Bring back the y-axis numbers

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Bring back the x-axis numbers
        axis.text.y = element_text(size = 12))  # Bring back the y-axis numbers

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Bring back the x-axis numbers
        axis.text.y = element_text(size = 12))  # Bring back the y-axis numbers

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(
  POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = 1.08    # Adjust y position for labels
)

# Extract the legend from one of the plots (e.g., POC_health)
legend <- get_legend(
  POC_health + 
    guides(color = guide_legend(title = "Crop"))  # Add the legend title "Crop"
)

# Position the legend at the top-right of the figure
Figure_7dhealth_with_legend <- plot_grid(
  Figure_7dhealth,  # The grid with 3 plots
  legend,           # The shared legend
  ncol = 2,         # 2 columns: 1 for the plots and 1 for the legend
  rel_widths = c(1, 0.2)  # Adjust the relative widths to give more space for the plots
)

# Move the legend to the top right
Figure_7dhealth_edit <- Figure_7dhealth_with_legend + 
  theme(legend.position = c(0.9, 0.95),  # Move the legend to the top right
        legend.justification = c("right", "top"),  # Align the legend to the top right
        legend.title = element_text(size = 12),  # Adjust legend title size
        legend.text = element_text(size = 10),   # Adjust legend text size
        legend.title.align = 1)  # Align the legend title with the text (right-aligned)

# Add a common x-axis label at the bottom (for all plots)
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(axis.title.x = element_text(size = 14), 
        axis.text.x = element_text(size = 12), 
        axis.ticks.x = element_line(color = "black")) + 
  annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(
    plot.margin = margin(t = 20, r = 20, b = 20, l = 20)  # Increase margins
  )

# Display the final figure
Figure_7dhealth_edit
ggsave("Figure_7dhealth_edit.jpeg", plot = Figure_7dhealth_edit, width = 20, height = 22, units = "cm", dpi = 300)

########################################################### Figure4abc Corrected
# Create the plots without legends but keep axis numbers for y-axis
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

MAOC_health_no_legend <- MAOC_health + 
  theme(legend.position = "none",  # Remove the legend for MAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_text(size = 12),  # Keep x-axis numbers on the bottom plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(
  POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = c(1.08, 0.95, 1.1)    # Adjust y positions for labels (move 'b' down and 'c' up)
)

# Now, let's create a common x-axis label below the shared x-axis for all plots
Figure_7dhealth_edit <- Figure_7dhealth + 
  theme(
    axis.title.x = element_text(size = 14, vjust = -40),  # Move the x-axis title further down below the labels
    axis.text.x = element_text(size = 12),  # Keep the x-axis numbers
    axis.ticks.x = element_line(color = "black"),  # Keep the x-axis ticks
    plot.margin = margin(t = 20, r = 20, b = 60, l = 20)  # Increase bottom margin for the x-axis title
  ) + 
   annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)  # Add the x-axis title below the plots

# To ensure that the x-axis labels only appear once (on the bottom plot), 
# we need to remove the x-axis labels from the first two rows manually
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(
    axis.text.x = element_blank()  # Remove x-axis labels from the first two rows
  ) 

# Display the final figure
Figure_7dhealth_edit

# Save the figure as 'figure4abc.jpeg'
ggsave("figure4abcv.jpeg", plot = Figure_7dhealth_edit, width = 20, height = 22, units = "cm", dpi = 600)

###################################################################
# Ensure no x-axis labels on individual plots (POC_health_no_legend, MAOC_health_no_legend, PropMAOC_health_no_legend)
POC_health_no_legend <- POC_health + 
  theme(legend.position = "none",  # Remove the legend for POC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

MAOC_health_no_legend <- MAOC_health + 
  theme(axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

PropMAOC_health_no_legend <- PropMAOC_health + 
  theme(legend.position = "none",  # Remove the legend for PropMAOC_health
        axis.title.x = element_blank(), axis.ticks.x = element_blank(),
        axis.text.x = element_blank(),  # Remove x-axis numbers from this plot
        axis.text.y = element_text(size = 12))  # Keep y-axis numbers

# Arrange the plots in 1 column, 3 rows, with shared x-axis
Figure_7dhealth <- plot_grid(POC_health_no_legend,  # No legend for this plot
  MAOC_health_no_legend,  # No legend for this plot
  PropMAOC_health_no_legend,  # No legend for this plot
  ncol = 1,  # 1 column of plots
  nrow = 3,  # 3 rows
  align = 'v',  # Align vertically
  labels = c("a", "b", "c"),  # Label the plots as "a", "b", and "c"
  label_x = 0.05,   # Adjust x position for labels
  label_y = 1.08    # Adjust y position for labels
)

# Adjust the x-axis title to be positioned below the x-axis numbers
Figure_7dhealth_edit <- Figure_7dhealth + 
  theme(axis.title.x = element_text(size = 14, margin = margin(t = 40)),  # Increase top margin for the x-axis title
        axis.text.x = element_text(size = 12), 
        axis.ticks.x = element_line(color = "black")) +
  annotation_custom(grob = grid::textGrob("Soil Health Index", gp = grid::gpar(fontsize = 14)), 
                    ymin = -Inf, ymax = -Inf, xmin = -Inf, xmax = Inf)  # Place the x-axis label below

# Adjust the margins of the plot to provide space for the x-axis title
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  theme(
    plot.margin = margin(t = 30, r = 20, b = 60, l = 20)  # Increase bottom margin to give space for the title
  )

# Remove the first x-axis label (e.g., 0.00) using scale_x_continuous()
Figure_7dhealth_edit <- Figure_7dhealth_edit + 
  scale_x_continuous(breaks = scales::pretty_breaks(n = 5), labels = function(x) ifelse(x == 0, NA, x))  # Remove 0.00
scale_color_manual(values = c("#cd853f", "darkgreen"),  # Custom colors for AP categories
                   name = NULL) +  # Remove legend title
# Rename the entire figure
figure4abc <- Figure_7dhealth_edit

# Display the final figure
figure4abc

# Save the figure as 'figure4abc.jpeg'
ggsave("figure4abc.jpeg", plot = figure4abc, width = 20, height = 22, units = "cm", dpi = 300)







# Adjust the legend text size
Figure_7dhealth <- Figure_7dhealth + 
  theme(legend.text = element_text(size = 16),  # Increase legend text size
        legend.title = element_text(size = 18),  # Increase legend title size
        legend.key.size = unit(1.8, "cm"))  # Increase legend key size for better visibility

# Save the combined figure
ggsave("Figure_7dhealth.jpeg", width = 15, height = 8)

view (data_clean)

# Fit the linear model
lm_model <- lm(mean_mgCpergSoilP ~ overall.score, data = data_summary)

# Get predictions along with confidence intervals
predictions <- predict(lm_model, newdata = data_summary, interval = "confidence", level = 0.95)

# Combine predictions with data_summary
predictions_df <- as.data.frame(predictions)
data_summary <- cbind(data_summary, predictions_df)
colnames(data_summary)[3:5] <- c("fit", "lwr", "upr")  # Rename columns for clarity

# Create unique column names if needed
names(data_summary) <- make.unique(names(data_summary))

# Now create the plot with error bands
POC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_mgCpergSoilP - se_mgCpergSoilP, ymax = mean_mgCpergSoilP + se_mgCpergSoilP), width = 0.2) +  # Error bars for means
  geom_ribbon(aes(ymin = lwr, ymax = upr), alpha = 0.2, fill = "black") +  # Error bands around regression line
  geom_line(aes(y = fit), color = "black") +  # Regression line
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Replace color1 and color2 with your desired colors
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
POC_health


# Calculate mean and standard error for mgCpergSoilP grouped by overall.score
data_summary <- data_clean %>%
  group_by(overall.score, AP) %>%
  summarise(
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),  # Calculate mean for each overall.score
    n = n(),  # Count total number of observations for each overall.score
    se_mgCpergSoilP = ifelse(n > 1, sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n), NA),  # Calculate SE
    .groups = 'drop'  # Avoid warnings about grouped data
  )

# View the summary to check for calculated values
print(data_summary)

# Create a plot with the regression line and error bars for POC
POC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilP)) +
  geom_point(data = data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP), alpha = 0.5) +  # Scatter plot of original data
  geom_errorbar(aes(ymin = mean_mgCpergSoilP - se_mgCpergSoilP, 
                    ymax = mean_mgCpergSoilP + se_mgCpergSoilP), 
                width = 0.2) +  # Use data_summary for error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Regression line
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Use your desired colors
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
POC_health




# Calculate means and standard errors for error bars
data_summary <- data_clean %>%
  group_by(overall.score, AP) %>%
  summarise(
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    se_mgCpergSoilP = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n()),
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n()),
    mean_propM = mean(propM, na.rm = TRUE),
    se_propM = sd(propM, na.rm = TRUE) / sqrt(n())
  )

# Create a plot with the regression line and error bars for POC
POC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_mgCpergSoilP - se_mgCpergSoilP, ymax = mean_mgCpergSoilP + se_mgCpergSoilP), width = 0.2) +  # Error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Replace color1 and color2 with your desired colors
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
POC_health

# Replace 'pere' with 'perennial' in the AP column
data_clean$AP[data_clean$AP == "pere"] <- "perennial"

# Create a plot with the regression line and error bars for MAOC
MAOC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_mgCpergSoilM - se_mgCpergSoilM, ymax = mean_mgCpergSoilM + se_mgCpergSoilM), width = 0.2) +  # Error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
MAOC_health

# Create a plot with the regression line and error bars for Proportion of Carbon as MAOC
PropMAOC_health <- ggplot(data_summary, aes(x = overall.score, y = mean_propM, color = AP)) +
  geom_point(alpha = 0.5) +
  geom_errorbar(aes(ymin = mean_propM - se_propM, ymax = mean_propM + se_propM), width = 0.2) +  # Error bars
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16),  # Increase y-axis label size
        legend.text = element_text(size = 14))   # Increase legend text size

# Display the plot
PropMAOC_health

# Arrange the plots side by side with shared legend
Figure_7dhealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             labels = c("a", "b", "c"),  # Labels for each plot
                             label.x = c(0.02, 0.02, 0.02),  # Position labels on the left
                             label.y = c(1.05, 1.05, 1.05),  # Position labels above the plots
                             common.legend = TRUE,  # Share a legend
                             legend = "top")  # Position legend at the top

# Adjust the legend text size
Figure_7dhealth <- Figure_7dhealth + 
  theme(legend.text = element_text(size = 16),  # Increase legend text size
        legend.title = element_text(size = 18),  # Increase legend title size
        legend.key.size = unit(1.5, "cm"))  # Increase legend key size for better visibility

# Save the combined figure
ggsave("Figure_7dhealth.jpeg", width = 15, height = 8)
# Arrange the plots side by side with shared legend
Figure_7ehealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns











# Create a plot with the regression line
POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg POC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
POC_health

# Replace 'pere' with 'perennial' in the AP column
data_clean$AP[data_clean$AP == "pere"] <- "perennial"
view(data_clean)

# Create a plot with the regression line for MAOC
MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("mg MAOC g"^-1~"soil")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
MAOC_health

# Create a plot with the regression line for PropMAOC
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
PropMAOC_health



## Calculate overall mean and standard error for propM
data_summary <- data_clean %>%
  summarise(
    mean_propM = mean(propM, na.rm = TRUE),  # Calculate overall mean
    n = n(),  # Count total number of observations
    se_propM = ifelse(n > 1, sd(propM, na.rm = TRUE) / sqrt(n), NA)  # Calculate SE
  )

# View the summary to check for calculated values
print(data_summary)

# Calculate overall mean and standard error for propM
data_summary <- data_clean %>%
  summarise(
    mean_propM = mean(propM, na.rm = TRUE),  # Calculate overall mean
    n = n(),  # Count total number of observations
    se_propM = ifelse(n > 1, sd(propM, na.rm = TRUE) / sqrt(n), NA)  # Calculate SE
  )

# Calculate overall mean and standard error for y_variable
overall_mean <- mean(data_clean$mgCpergSoilP, na.rm = TRUE)
overall_se <- sd(data_clean$mgCpergSoilP, na.rm = TRUE) / sqrt(nrow(data_clean))

# Create a plot with a single point and error bars
ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP)) +
  geom_point(alpha = 0.5) +  # Original data points
  geom_errorbar(aes(ymin = overall_mean - overall_se, ymax = overall_mean + overall_se), 
                width = 0.2) +  # Error bars at the overall mean
  labs(x = "Soil Health Index", y = "Y Variable") +
  theme_minimal()


# Get a representative x value (e.g., the mean overall.score)
mean_x_value <- mean(data_clean$overall.score, na.rm = TRUE)

# Create a plot with the regression line for PropMAOC with error bars
PropMAOC_health <- ggplot(data_clean, aes(x = overall.score, y = propM, color = AP)) +
  geom_point(alpha = 0.5) +  # Original data points
  geom_errorbar(data = data_summary, 
                aes(x = mean_x_value, ymin = mean_propM - se_propM, ymax = mean_propM + se_propM), 
                width = 0.2) +  # Error bars at the mean x value
  stat_smooth(method = "lm", se = FALSE, color = "black") +  # Single black line for the overall relationship
  labs(x = "Soil Health Index",
       y = expression("Proportion of Carbon as MAOC")) +
  scale_color_manual(values = c("#cd853f", "darkgreen"),  # Lighter brown and dark green
                     name = NULL) +  # Remove legend title
  theme_minimal() +
  theme(axis.title.x = element_text(size = 16),  # Increase x-axis label size
        axis.title.y = element_text(size = 16))  # Increase y-axis label size

# Display the plot
PropMAOC_health



library(ggpubr)

# Arrange the plots side by side with shared legend
Figure_7ehealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             
                             


                             Figure_7ehealth



                             
                        
                             # Fit linear models for each response variable
                             model_POC <- lm(mgCpergSoilP ~ overall.score, data = data_clean)
                             model_MAOC <- lm(mgCpergSoilM ~ overall.score, data = data_clean)
                             model_PropMAOC <- lm(propM ~ overall.score, data = data_clean)
                             
                             # Summarize the models to extract coefficients and significance
                             summary_POC <- summary(model_POC)
                             summary_MAOC <- summary(model_MAOC)
                             summary_PropMAOC <- summary(model_PropMAOC)
                             
                             # Extract slopes (coefficients) and p-values for overall.score
                             slope_POC <- summary_POC$coefficients["overall.score", "Estimate"]
                             p_value_POC <- summary_POC$coefficients["overall.score", "Pr(>|t|)"]
                             
                             slope_MAOC <- summary_MAOC$coefficients["overall.score", "Estimate"]
                             p_value_MAOC <- summary_MAOC$coefficients["overall.score", "Pr(>|t|)"]
                             
                             slope_PropMAOC <- summary_PropMAOC$coefficients["overall.score", "Estimate"]
                             p_value_PropMAOC <- summary_PropMAOC$coefficients["overall.score", "Pr(>|t|)"]
                             
                             # Print slopes and p-values
                             cat("Slope and p-value for mgCpergSoilP:\n")
                             cat("Slope:", slope_POC, "P-value:", p_value_POC, "\n")
                             
                             cat("Slope and p-value for mgCpergSoilM:\n")
                             cat("Slope:", slope_MAOC, "P-value:", p_value_MAOC, "\n")
                             
                             cat("Slope and p-value for propM:\n")
                             cat("Slope:", slope_PropMAOC, "P-value:", p_value_PropMAOC, "\n")                           
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             
                             

# Adjust the legend text size within each plot
POC_health <- POC_health + 
  theme(legend.text = element_text(size = 14),  # Increase legend item text size
        legend.title = element_blank())  # Ensure no legend title

MAOC_health <- MAOC_health + 
  theme(legend.text = element_text(size = 14),  # Increase legend item text size
        legend.title = element_blank())  # Ensure no legend title

PropMAOC_health <- PropMAOC_health + 
  theme(legend.text = element_text(size = 14),  # Increase legend item text size
        legend.title = element_blank())  # Ensure no legend title

# Arrange the plots side by side with shared legend
Figure_7dhealth <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             labels = c("a", "b", "c"),  # Labels for each plot
                             label.x = c(0.02, 0.02, 0.02),  # Position labels on the left
                             label.y = c(1.05, 1.05, 1.05),  # Position labels above the plots
                             common.legend = TRUE,  # Share a legend
                             legend = "top")  # Position legend at the top

# Save the combined figure
ggsave("Figure_7dhealth.jpeg", width = 15, height = 8)



# Arrange the plots side by side with shared legend
Figure_combined <- ggarrange(POC_health, MAOC_health, PropMAOC_health,
                             ncol = 3, nrow = 1,  # Arrange in 1 row and 3 columns
                             labels = c("a", "b", "c"),  # Labels for each plot
                             label.x = c(0.1, 0.5, 0.9),  # Adjust x positions of labels
                             label.y = c(1, 1, 1),  # Keep labels at the top
                             common.legend = TRUE,  # Share a legend
                             legend = "top")  # Position legend at the top

# Adjust the legend position to overlap with the first plot
Figure_7.health <- annotate_figure(Figure_combined,
                                   top = text_grob("", vjust = 0.5),  # Add space for legend
                                   bottom = text_grob("", vjust = 0.5))

# Display the combined figure
print(Figure_7.health)
ggsave("Figure_7.health.jpeg", width = 15, height = 8)


# Remove rows with NA values in the relevant columns
data_clean <- na.omit(data[, c("overall.score", "mgCpergSoilP", "AP")])

POC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilP, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE) +  # 'color' aesthetic in ggplot will be used
  labs(
    x = "Soil Health Index",
    y = expression("mg POC " * g^{-1} * " soil")
  ) +
  theme_minimal()

POC_health
# Remove rows with NA values in the relevant columns
data_clean <- na.omit(data[, c("overall.score", "mgCpergSoilM", "AP")])

MAOC_health <- ggplot(data_clean, aes(x = overall.score, y = mgCpergSoilM, color = AP)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE) +  # 'color' aesthetic in ggplot will be used
  labs(
    x = "Soil Health Index",
    y = expression("mg MAOC " * g^{-1} * " soil")
  ) +
  theme_minimal()

MAOC_health

ggsave("POC_health.jpeg", width = 15, height = 8)

   # Perform linear regression MAOC
  regression_model_MAOC <- lm(mgCpergSoilM ~ overall.score, data = data)
  summary
  

  # Create a plot with the regression line
  MAOC_health <- ggplot(data, aes(x = overall.score, y = mgCpergSoilM, color=AP)) +
    geom_point(alpha = 0.5) +
    stat_smooth(method = "lm", se = FALSE, color = "black") +
    labs(x = "Soil Health Index",
         y = expression("mg MAOC g"^-1~"soil")) +
    theme_minimal()
  ggsave("MAOC_health.jpeg", width = 15, height = 8)
  
   # Perform linear regression Prop MAOC
  regression_model_propMAOC <- lm(logitpropM ~ overall.score, data = data)
  summary(regression_model_propMAOC)
  
  # Create a plot with the regression line
  PropM_health <- ggplot(data, aes(x = overall.score, y = logitpropM, color=AP)) +
    geom_point(alpha = 0.5) +
    stat_smooth(method = "lm", se = FALSE, color = "black") +
    labs(x = "Soil Health Index",
         y = expression("Proportion of carbon as MAOC")) +
    theme_minimal()
  ggsave("PropM_health.jpeg", width = 15, height = 8)
  soilhealth3panel<- ggarrange(POC_health, MAOC_health, PropM_health,nrow=1,ncol=3, common.legend=T, legend="left", labels=c("a","b", "c"))
ggsave("soilhealth3panel.jpeg", width = 15, height = 8)
  
  # Define the coefficient for soil health regression (slopes)
  coef_POC <- .257  # in mg find in model summary
  coef_MAOC <- .377
  coef_PropM <- -.008
  # Define the mean values for each response variable
    mean_POC <- 8.17  
    mean_MAOC <- 16.77
    mean_PropM <- .76
  percentage_increase <- 10  #set a percentage increase of soil health based on data
    # Calculate the absolute increase in POC for the given percentage increase in aggregate stability
  absolute_increase_poc <- coef_POC * percentage_increase
  absolute_increase_maoc <- coef_MAOC * percentage_increase
  absolute_increase_propmaoc <- coef_PropM * percentage_increase
  # Calculate the percent increase in POC for a 1% increase in aggregate stability
  Onepercent_increase_poc <- (coef_POC / mean_POC) * 100
  Onepercent_increase_maoc <- (coef_MAOC / mean_MAOC) * 100
  Onepercent_increase_propmaoc <- (coef_PropM / mean_PropM) * 100
  # Calculate the percent increase in POC based on the mean value
  percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100
  percent_increase_maoc <- (absolute_increase_maoc / mean_MAOC) * 100
  percent_increase_propmaoc <- (absolute_increase_propmaoc / mean_PropM) * 100
    # Print the result POC
  print(paste("Absolute increase in POC for a 10 unit in soil health index is", round(absolute_increase_poc, 2), "mg"))
  print(paste("Percent increase in POC for a 1 unit increase in soil health index is", round(Onepercent_increase_poc, 2), "%"))
  print(paste("Percent increase in POC for a", percentage_increase, "% increase in soil health is", round(percent_increase_poc, 2), "%"))
  # Print the result MAOC
  print(paste("Absolute increase in MAOC for a 10 unit in soil health index is", round(absolute_increase_maoc, 2), "mg"))
  print(paste("Percent increase in MAOC for a 1 unit increase in soil health index is", round(Onepercent_increase_maoc, 2), "%"))
  print(paste("Percent increase in MAOC for a", percentage_increase, "% increase in soil health is", round(percent_increase_maoc, 2), "%"))
  # Print the result Prop MAOC
  print(paste("Absolute increase in Prop MAOC for a 10 unit in soil health index is", round(absolute_increase_propmaoc, 2), "%"))
  print(paste("Percent increase in Prop MAOC for a 1 unit increase in soil health index is", round(Onepercent_increase_propmaoc, 2), "%"))
  print(paste("Percent increase in Prop MAOC for a", percentage_increase, "% increase in soil health is", round(percent_increase_propmaoc, 2), "%"))
  


#Correlation plot
cordata <- cor(data[,c("mgCpergSoilP","overall.score","mgCpergSoilM","logitpropM")], use="pairwise.complete.obs", method="pearson")
corrplot(cordata)
cordata

#view na for ph: Z1, Z2 are truly NA
missing_ph <- subset(data, is.na(ph) | ph == "")
missing_field_codes <- missing_ph$Field_Code
print(missing_field_codes)

missing_mgCpergSoilP <- subset(data, is.na(mgCpergSoilP) | mgCpergSoilP == "")
missing_field_codes <- missing_mgCpergSoilP$Field_Code
print(missing_field_codes)

#First, graphically explore relationships among independent variables to look for interactions


data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=ppt.cm, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=ph, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=aggregate_stability, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(claycategory=cut(soil_texture_clay, breaks=c(-Inf, 14, 24, Inf), labels=c("low","med", "high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=soil_texture_clay))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ claycategory, ncol=1, scales="free_x")

#more interactions with ph
summary(data$ph)

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=ppt.cm, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=aggregate_stability, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=soil_texture_clay, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(phcategory=cut(ph, breaks=c(-Inf,6,7, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=ph))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ phcategory, ncol=1, scales="free_x")

#interactions with ppt

data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")


data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=aggregate_stability, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")

summary(data$ppt.cm)
data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")


data <- data %>% 
  mutate(pptcategory=cut(ppt.cm, breaks=c(-Inf,101.4, 110.0, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=ppt.cm))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ pptcategory, ncol=1, scales="free_x")

#interactions with aggregate stability
summary(data$aggregate_stability)

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=ph, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=ppt.cm, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=tmeanC, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=soil_texture_clay, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

data <- data %>% 
  mutate(agStcategory=cut(aggregate_stability, breaks=c(-Inf,29.3, 65.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=aggregate_stability))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ agStcategory, ncol=1, scales="free_x")

#tmeanC and active carbon
summary(data$tmeanC)

data <- data %>% 
  mutate(tmeanCcategory=cut(tmeanC, breaks=c(-Inf,6.8, 7.6, Inf), labels=c("low","med","high")))

ggplot(data=data, aes(x=active_carbon, y=mgCpergSoilP, col=tmeanC))+ 
  geom_point()+
  geom_smooth(method=lm)+
  facet_wrap(~ tmeanCcategory, ncol=1, scales="free_x")

#Models
#Correlation plot
cordata <- cor(data[,c("mgCpergSoilP","ph","ppt.cm","tmeanC","aggregate_stability","soil_texture_clay","active_carbon")], use="pairwise.complete.obs", method="pearson")
corrplot(cordata)
print(cordata)

##Linear Mixed Model for dependent variable (mgCpergSoilP)
#test without random effect, because only one value per field

m1P=gls(mgCpergSoilP~ppt.cm*tmeanC+soil_texture_clay+
          aggregate_stability+active_carbon+ 
          ph, data=data, na.action=na.exclude, method="ML")
summary(m1P)

m2P=gls(mgCpergSoilP~ppt.cm*tmeanC+soil_texture_clay+
          +aggregate_stability+active_carbon, data=data, na.action=na.exclude, method="ML")
summary(m2P)
anova(m1P, m2P)
library(nlme)
m3P=gls(mgCpergSoilP~ppt.cm*tmeanC
           +aggregate_stability+active_carbon+ph, 
         data=data, na.action=na.exclude, method="ML")
summary(m3P)
anova(m2P,m3P)
anova(m3P)

n <- nobs(m3P)
print(n)


# Perform ANOVA on the model
anova_result <- anova(m3P)

# Print the ANOVA table
print(anova_result)

# Extract the degrees of freedom for each variable
num_df <- anova_result$"numDF"  # Numerator degrees of freedom
den_df <- anova_result$"denDF"  # Denominator degrees of freedom

# Print the degrees of freedom
print(num_df)
print(den_df)

#pseudo R squared calculation (fit between model predicted data and actual data)
data$mgCpergSoilP.pred=as.vector(fitted(m3P))
R4=lm(mgCpergSoilP~mgCpergSoilP.pred, data=data, na.action=na.omit)
summary(R4) #r2=.4825

#check assumptions, distrubution of residuals
#final model should use REML
m3P=gls(mgCpergSoilP~ppt.cm*tmeanC
        +aggregate_stability+active_carbon+ph,
        data=data, na.action=na.exclude, method="REML") 
summary(m3P)

n_obs_model <- nobs(m3P)
print(n_obs_model) 
####predict(x= aggregate_stability) percent increase over the range of value obererved. 

F_Final <- fitted(m3P)
R_Final <- residuals(m3P, type = "pearson", scaled = TRUE)
N = !is.na(data$mgCpergSoilP)
Rfull <- NA
Rfull[N] <- R_Final
op <- par(mfrow = c(2,2), mar = c(5,4,1,1))  
plot(F_Final, R_Final)
hist(Rfull)
plot(Rfull ~ data$aggregate_stability)
plot(Rfull ~ data$soil_texture_clay)
plot(Rfull ~ data$active_carbon)
plot(Rfull ~ data$tmeanC)
plot(Rfull ~ data$ppt.cm)
plot(Rfull ~ data$ph)
par(op)

#partial residuals to test that the relationship is linear
#do these for each of the significant predictors (do green and red lines match?)

op <- par(mfrow = c(2,2), mar = c(5,4,1,1)) #this makes it so all the graphs are plotted in the same window (a 2 x 2 grid)

ppt.cm.c <- summary(m3P)$coefficients[2] #predictor coefficient
ppt.cm.pr <- Rfull + ppt.cm.c*data$ppt.cm  #Residuals + pred coef * predictor value
{scatter.smooth(data$ppt.cm, ppt.cm.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(ppt.cm.c*data$ppt.cm ~ data$ppt.cm), col = "red")} 

soil_texture_clay.c <- summary(m3P)$coefficients[3] #predictor coefficient
soil_texture_clay.pr <- Rfull + soil_texture_clay.c*data$soil_texture_clay  #Residuals + pred coef * predictor value
{scatter.smooth(data$soil_texture_clay, soil_texture_clay.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(soil_texture_clay.c*data$soil_texture_clay ~ data$soil_texture_clay), col = "red")} 

aggregate_stability.c <- summary(m3P)$coefficients[5] #predictor coefficient
aggregate_stability.pr <- Rfull + aggregate_stability.c*data$aggregate_stability  #Residuals + pred coef * predictor value
{scatter.smooth(data$aggregate_stability, aggregate_stability.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(aggregate_stability.c*data$aggregate_stability ~ data$aggregate_stability), col = "red")} 

active_carbon.c <- summary(m3P)$coefficients[6] #predictor coefficient
active_carbon.pr <- Rfull + active_carbon.c*data$active_carbon  #Residuals + pred coef * predictor value
{scatter.smooth(data$active_carbon, active_carbon.pr, 
                lpars = list(col = "green", lwd = 3, lty = 3)) #residual loess
  abline(lm(active_carbon.c*data$active_carbon ~ data$active_carbon), col = "red")} 

par(op)

#Visualize significant relationships

#own_theme below sets ggplot parameters for how plots should look. 
own_theme <- theme_bw(base_size = 12) +
  theme(rect = element_blank(),
        axis.ticks = element_line(color = "black"),
        axis.text = element_text(color = "black"),
        axis.line = element_line(color = "black"),
        panel.grid.minor = element_blank())

#ppt and tmeanC, option 1
summary(data$ppt.cm)
summary(data$tmeanC)

pred_pptC <- ggpredict(m3P, terms = c("ppt.cm", "tmeanC[6.8,7.5]"))
pred_pptC$tmean_group <- pred_pptC$group
levels(pred_pptC$tmean_group) <- c("low (4.5-7.2)",  
                                   "high (7.2-8.6)")
data <- data %>%
  drop_na(tmeanC) %>% 
  dplyr::mutate(tmean_group = cut(tmeanC, breaks = c(4.5,7.2,8.6)))

levels(data$tmean_group) <- c("low (4.5-7.2)",  
                              "high (7.2-8.6)")

mgPOM_pptC <-data %>% 
  ggplot() +
  geom_point(aes(x = ppt.cm, y = mgCpergSoilP, col = tmean_group), #plot your data
             size = 1.5, alpha = 0.5) +
  geom_line(pred_pptC, mapping = aes(x=x, y=predicted, col = tmean_group), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  #theme(legend.position = "none") +
  scale_y_continuous(expression("mg C in POM per g soil")) +
  scale_x_continuous(expression("Mean Annual Precipitation (cm)"),
                     label = scales::comma) +
  scale_color_manual(values = c("blue", "red")) # adjust colors if needed

mgPOM_pptC

ggsave("mgPOM_ppt_tmeanC.jpeg", width = 4, height = 3)


#ppt and tmeanC, option 2, Figure 4 Final
summary(data$ppt.cm)
pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC","ppt.cm[101,110]"))
pred_tmeanppt$ppt_group <- pred_tmeanppt$group
levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                   "high (104-142)")
data <- data %>%
  drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 levels(data$ppt_group) <- c("low (92-104)",  
                            "high (104-142)")
  mgPOM_tmeanppt <-data %>% 
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), #plot your data
              size = 1.5, alpha = 0.5) +
   geom_line(pred_tmeanppt, mapping = aes(x=x, y=predicted, col = ppt_group), #plot the model's prediction (based on linear )
             lwd = 1) +
   own_theme+
   #theme(legend.position = "none") +
   scale_y_continuous(expression("mg POC g"^-1 * "soil")) +
   scale_x_continuous(expression("Mean Annual Temperature(°C)"),
                      label = scales::comma) +
   scale_color_manual(name = "Mean Annual Precipitation (cm)", values = c("red", "blue"))+
    theme_minimal()
  theme(
    axis.title = element_text(size = 12),
    axis.text = element_text(size = 12),
    legend.title = element_text(size = 12),
    legend.text = element_text(size = 12),
    axis.line = element_line(color = "black") 
  )
 mgPOM_tmeanppt
 ggsave("mgPOM_Figure4.jpeg", width = 10, height = 8)
 
 #add axes line for Figure4a
 #ppt and tmeanC, option 2, Figure 4 Final
 summary(data$ppt.cm)
 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC","ppt.cm[101,110]"))
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                      "high (104-142)")
 data <- data %>%
   drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 levels(data$ppt_group) <- c("low (92-104)",  
                             "high (104-142)")
 
 # Plot new Figure with axes labels
 mgPOM_tmeanppt <- data %>% 
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), # Plot your data
              size = 1.5, alpha = 0.5) +
   geom_line(pred_tmeanppt, mapping = aes(x = x, y = predicted, col = ppt_group), # Plot the model's prediction
             lwd = 1) +
   own_theme +  # Apply your custom theme
   scale_y_continuous(expression("mg POC g"^-1 * "soil")) +
   scale_x_continuous(expression("Mean Annual Temperature(°C)"),
                      label = scales::comma) +
   scale_color_manual(name = "Mean Annual Precipitation (cm)", values = c("red", "blue")) +
   theme_minimal() +  # Use minimal theme
   theme(
     axis.title = element_text(size = 14),      # Font size for axis labels
     axis.text = element_text(size = 12),       # Font size for axis text
     legend.title = element_text(size = 14),    # Font size for legend title
     legend.text = element_text(size = 12),     # Font size for legend text
     axis.line = element_line(color = "black")  # Add black axis lines
   )
 
 # Show the plot
 mgPOM_tmeanppt
 
 
 # ppt and tmeanC, option 2, Figure 4 Final
 summary(data$ppt.cm)
 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC", "ppt.cm[101,110]"))
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                      "high (104-142)")
 
 data <- data %>%
   drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 levels(data$ppt_group) <- c("low (92-104)",  
                             "high (104-142)")
 
 # Plot
 mgPOM_tmeanppt <- data %>% 
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), # Plot your data
              size = 1.5, alpha = 0.5) +
   geom_line(pred_tmeanppt, mapping = aes(x = x, y = predicted, col = ppt_group), # Plot the model's prediction
             lwd = 1) +
   own_theme +  # Apply your custom theme
   scale_y_continuous(expression("mg POC g"^-1 * "soil")) +
   scale_x_continuous(expression("Mean Annual Temperature(°C)"),
                      label = scales::comma) +
   scale_color_manual(name = "Mean Annual Precipitation (cm)", values = c("red", "blue")) +
   theme_minimal() +  # Apply minimal theme
   theme(
     axis.title = element_text(size = 11),    # Font size for axis labels
     axis.text = element_text(size = 11),     # Font size for axis tick labels
     legend.title = element_text(size = 11),  # Font size for legend title
     legend.text = element_text(size = 11),   # Font size for legend text
     axis.line = element_line(color = "black")  # Add black axis lines
   )
 
 # Show the plot
 mgPOM_tmeanppt
 
 
 #fix font
 library(ggplot2)
 library(dplyr)
 library(ggeffects)  # Ensure ggeffects is loaded for ggpredict function
 
 # Generate predictions
 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC", "ppt.cm[101,110]"))
 
 # Assign and update the ppt_group levels in pred_tmeanppt
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 pred_tmeanppt$ppt_group <- factor(pred_tmeanppt$ppt_group, 
                                   levels = c("low", "high"),
                                   labels = c("low (92-104)", "high (104-142)"))
 
 # Prepare the data
 data <- data %>%
   drop_na(ppt.cm) %>%
   mutate(ppt_group = cut(ppt.cm, breaks = c(92, 104, 142),
                          labels = c("low (92-104)", "high (104-142)")))
 
 # Plot the data
 mgPOM_tmeanppt <- ggplot(data) +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, color = ppt_group), 
              size = 1.5, alpha = 0.5) +
   geom_line(data = pred_tmeanppt, aes(x = x, y = predicted, color = ppt_group), 
             size = 1) +
   labs(
     title = "Relationship between Mean Annual Temperature and mg POC per g Soil",
     x = "Mean Annual Temperature (°C)",
     y = expression("mg POC g"^-1 * "soil"),
     color = "Mean Annual Precipitation (cm)"
   ) +
   scale_color_manual(values = c("low (92-104)" = "red", "high (104-142)" = "blue")) +
   theme_minimal() +
   theme(
     axis.title = element_text(size = 14),
     axis.text = element_text(size = 12),
     legend.title = element_text(size = 12),
     legend.text = element_text(size = 10)
   )
 
 # Display the plot
 print(mgPOM_tmeanppt)
 
 # Save the plot
 ggsave("mgPOM_Figure4.jpeg", plot = mgPOM_tmeanppt, width = 10, height = 8)
 ``
 
 
 
 
 #tying to get line to end
 #ppt and tmeanC, option 2
 # Ensure predictions are within the range of observed tmeanC values
 # Identify the range of observed data

  # Determine the range of observed data for both factors
 range_tmeanC <- range(data$tmeanC, na.rm = TRUE)
 range_ppt_cm <- range(data$ppt.cm, na.rm = TRUE)
 
 # Generate predictions across a grid within the range of observed data
 tmeanC_seq <- seq(from = range_tmeanC[1], to = range_tmeanC[2], length.out = 100)
 ppt_cm_seq <- seq(from = range_ppt_cm[1], to = range_ppt_cm[2], length.out = 100)
 
 # Create a data frame for prediction
 prediction_data <- expand.grid(tmeanC = tmeanC_seq, ppt.cm = ppt_cm_seq)
 
 # Generate predictions using the model
 predictions <- predict(m3P, newdata = prediction_data, interval = "confidence")

 
summary(m3P)
 # Combine predictions with the prediction data
 pred_tmeanppt <- cbind(prediction_data, predicted = predictions)
 

 pred_tmeanppt <- ggpredict(m3P, terms = c("tmeanC","ppt.cm[101,110]"))
 pred_tmeanppt$ppt_group <- pred_tmeanppt$group
 levels(pred_tmeanppt$ppt_group) <- c("low (92-104)",  
                                      "high (104-142)")
 data <- data %>%
   drop_na(ppt.cm) %>% 
   dplyr::mutate(ppt_group = cut(ppt.cm, breaks = c(92,104,142)))
 
 levels(data$ppt_group) <- c("low (92-104)",  
                             "high (104-142)")
 
 
 # Plot the data and the fitted line
 mgPOM_tmeanppt <- data %>%
   ggplot() +
   geom_point(aes(x = tmeanC, y = mgCpergSoilP, col = ppt_group), size = 1.5, alpha = 0.5) +
   geom_line(data = pred_tmeanppt, aes(x = x, y = predicted, col = ppt_group), lwd = 1) +
   own_theme +
   scale_y_continuous(expression("mg POC g"^-1~"soil")) +
   scale_x_continuous(expression("Mean Annual Temperature (°C)"),
                      label = scales::comma) +
   scale_color_manual(values = c("red", "blue")) +
   labs(color = "Precipitation Group")
 
 print(mgPOM_tmeanppt)
 
 ggsave(" mgPOM_tmeanppt.jpeg", width = 10, height = 8)
view(data)

#for agg stability color by AP()
pred_aggregate_stability <- ggpredict(m3P, terms = c"aggregate_stability","AP"))
mgPOM_aggregate_stability <-data %>% 
  ggplot() +
  geom_point(aes(x = aggregate_stability, y = mgCpergSoilP,color=AP),
                     size = 1.5, alpha = 0.5) +
  geom_line(pred_aggregate_stability, mapping = aes(x=x, y=predicted,color=group), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  #theme(legend.position = "none") +
  scale_y_continuous(
    name = expression("mg POC " * g^{-1} * " soil")
  )
scale_x_continuous(expression("Aggregate Stability (%)"),
                     label = scales::comma) 

mgPOM_aggregate_stability
ggsave("mgPOM_aggregate_stability.jpeg", width = 15, height = 8, units="cm")

library(ggplot2)
library(ggeffects)
library(dplyr)

# Define the coefficient for active carbon
coef_activecarbon <-  0.01317  # in ppm
# Define the mean value of POC (baseline POC)
mean_POC <- 8.17  # Replace with the actual mean value from your data
# Define the ppm increase in active carbon
ppm_increase <- 100  # For a 100 ppm increase in active carbon

# Calculate the absolute increase in POC for the given ppm increase in active carbon
absolute_increase_poc <- coef_activecarbon * ppm_increase

# Calculate the percent increase in POC based on the mean value
percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100

# Print the result
print(paste("Percent increase in POC for a", ppm_increase, "ppm in active carbon is", round(percent_increase_poc, 2), "%"))


# Assuming 'data' is your data frame and 'mgCpergSoilP' is the column name for POC
mean_poc <- mean(data$mgCpergSoilP, na.rm = TRUE)

# Print the mean POC value
print(paste("The mean POC is", round(mean_poc, 2), "mg"))



# Generate predictions from the model
pred_aggregate_stability <- ggpredict(m3P, terms = c("aggregate_stability"))
# Convert the ggpredict object to a data frame
pred_df <- as.data.frame(pred_aggregate_stability)

# Create the plot

  View(data)
  mgPOM_aggregate_stability <- data %>%
    ggplot(aes(x = aggregate_stability, y = mgCpergSoilP)) +
    geom_point(size = 1.5, alpha = 0.5) +
    geom_line(data = pred_df, aes(x = x, y = predicted), color = "black", lwd = 1) +  # Plot the model's prediction
    own_theme +  # Ensure 'own_theme' is defined or remove it
    theme(legend.position = "none") +
    scale_y_continuous(name = expression("mg POC " * g^{-1} * " soil")) +
    scale_x_continuous(name = expression("Aggregate Stability (%)"),
                       labels = scales::comma)
  
  mgPOM_aggregate_stability
  
ggsave("mgPOM_aggregate_stability.jpeg", width = 4, height = 3)

# Define the coefficient for aggregate stability
coef_aggregate_stability <- 0.06799  # in mg find in model summary
# Define the mean value of POC 
mean_POC <- 8.17  # Replace with the actual mean value from data
percentage_increase <- 10  #set a percentage increase of agg stability based on data

# Calculate the absolute increase in POC for the given percentage increase in aggregate stability
absolute_increase_poc <- coef_aggregate_stability * percentage_increase
# Calculate the percent increase in POC for a 1% increase in aggregate stability
Onepercent_increase_poc <- (coef_aggregate_stability / mean_POC) * 100
# Calculate the percent increase in POC based on the mean value
percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100

# Print the result
print(paste("Absolute increase in POC for a 10% increase in aggregate stability is", round(absolute_increase_poc, 2), "mg"))
# Print the result
print(paste("Percent increase in POC for a 1% increase in aggregate stability is", round(Onepercent_increase_poc, 2), "%"))
# Print the result
print(paste("Percent increase in POC for a", percentage_increase, "% increase in aggregate stability is", round(percent_increase_poc, 2), "%"))


# Define the coefficient for active carbon
coef_activecarbon <-  0.01317  # in ppm
# Define the mean value of POC (baseline POC)
mean_POC <- 8.17  # Replace with the actual mean value from your data
# Define the ppm increase in active carbon
ppm_increase <- 100  # For a 100 ppm increase in active carbon

# Calculate the absolute increase in POC for the given ppm increase in active carbon
absolute_increase_poc <- coef_activecarbon * ppm_increase

# Calculate the percent increase in POC based on the mean value
percent_increase_poc <- (absolute_increase_poc / mean_POC) * 100

# Print the result
print(paste("Percent increase in POC for a", ppm_increase, "ppm in active carbon is", round(percent_increase_poc, 2), "%"))


# Assuming 'data' is your data frame and 'mgCpergSoilP' is the column name for POC
mean_poc <- mean(data$mgCpergSoilP, na.rm = TRUE)

# Print the mean POC value
print(paste("The mean POC is", round(mean_poc, 2), "mg"))

#Figure 3b

# Generate predictions from the model
pred_active_carbon <- ggpredict(m3P, terms = c("active_carbon"))
# Convert the ggpredict object to a data frame
pred_df <- as.data.frame(pred_active_carbon)

# Create the plot
mgPOM_active_carbon <- data %>%
  ggplot(aes(x = active_carbon, y = mgCpergSoilP)) +
  geom_point(size = 1.5, alpha = 0.5) +
  geom_line(data = pred_df, aes(x = x, y = predicted), color = "black", lwd = 1) +  # Change color of the line
  own_theme +  
  theme(legend.position = "none") +
  scale_y_continuous(
    name = expression("mg POC " * g^{-1} * " soil")
  ) +
  scale_x_continuous(
    name = expression("Active Carbon (ppm)"),
    labels = scales::comma
  )

mgPOM_active_carbon
ggarrange(mgPOM_aggregate_stability,mgPOM_active_carbon,nrow=1, common.legend=T, legend="left", labels=c("a","b"))

# Arrange plots in a 2x2 layout without a legend
Figure2Final<- ggarrange(mgPOM_aggregate_stability, mgPOM_active_carbon, 
          mgMAOM_aggregate_stability, mgMAOM_active_carbon, 
          nrow = 2, ncol = 2, 
          labels = c("a", "b", "c", "d"), 
          common.legend = FALSE)
# Save the plot using ggsave
ggsave("Figure2Final.jpeg", plot = Figure2Final, width = 10, height = 8, dpi = 300)



#ppt on own
pred_ppt <- ggpredict(m3P, terms = c("ppt.cm"))
mgPOM_ppt <-data %>% 
  ggplot() +
  geom_point(aes(x = ppt.cm, y = mgCpergSoilP), #plot your data
             size = 1.5, alpha = 0.5) +
  geom_line(pred_ppt, mapping = aes(x=x, y=predicted), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  theme(legend.position = "none") +
  scale_y_continuous(expression("mg C in POM per g soil"))+
  scale_x_continuous(expression("mean annual precipitation (cm)"),
                     label = scales::comma) 

mgPOM_ppt

#tmeanC on own
pred_temp <- ggpredict(m3P, terms = c("tmeanC"))
mgPOM_temp <-data %>% 
  ggplot() +
  geom_point(aes(x = tmeanC, y = mgCpergSoilP), #plot your data
             size = 1.5, alpha = 0.5) +
  geom_line(pred_temp, mapping = aes(x=x, y=predicted), #plot the model's prediction (based on linear )
            lwd = 1) +
  own_theme+
  theme(legend.position = "none") +
  scale_y_continuous(expression("mg C in POM per g soil"))+
  scale_x_continuous(expression("mean annual temperature (C)"),
                     label = scales::comma) 

mgPOM_temp


# Create a violin plot with individual data points
ggplot(data, aes(x = Type.x, y = mgCpergSoilP)) +
  geom_violin(trim = FALSE, fill = "lightblue") +  # Create the violin plot
  geom_jitter(width = 0.2, size = 1, color = "darkblue") +  # Add jittered points
  labs(title = "Distribution of mg POM by Field Type",
       x = "Field Type",
       y = "mgC per g Soil POM") +
  theme_minimal()  # Apply a minimal theme for a clean look   

# Create a violin plot with individual data points and mean line
ggplot(data, aes(x = Type.x, y = mgCpergSoilP, color = Type.x, fill = Type.x)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1) +  # Add jittered points
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
  labs(title = "Distribution of mgCpergSoilP by Field Type",
       x = "Field Type",
       y = "mgC per g Soil POM") +
  theme_minimal()  # Apply a minimal theme for a clean look

# Create a violin plot with individual data points and mean line for soil texture class
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, color = soil_texture_class, fill = soil_texture_class)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1) +  # Add jittered points
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
  labs(title = "Distribution of mgCpergSoilP by Field Type",
       x = "Soil Texture Class",
       y = "mgC per g Soil POM") +
  theme_minimal()  # Apply a minimal theme for a clean look

# Create a violin plot with individual data points and mean line for soil texture class
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, color = soil_texture_class, fill = soil_texture_class)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1) +  # Add jittered points
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
  labs(title = "Distribution of mgCpergSoilP by Soil Texture Class",
       x = "Soil Texture Class",
       y = "mgC per g Soil POM") +
  theme_minimal() +  # Apply a minimal theme for a clean look
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),  # Adjust text angle, justification, and size
        plot.margin = margin(5, 5, 10, 5))  # Increase the bottom margin to give more space to labels

# Load necessary library
library(ggplot2)  # For plotting


# Get unique options in soil_texture_class
unique_soil_texture <- unique(data$soil_texture_class)

# Print the unique options
print(unique_soil_texture)

view(data$soil_texture_clay)

# Soil texture and field type
set.seed(123)
data <- data.frame(
  soil_texture_class = sample(c("Sandy", "Loam", "Clayey"), 100, replace = TRUE),
  Type.x = sample(c("Corn", "field crops", "hay", "pasture", "Veg", "corn"), 100, replace = TRUE),
  mgCpergSoilP = rnorm(100, mean = 10, sd = 2)
)

# Create a boxplot or violin plot
ggplot(data, aes(x = cut(soil_texture_clay, breaks = 5), y = Type.x)) +
  geom_boxplot() +  # or geom_violin() for a violin plot
  labs(x = "Soil Texture Clay Levels", y = "Field Type") +
  ggtitle("Comparison of Field Types across Soil Texture Clay Levels")


# Create a violin plot with individual data points and mean line for soil texture and field type
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, fill = Type.x)) +
  geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
  geom_jitter(width = 0.2, size = 1, position = position_jitterdodge()) +  # Add jittered points, dodge by Type.x
  stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow", position = position_dodge(width = 0.2)) +  # Add mean points, dodge by Type.x
  labs(title = "Distribution of mgCpergSoilP by Soil Texture and Field Type",
       x = "Soil Texture Class",
       y = "mgC per g Soil POM",
       fill = "Field Type") +
  theme_minimal() +  # Apply a minimal theme for a clean look
  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),  # Adjust text angle, justification, and size
        plot.margin = margin(5, 5, 10, 5))  # Increase the bottom margin to give more space to labels


#anova by field type to see differences 
field_anova<- aov(mgCpergSoilP~Type.x, data=data)
summary(field_anova)  

TukeyHSD(field_anova)


library(dplyr)

# Remove rows where Type.x is "Wheat"
data_filtered <- data %>% filter(Type.x != "Wheat")
# Remove rows where Type.x is "Wheat"
data_filtered <- filter(data, Type.x != "Field crops")

View(data_filtered)
# Run the ANOVA
field_anova <- aov(mgCpergSoilP ~ Type.x, data = data_filtered)

# Display the summary of the ANOVA
summary(field_anova)
# Run the ANOVA
field_anova <- aov(mgCpergSoilM ~ Type.x, data = data_filtered)

# Display the summary of the ANOVA
summary(field_anova)

# Run the ANOVA
field_anovaProp <- aov(logitpropM ~ Type.x, data = data_filtered)

# Display the summary of the ANOVA
summary(field_anovaProp)


# Calculate means by field type
means_by_field_type <- data %>%
  group_by(Type.x) %>%
  summarise(mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE))

print(means_by_field_type)

#anova by field type to see differences 
field_anova<- aov(mgCpergSoilM~Type.x, data=data)

summary(field_anova)  

TukeyHSD(field_anova)

# Calculate means by field type
means_by_field_type <- data %>%
  group_by(Type.x) %>%
  summarise(mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

print(means_by_field_type)


#anova by field type to see differences 
field_anova<- aov(propM~Type.x, data=data)
summary(field_anova)  
# Calculate means by field type
TukeyHSD(field_anova)
means_by_field_type <- data %>%
  group_by(Type.x) %>%
  summarise(mean_propM = mean(propM, na.rm = TRUE))

print(means_by_field_type)


# Create the new column 'AP'
data <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "Perennial",
    Type.x %in% c("Corn", "Veg") ~ "Annual",
    TRUE ~ NA_character_ # This handles any values not specified in the conditions
  ))

# View the updated dataframe
print(data)
view(data)

#anova by AP to see differences 
AP_anova<- aov(mgCpergSoilP~AP, data=data)
summary(AP_anova)  

TukeyHSD(AP_anova)

# Calculate the means and standard errors
# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    se_mgCpergSoilP = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#AP data for MAOC
#anova by AP to see differences 
APM_anova<- aov(mgCpergSoilM~AP, data=data)
summary(APM_anova)  

TukeyHSD(APM_anova)
summary(APM_anova)

# Calculate the means and standard errors
library(dplyr)

# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#AP data for logitprop MAOC
#anova by AP to see differences 
APPM_anova<- aov(logitpropM~AP, data=data)
summary(APPM_anova)  

TukeyHSD(APM_anova)
summary(APM_anova)

# Calculate the means and standard errors
library(dplyr)

# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_logitpropM = mean(logitpropM, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_logitpropM = mean(logitpropM, na.rm = TRUE),
    se_logitproplM = sd(logitpropM, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)

#AP data for soil health score
#anova by AP to see differences 
APSH_anova<- aov(overall.score~AP, data=data)
summary(APSH_anova)  

TukeyHSD(APSH_anova)
summary(APSH_anova)

# Calculate means
means <- data %>%
  group_by(AP) %>%
  summarise(mean_overall.score = mean(overall.score, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(AP) %>%
  summarise(
    mean_overall.score = mean(overall.score, na.rm = TRUE),
    se_overall.score = sd(overall.score, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#anova by field type to see differences MAOC
field_anova<- aov(logitpropM~Type.x, data=data)
summary(field_anova)  

TukeyHSD(field_anova)

# Calculate means
means <- data %>%
  group_by(Type.x) %>%
  summarise(mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

# Calculate standard errors
errors <- data %>%
  group_by(Type.x) %>%
  summarise(
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())
  )

# Print the results
print(means)
print(errors)


#anova by soil texture class to see differences 
texture_anova<- aov(mgCpergSoilP~soil_texture_class, data=data)
summary(texture_anova)  

TukeyHSD(texture_anova)
# Create a new column Tillage_Category with descriptive labels
data <- data %>%
  mutate(Tillage_Category = factor(Tillage_1to4,
                                   levels = c(1, 2, 3, 4),
                                   labels = c("No Till", 
                                              "1-7 inch Till", 
                                              "7-9 inch Till", 
                                              ">9 inch Till")))



# Check the new column
summary(data$Tillage_Category)


# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = recode(Type.x, "Field crops" = "Wheat"))

# Check the result to ensure the changes were applied correctly
table(data$Type.x)
library(dplyr)

# Convert Type.x to character if it is a factor
data <- data %>%
  mutate(Type.x = as.character(Type.x))

# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = recode(Type.x, "Field crops" = "Wheat"))

library(dplyr)

# Inspect the data type and unique values in Type.x
str(data$Type.x)  # Check the structure of the column
unique(data$Type.x)  # Check unique values

# Convert Type.x to character if it is a factor
data <- data %>%
  mutate(Type.x = as.character(Type.x))

# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = ifelse(Type.x == "Field crops", "Wheat", Type.x))

# Optionally convert back to factor
data$Type.x <- factor(data$Type.x)

# Check the result to ensure the changes were applied correctly
table(data$Type.x)




# Check the result to ensure the changes were applied correctly
table(data$Type.x)

# Create the stacked bar plot

ggplot(data, aes(x = Type.x, fill = factor(Tillage_Category))) +
  geom_bar(position = "stack") +
  labs(title = "",
       x = "Crop Type",
       y = "Number of Fields",
       fill = "Tillage Category") +
  theme_minimal()

library(dplyr)

# Inspect the data type and unique values in Type.x
str(data$Type.x)  # Check the structure of the column
unique(data$Type.x)  # Check unique values

# Convert Type.x to character if it is a factor
data <- data %>%
  mutate(Type.x = as.character(Type.x))

# Update Type.x: Change "Field crops" to "Wheat"
data <- data %>%
  mutate(Type.x = ifelse(Type.x == "Field crops", "Wheat", Type.x))

# Reorder and convert Type.x to factor with the desired levels
data$Type.x <- factor(data$Type.x,
                      levels = c("Hay", "Pasture", "Corn", "Veg", "Wheat"))

# Check the result to ensure the changes were applied correctly
table(data$Type.x)


# Create the stacked bar plot
ggplot(data, aes(x = Type.x, fill = factor(till.passes))) +
  geom_bar(position = "stack") +
  labs(title = "Distribution of Tillage Passes by Field Type",
       x = "Field Type",
       y = "Count",
       fill = "Tillage Category") +
  theme_minimal()


# Perform linear regression
regression_modelPM <- lm(mgCpergSoilM ~ mgCpergSoilP, data = data)

# Perform linear regression
regression_modelMAOC <- lm(mgCpergSoilM ~ Type.x, data = data)
anova(regression_modelMAOC)
# Summarize the regression model
summary(regression_modelPM)

data
regression_modelPOC <- lm(mgCpergSoilP ~ Type.x, data = data)
anova(regression_modelPOC)



#Figure 8 Final This is now Figure 5 submit

Figure8d <- ggplot(data, aes(x = mgCpergSoilP, y = mgCpergSoilM, color= AP)) +
  geom_point(alpha = 0.5) +  # Explicitly set all points to black
  stat_smooth(method = "lm", se = FALSE, color = "black", lwd = 1) +  # Keep the line black
  own_theme +  
  theme(legend.title = element_blank(),
        legend.position = c(0.8, 0.8),# Remove legend
       # axis.title = element_text(size = 12),  # Axis title size
       # axis.text = element_text(size = 12),   # Axis text size
        axis.line = element_line(color = "black"),  # Add axis lines
        axis.ticks = element_line(color = "black"),  # Optional: Add ticks
        strip.background = element_blank()) +  # Remove facet strip background if it's present
  labs(
    x = expression(paste("mg POC ", g^{-1}, " soil")),  # X-axis label
    y = expression(paste("mg MAOC ", g^{-1}, " soil"))) +
  scale_color_manual(values = c("Annual" = "#cd853f", "Perennial" = "darkgreen"))  # Custom colors for annual and perennial



Figure8d



# Save the plot
ggsave("FinalFigures/Figure5_submit.jpeg", plot= Figure8d, width = 4, height = 3, dpi= 600) 


Figure8a
# Fit the linear model
lm_model <- lm(mgCpergSoilM ~ mgCpergSoilP, data = data)

# Get the summary of the model
model_summary <- summary(lm_model)

# Extract slope and p-value
slope <- model_summary$coefficients[2, 1]  # Slope (the coefficient of mgCpergSoilP)
p_value <- model_summary$coefficients[2, 4]  # P-value for the slope

# Print the results
print(paste("Slope:", slope))
print(paste("P-value:", p_value))

# Display the plot
Figure8a

 Figure8a<-ggplot(data, aes(x = mgCpergSoilP, y = mgCpergSoilM)) +
  geom_point(alpha = 0.5) +
  stat_smooth(method = "lm", se = FALSE, color = "black") +
  labs(
    x = expression(paste("mg POC ", g^{-1}, " soil")),
    y = expression(paste("mg MAOC ", g^{-1}, " soil"))
  ) +
  theme_minimal()

# Adjust the legend text size
Figure8a <- Figure8a + 
  theme(legend.text = element_text(size = 16),  # Increase legend text size
        legend.title = element_text(size = 18)) +  # Increase legend title size
  theme(legend.key.size = unit(1.5, "cm"))  # Increase legend key size for better visibility
Figure8a
ggsave("Figure8a.jpeg", width = 15, height = 8)  
  
  

# Subset the data frame to get only the rows where Type.x is 'Field_crops'
  field_crops_samples <- subset(data, Type.x == "Field crops")

# Extract the Field_code for those samples
  field_crops_codes <- field_crops_samples$Field_Code
  
  # Print the result
  print(field_crops_codes)
  
  library(ggplot2)
  library(dplyr)
  library(car) # for Levene's Test
  library(ggpubr) # for easy plotting
  
  # Check the distribution of pH for each Type.x using boxplots
  ggboxplot(data, x = "Type.x", y = "ph", 
            color = "Type.x", palette = "jco",
            ylab = "pH", xlab = "Field Type")
  
  # Check the normality assumption
  shapiro_test <- data %>%
    group_by(Type.x) %>%
    summarise(shapiro_p = shapiro.test(ph)$p.value)
  
  print(shapiro_test)
  
  # Check the homogeneity of variances assumption
  levene_test <- leveneTest(ph ~ Type.x, data = data)
  
  print(levene_test)
  
  # If p-value of Shapiro-Wilk test and Levene's test are greater than 0.05, proceed with ANOVA
  if (all(shapiro_test$shapiro_p > 0.05) && levene_test$p.value > 0.05) {
    # Perform ANOVA
    anova_result <- aov(ph ~ Type.x, data = data)
    summary(anova_result)
    
    # Post-hoc test if ANOVA is significant
    if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
      tukey_result <- TukeyHSD(anova_result)
      print(tukey_result)
    }
  } else {
    # If assumptions are not met, perform the Kruskal-Wallis test
    kruskal_result <- kruskal.test(ph ~ Type.x, data = data)
    print(kruskal_result)
  }
  
  
  # Post-hoc test if ANOVA is significant
  if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
    tukey_result <- TukeyHSD(anova_result)
    print(tukey_result)
    
    # Plot the Tukey HSD results
    plot(tukey_result)
  }
  } else {
    # If assumptions are not met, perform the Kruskal-Wallis test
    kruskal_result <- kruskal.test(ph ~ Type.x, data = data)
    print(kruskal_result)
    
    # If Kruskal-Wallis test is significant, perform post-hoc Dunn test
    if (kruskal_result$p.value < 0.05) {
      library(FSA) # For Dunn test
      dunn_result <- dunnTest(pH ~ Type.x, data = data, method = "bh")
      print(dunn_result)
    }
  }




# test for differences in pH for field types
#all CIs overlap indicatin no sigficant difference
# Perform ANOVA
anova_result <- aov(ph ~ Type.x, data = data)
# Summary of ANOVA
summary(anova_result)
# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result, ~ Type.x)
# Print pairwise comparisons
print(posthoc, type = "compact")

# Example scatter plot with jitter
ggplot(data, aes(x = Type.x, y = ph)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  labs(x = "Field Type", y = "pH") +
  ggtitle("Relationship between pH and Field Type") +
  theme_minimal()

# look at the normality of each variable within each group
shapiro_test_results <- data %>%
  group_by(Type.x) %>%
  summarise(
    K = shapiro.test(k)$p.value,
    Mn = shapiro.test(mn)$p.value,
    Fe = shapiro.test(fe)$p.value,
    Mg = shapiro.test(mg)$p.value,
    Zn = shapiro.test(zn)$p.value
  )
print(shapiro_test_results)

# Perform MANOVA
manova_result <- manova(cbind(k, mn, fe, mg, zn) ~ Type.x, data = data)
summary(manova_result)

# If MANOVA is significant, perform post-hoc tests
summary.aov(manova_result)

# Perform separate ANOVAs with Bonferroni correction
anova_results <- list(
  K = aov(k ~ Type.x, data = data),
  Mn = aov(mn ~ Type.x, data = data),
  Fe = aov(fe ~ Type.x, data = data),
  Mg = aov(mg ~ Type.x, data = data),
  Zn = aov(zn ~ Type.x, data = data)
)

# Print ANOVA summaries
lapply(anova_results, summary)

# Apply Bonferroni correction (or other corrections) to p-values
p_values <- sapply(anova_results, function(x) summary(x)[[1]]$`Pr(>F)`[1])
p_values_adjusted <- p.adjust(p_values, method = "bonferroni")

print(data.frame(Variable = names(p_values), P_value = p_values, Adjusted_P_value = p_values_adjusted))
}

# Perform ANOVAs for each cation
anova_results <- list(
  K = aov(k ~ Type.x, data = data),
  Mn = aov(mn ~ Type.x, data = data),
  Fe = aov(fe ~ Type.x, data = data),
  Mg = aov(mg ~ Type.x, data = data),
  Zn = aov(zn ~ Type.x, data = data)
)

# Print ANOVA summaries
anova_summaries <- lapply(anova_results, summary)
print(anova_summaries)

# Perform Tukey's HSD test if ANOVA is significant
tukey_results <- lapply(anova_results, function(x) {
  if (summary(x)[[1]]$`Pr(>F)`[1] < 0.05) {
    TukeyHSD(x)
  } else {
    NULL
  }
})

# Print Tukey's HSD results
print(tukey_results)

# Optionally plot Tukey's HSD results
par(mfrow = c(3, 2))
for (i in 1:length(tukey_results)) {
  if (!is.null(tukey_results[[i]])) {
    plot(tukey_results[[i]], main = names(tukey_results)[i])
  }
}

#regression of MAOM and tillage

regression_model <- lm(mgCpergSoilM ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)

#graph the regression

# Create a new data frame with predictions
data_with_predictions <- data %>%
  mutate(predicted = predict(regression_model, newdata = data))

library(ggplot2)
library(dplyr)

# Assuming regression_model is already created and data_with_predictions is calculated

# Create a new data frame with predictions for plotting
data_with_predictions <- data %>%
  mutate(predicted = predict(regression_model, newdata = data)) %>%
  group_by(Tillage_1to4) %>%
  summarize(mean_predicted = mean(predicted), 
            mean_mgCpergSoilP = mean(mgCpergSoilP), 
            .groups = 'drop')

# Plot the data
ggplot(data, aes(x = Tillage_1to4, y = mgCpergSoilM)) +
  geom_jitter(width = 0.2, size = 2, alpha = 0.5) +  # Scatter plot with jitter to avoid overplotting
  geom_point(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted), color = "red", size = 3, shape = 1) +  # Predicted values
  geom_line(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted, group = 1), color = "blue", size = 1) +  # Regression line
  labs(title = "Regression of mgCpergSoilP on Tillage_1to4",
       x = "Tillage Category",
       y = "POC mg C per g Soil",
       color = "Legend") +
  scale_x_discrete(labels = c("1" = "No Till", "2" = "1-7inch Till", "3" = "7-9inch Till", "4" = ">9inch Till")) +  # Customize x-axis labels
  theme_minimal()


# Create the data
tillMAOC <- data.frame(
  Tillage_Category = c("No-till", "1-7 inch", "7-9 inch", "> 9 inch"),
  MAOC = c(18.9, 15.9, 15.1, 17.7),
  se = c(1.20, 1.08, 1.66, 2.02)
)

# Perform one-way ANOVA
anova_result <- aov(MAOC ~ Tillage_Category, data = tillMAOC)

# Tukey's post hoc test
tukey_result <- TukeyHSD(anova_result, "Tillage_Category")

# View Tukey's test results
print(tukey_result)

#Supplement Table 1 significance of differences
# Values for No-Till
mean_no_till <- 18.9
se_no_till <- 1.2

# Values for other tillage levels
means_other <- c(15.9, 15.1, 17.7)
ses_other <- c(1.08, 1.66, 2.02)

# Calculate the mean and SE for the comparison group
mean_other <- mean(means_other)
se_other <- sqrt(sum(ses_other^2) / length(ses_other))  # Pooled SE

# Calculate the t-statistic
mean_diff <- mean_no_till - mean_other
t_stat <- mean_diff / sqrt(se_no_till^2 + se_other^2)

# Degrees of freedom for the comparison (approximation)
df <- length(means_other) - 1

# Calculate the p-value
p_value <- 2 * pt(-abs(t_stat), df)

# Output results
mean_other
mean_diff
t_stat
p_value


# Example scatter plot with jitter
library(ggplot2)

ggplot(data, aes(x = as.factor(Tillage_1to4), y = mgCpergSoilP)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "POC") +
  ggtitle("Relationship between Tillage and POC") +
  theme_minimal()

#Ensure Tillage_1to4 is a factor
data <- data %>%
  mutate(Tillage_1to4 = as.factor(Tillage_1to4))

#Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_1to4, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)

# Optionally, plot the Tukey HSD results
plot(tukey_result)


# Load necessary libraries
library(ggplot2)
library(dplyr)
library(multcomp)

# Create a new variable that combines Tillage_1to4 = 2, 3, and 4 into a single group
data <- data %>%
  mutate(Tillage_Grouped = ifelse(Tillage_1to4 == 1, "1", "2, 3, 4"))

# Ensure the new variable is a factor
data$Tillage_Grouped <- as.factor(data$Tillage_Grouped)

View(data)
# Perform ANOVA
anova_result <- aov(mgCpergSoilM ~ Tillage_Grouped, data = data)
summary(anova_result)
# Perform ANOVA
anova_result <- aov(aggregate_stability ~ Tillage_Grouped, data = data)
summary(anova_result)
# Perform ANOVA
anova_result <- aov(aggregate_stability ~ AP, data = data)
summary(anova_result)


# Calculate mean, standard error, and sample size for mgCpergSoilP and mgCpergSoilM by Tillage_Grouped
summary_stats <- data %>%
  group_by(Tillage_Grouped) %>%
  summarize(
    n = n(),  # Sample size
    mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),  # Mean for mgCpergSoilP
    se_mgCpergSoilP = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n()),  # SE for mgCpergSoilP
    mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),  # Mean for mgCpergSoilM
    se_mgCpergSoilM = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())   # SE for mgCpergSoilM
  )

# View the summary statistics
print(summary_stats)

# Conduct a t-test for mgCpergSoilP
t_test_P <- t.test(mgCpergSoilP ~ Tillage_Grouped, data = data)

# Print the results
print(t_test_P)
# Filter the data to remove NAs in mgCpergSoilP and mgCpergSoilM
data_filtered <- data %>%
  filter(!is.na(mgCpergSoilP), !is.na(mgCpergSoilM))

# Conduct a t-test for mgCpergSoilP
t_test_P <- t.test(mgCpergSoilP ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_P)

# Conduct a t-test for mgCpergSoilM
t_test_M <- t.test(mgCpergSoilM ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_M)




# Filter the data to remove NAs in mgCpergSoilP and mgCpergSoilM
data_filtered <- data %>%
  filter(!is.na(mgCpergSoilP), !is.na(mgCpergSoilM))

# Conduct a t-test for mgCpergSoilP
t_test_P <- t.test(mgCpergSoilP ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_P)

# Conduct a t-test for mgCpergSoilM
t_test_M <- t.test(mgCpergSoilM ~ Tillage_Grouped, data = data_filtered)

# Print the results
print(t_test_M)

# Calculate mean and standard error for each group in Tilled_Grouped
summary_stats <- data %>%
  group_by(Tilled_Grouped) %>%
  summarize(
    mean_value = mean(your_column, na.rm = TRUE),  # Replace 'your_column' with the name of the column you want the mean and SE for
    se_value = sd(your_column, na.rm = TRUE) / sqrt(n())  # Standard error calculation
  )

# View the summary statistics
print(summary_stats)


# percent greater POC in notill
mean_P_notill <- 12.5 
mean_p_till <- 7.58

# Calculate the percent increase in POC based on the mean value
percent_increase_poc_till <- (mean_P_notill-mean_p_till) / mean_p_till

percent_increase_poc_till

# percent greater MAOC in notill
mean_M_notill <- 18.9 
mean_m_till <- 16.1

# Calculate the percent increase in POC based on the mean value
percent_increase_maoc_till <- (mean_M_notill-mean_m_till) / mean_m_till

percent_increase_maoc_till

# Means, standard errors, and sample sizes
means <- c(15.9, 15.1, 17.7)
ses <- c(1.08, 1.66, 2.02)
sample_sizes <- c(39, 17, 13)

# Calculate the weighted mean for the non-no-till categories
weighted_mean_non_notill <- sum(means * sample_sizes) / sum(sample_sizes)
weighted_mean_non_notill
combined_se_non_notill <- sqrt(sum((ses^2) * sample_sizes) / sum(sample_sizes))
combined_se_non_notill

# No-till values
mean_notill <- 18.9
se_notill <- 1.20
n_notill <- 34

# Combined non-no-till values
mean_till <- weighted_mean_non_notill
se_till <- combined_se_non_notill
n_till <- sum(sample_sizes)

# Calculate the pooled standard error
pooled_se <- sqrt((se_notill^2 / n_notill) + (se_till^2 / n_till))

# Calculate the t statistic
t_stat <- (mean_notill - mean_till) / pooled_se
t_stat

# Degrees of freedom (approximation for unequal variances)
df <- (se_notill^2 / n_notill + se_till^2 / n_till)^2 / 
  (((se_notill^2 / n_notill)^2 / (n_notill - 1)) + ((se_till^2 / n_till)^2 / (n_till - 1)))

# Calculate the p-value
p_value <- 2 * pt(-abs(t_stat), df)
p_value



# If ANOVA is significant, perform Tukey's HSD test
if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
  tukey_result <- TukeyHSD(anova_result)
  print(tukey_result)
  plot(tukey_result)
} else {
  print("No significant difference between tillage groups.")
}

#compare the means
# Calculate means of mgCpergSoilP for each Tillage Group
means <- data %>%
  group_by(Tillage_Grouped) %>%
  summarise(Mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE))

print(means)

# Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_Grouped, data = data)
summary(anova_result)

# If ANOVA is significant, perform Tukey's HSD test
if (summary(anova_result)[[1]]$`Pr(>F)`[1] < 0.05) {
  tukey_result <- TukeyHSD(anova_result)
  print(tukey_result)
  plot(tukey_result)
} else {
  print("No significant difference between tillage groups.")
}

#compare the means
# Calculate means of mgCpergSoilM for each Tillage Group
means <- data %>%
  group_by(Tillage_Grouped) %>%
  summarise(Mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE))

print(means)

# Create box plot with means
ggplot(data, aes(x = Tillage_Grouped, y = mgCpergSoilM)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage Grouped", y = "MAOM") +
  ggtitle("Relationship between Tillage and MAOM") +
  theme_minimal()

#Aggregrate stabiity by field type

#Perform ANOVA
anova_result <- aov(aggregate_stability ~ Type.x, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)


#Perform ANOVA
anova_result <- aov(aggregate_stability ~ Tillage_Grouped, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)


# Create box plot with means
ggplot(data, aes(x = Tillage_1to4, y = aggregate_stability)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "Aggregate Stability") +
  ggtitle("Relationship between Tillage and Aggregate Stability") +
  theme_minimal()

# Create scatter plot with regression line and slope
ggplot(data, aes(x = Tillage_Grouped, y = aggregate_stability)) +
  geom_point(alpha = 0.7) +  # Scatter plot of the data points
  geom_smooth(method = "lm", se = TRUE, color = "blue") +  # Add regression line with confidence interval
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Mark means in red
  labs(x = "Tillage", y = "Aggregate Stability") +
  ggtitle("Regression of Tillage vs. Aggregate Stability") +
  theme_minimal() +
  annotate("text", x = Inf, y = Inf, hjust = 1.1, vjust = 1.5, size = 4,
           label = paste("Slope:", round(coef(lm(aggregate_stability ~ Tillage_1to4, data = data))[2], 2)))



#Create the new dataframe 'data_clean' with the necessary filters and grouping
data_clean <- data %>%
  # Remove NAs in Tillage_Grouped, AP, and aggregate_stability
  filter(!is.na(Tillage_Grouped), !is.na(AP), !is.na(aggregate_stability)) %>%
  
  # Create the new column 'AP' based on Type.x
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "perennial",
    Type.x %in% c("Corn", "Veg") ~ "annual",
    TRUE ~ NA_character_  # Handles any unspecified values
  )) %>%
  
  # Reclassify Tillage_Grouped variable as "No-Till" and "Till"
  mutate(Tillage_Grouped = factor(ifelse(Tillage_Grouped == 1, "No-Till", "Till")))

#Supplement Figure
ggplot(data, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Tillage", y = "Aggregate Stability", fill = NULL) +  # Remove legend title
  guides(fill = "none") +  # Remove the legend
  theme_minimal()
# Conduct a two-sample t-test
t_test_result <- t.test(aggregate_stability ~ Tillage_Grouped, data = data_clean)

# Extract the mean difference and p-value
mean_diff <- t_test_result$estimate[1] - t_test_result$estimate[2]
p_value <- t_test_result$p.value

print(mean_diff)
print(p_value)
# Calculate the mean for the No-Till group
mean_no_till <- mean(data_clean$aggregate_stability[data_clean$Tillage_Grouped == "No-Till"], na.rm = TRUE)
# Calculate the mean for the No-Till group
mean_till <- mean(data_clean$aggregate_stability[data_clean$Tillage_Grouped == "Till"], na.rm = TRUE)

# Print the mean
mean_till
# Print the mean
mean_no_till
mean_no_till <- 68.01775  # Mean in No-Till group
mean_till <- 38.63691         # Example mean in Till group, replace with your value

percent_increase <- ((mean_no_till - mean_till) / mean_till) * 100
percent_increase

# Calculate the mean for the Annual and Pere
mean_pere<- mean(data_clean$aggregate_stability[data_clean$AP == "perennial"], na.rm = TRUE)
mean_annual <- mean(data_clean$aggregate_stability[data_clean$AP == "annual"], na.rm = TRUE)
print(mean_pere)
mean_annual
mean_pere <-  66.52411 # Replace
mean_annual <-   36.32961      # Replace

percent_increase <- ((mean_pere - mean_annual) / mean_annual) * 100
percent_increase

# Conduct a two-sample t-test
t_test_result <- t.test(aggregate_stability ~ AP, data = data_clean)

# Extract the mean difference and p-value
mean_diff <- t_test_result$estimate[1] - t_test_result$estimate[2]
p_value <- t_test_result$p.value
p_value

# Determine the y-axis limits from the data
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Remove rows where aggregate_stability is NA (but keep all Tillage_Grouped values)
data_clean <- data_clean[!is.na(data_clean$aggregate_stability), ]

# Rename Tillage_Grouped categories: 1 = "No-Till", 2, 3, 4 = "Till"
data_clean$Tillage_Grouped <- factor(data_clean$Tillage_Grouped, 
                                     levels = c(1, 2, 3, 4), 
                                     labels = c("No-Till", "Till", "Till", "Till"))

# Check that the factor levels are correctly assigned
table(data_clean$Tillage_Grouped)

# Plot for Tillage_Grouped
plot_AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Tillage Type", y = "Aggregate Stability", fill = NULL) +  # Set labels for axes
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

# Print the plot
print(plot_AgTill)



# Plot for AP (Perennial vs Annual)
# Ensure that the levels for AP are in the correct order: "Perennial", "Annual"
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = NULL, y = NULL) +  # Remove y-axis label for this plot
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Set specific colors for the bars
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Ensure correct order of x-axis labels
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

# Combine the two plots side by side with shared y-axis
combined_plot <- ggarrange(plot_AgTill, plot_AgAP,
                           labels = c("a", "b"),  # Add labels A and B
                           ncol = 2, nrow = 1,
                           align = "hv")  # Align both horizontally and vertically

# Print the combined plot
print(combined_plot)

# Optional: Perform a t-test to compare means of aggregate stability between the two groups
t_test_result <- t.test(aggregate_stability ~ Tillage_Grouped, data = data_clean)
print(t_test_result)
# Optionally, plot the Tukey HSD results
plot(tukey_result)

# Create box plot with means
ggplot(data, aes(x = Type.x, y = aggregate_stability)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Field Type", y = "Aggregate Stability") +
  ggtitle("Relationship between Field Type and Aggregate Stability") +
  theme_minimal()

#Active Carbon by field type

#Perform ANOVA
anova_result <- aov(active_carbon ~ Type.x, data = data)
summary(anova_result)

#Perform Tukey's HSD test if ANOVA is significant
tukey_result <- TukeyHSD(anova_result)
print(tukey_result)

# Optionally, plot the Tukey HSD results
plot(tukey_result)

# Create box plot with means
ggplot(data, aes(x = Type.x, y = active_carbon)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Field Type", y = "Active Carbon") +
  ggtitle("Relationship between Field Type and Active Carbon") +
  theme_minimal()


# Create box plot with means
ggplot(data, aes(x = Type.x, y = mgCpergSoilP)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Crop Type", y = "mg C POM") +
   theme_minimal()


ggplot(data) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
  geom_jitter(aes(x = Type.x, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
  geom_jitter(aes(x = Type.x, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
  stat_summary(aes(x = Type.x, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  stat_summary(aes(x = Type.x, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
  labs(x = "Crop Type", y = "mg POC(blue) and MAOC (green) g"^-1~"soil") +
  theme_minimal()

library(dplyr)
library(ggplot2)

# Filter out wheat data
filtered_data <- data %>%
  filter(Type.x != "Wheat")

# Create the plot with the filtered data
ggplot(filtered_data) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_boxplot(aes(x = Type.x, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
  geom_jitter(aes(x = Type.x, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
  geom_jitter(aes(x = Type.x, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
  stat_summary(aes(x = Type.x, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  stat_summary(aes(x = Type.x, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
  labs(x = "Crop Type", y = "mg POC(blue) and MAOC (green) g"^-1~"soil" +
  theme_minimal()

  # Filter out wheat data
  filtered_data <- data %>%
    filter(Type.x != "Wheat")  # Adjust to match the exact value in your dataset
  
  # Create the plot with the filtered data
  ggplot(filtered_data) +
    geom_boxplot(aes(x = Type.x, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
    geom_boxplot(aes(x = Type.x, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
    geom_jitter(aes(x = Type.x, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
    geom_jitter(aes(x = Type.x, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
    stat_summary(aes(x = Type.x, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
    stat_summary(aes(x = Type.x, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
    labs(x = "Crop Type", y = expression("mg POC (blue) and MAOC (green) g"^{-1}~"soil")) +  # Fixed y-axis label
    theme_minimal()
  
  # Create the plot with the filtered data
  ggplot(filtered_data) +
    geom_boxplot(aes(x = AP, y = mgCpergSoilP), outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
    geom_boxplot(aes(x = AP, y = mgCpergSoilM), outlier.shape = NA, fill = "lightgreen", alpha = 0.5) +  # Second box plot for mgCpergSoilM
    geom_jitter(aes(x = AP, y = mgCpergSoilP), width = 0.3, height = 0, alpha = 0.7) +
    geom_jitter(aes(x = AP, y = mgCpergSoilM), width = 0.3, height = 0, color = "darkgreen", alpha = 0.7) +  # Jitter for mgCpergSoilM
    stat_summary(aes(x = AP, y = mgCpergSoilP), fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
    stat_summary(aes(x = AP, y = mgCpergSoilM), fun = "mean", geom = "point", shape = 20, size = 3, color = "blue") +  # Mean for mgCpergSoilM
    labs(x = "Crop Type", y = expression("mg POC (blue) and MAOC (green) g"^{-1}~"soil")) +  # Fixed y-axis label
    theme_minimal()

#POM and MAOM
# Perform linear regression
regression_model <- lm(mgCpergSoilM ~ mgCpergSoilP, data = data)

# Summarize the regression model
summary(regression_model)

# Create a plot with the regression line
ggplot(data, aes(x = mgCpergSoilP, y = mgCpergSoilM)) +
  geom_point() +
  geom_smooth(method = "lm", col = "blue") +
  labs(title = "Linear Regression of MAOM on POM",
       x = "POM",
       y = "MAOM") +
  theme_minimal()

#compost
# Count occurrences of "compost" in the column
count_compost <- sum(grepl("compost", data$Soil.amendments, ignore.case = TRUE))

# Output the count
count_compost

#tillage and active carbon


regression_model <- lm(active_carbon ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)

library(ggplot2)
library(dplyr)

# Assuming regression_model is already created

# Create a data frame with predictions for plotting
data_with_predictions <- data %>%
  mutate(predicted = predict(regression_model, newdata = data)) %>%
  group_by(Tillage_1to4) %>%
  summarize(mean_predicted = mean(predicted), 
            mean_active_carbon = mean(active_carbon), 
            .groups = 'drop')

# Plot the data
ggplot(data, aes(x = Tillage_1to4, y = active_carbon)) +
  geom_jitter(width = 0.2, size = 2, alpha = 0.5) +  # Scatter plot with jitter to avoid overplotting
  geom_point(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted), color = "red", size = 3, shape = 1) +  # Predicted values
  geom_line(data = data_with_predictions, aes(x = Tillage_1to4, y = mean_predicted, group = 1), color = "blue", size = 1) +  # Regression line
  labs(title = "Regression of Active Carbon on Tillage Category",
       x = "Tillage Category",
       y = "Active Carbon",
       color = "Legend") +
  scale_x_discrete(labels = c("1" = "No Till", "2" = "1-7inch Till", "3" = "7-9inch Till", "4" = ">9inch Till")) +  # Customize x-axis labels
  theme_minimal()

#tillage and POC


regression_model <- lm(mgCpergSoilP ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)


library(ggplot2)

# Plot with regression line
ggplot(data, aes(x = as.factor(Tillage_1to4), y = mgCpergSoilP)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +  # Scatter plot with jitter
  geom_smooth(method = "lm", se = FALSE, color = "blue", size = 1) +  # Linear regression line
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Mean points
  labs(x = "Tillage", y = "mgCpergSoilP") +
  ggtitle("Relationship between Tillage and mgCpergSoilP") +
  theme_minimal()

# Plot with regression line
ggplot(data, aes(x = as.factor(Tillage_Grouped), y = mgCpergSoilP)) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +  # Scatter plot with jitter
  geom_smooth(method = "lm", se = FALSE, color = "blue", size = 1) +  # Linear regression line
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Mean points
  labs(x = "Tillage", y = "mgCpergSoilP") +
  ggtitle("Relationship between Tillage and mgCpergSoilP") +
  theme_minimal()


# Example scatter plot with jitter
library(ggplot2)

ggplot(data, aes(x = as.factor(Tillage_1to4), y = active_carbon)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "PoxC") +
  ggtitle("Relationship between Tillage and PoxC") +
  theme_minimal()

summary(Tillage_1to4)

#tillage and agg stability
# Assuming 'data' is your dataframe
count_by_tillage <- data %>%
  group_by(Tillage_1to4) %>%
  count(Type.x)

# Print the result
print(count_by_tillage)

regression_model <- lm(agg_stability ~ Tillage_1to4, data = data)

#Summarize the regression model
summary(regression_model)

# Example scatter plot with jitter
library(ggplot2)

ggplot(data, aes(x = as.factor(Tillage_1to4), y = active_carbon)) +
  geom_boxplot(outlier.shape = NA, fill = "lightblue", alpha = 0.5) +
  geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +
  labs(x = "Tillage", y = "PoxC") +
  ggtitle("Relationship between Tillage and PoxC") +
  theme_minimal()

# Calculate means and standard errors of mgCpergSoilP for each Tillage Category
means_and_se <- data %>%
  group_by(Tillage_1to4) %>%
  summarise(
    Mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    Std_Error = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n())  # Standard Error
  )

print(means_and_se)
# Calculate means and standard errors of mgCpergSoilM for each Tillage Category
means_and_se <- data %>%
  group_by(Tillage_1to4) %>%
  summarise(
    Mean_mgCpergSoilM = mean(mgCpergSoilM, na.rm = TRUE),
    Std_Error = sd(mgCpergSoilM, na.rm = TRUE) / sqrt(n())  # Standard Error
  )

print(means_and_se)


# Calculate means, standard errors, and sample sizes of mgCpergSoilP for each Tillage Category
means_and_stats <- data %>%
  group_by(Tillage_1to4) %>%
  summarise(
    Mean_mgCpergSoilP = mean(mgCpergSoilP, na.rm = TRUE),
    Std_Error = sd(mgCpergSoilP, na.rm = TRUE) / sqrt(n()),  # Standard Error
    n = n()  # Sample size
  )

print(means_and_stats)

# Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_1to4, data = data)

# Summarize the ANOVA result
summary(anova_result)

# Convert Tillage_1to4 to a factor
data$Tillage_1to4 <- as.factor(data$Tillage_1to4)

# Perform ANOVA
anova_result <- aov(mgCpergSoilP ~ Tillage_1to4, data = data)

# Summarize the ANOVA result
summary(anova_result)

# Apply Tukey's HSD test
tukey_result <- TukeyHSD(anova_result)

# Print the Tukey HSD result
print(tukey_result)

# Optionally, convert Tukey result to a data frame for better readability
tukey_df <- as.data.frame(tukey_result$`Tillage_1to4`)
print(tukey_df)


# Convert Tillage_1to4 to a factor
data$Tillage_1to4 <- as.factor(data$Tillage_1to4)

# Perform ANOVA
anova_result <- aov(mgCpergSoilM ~ Tillage_1to4, data = data)

# Summarize the ANOVA result
summary(anova_result)

# Apply Tukey's HSD test
tukey_result <- TukeyHSD(anova_result)

# Print the Tukey HSD result
print(tukey_result)

# Optionally, convert Tukey result to a data frame for better readability
tukey_df <- as.data.frame(tukey_result$`Tillage_1to4`)
print(tukey_df)

view (data)
# Using base R with grepl
search_term <- "manure"
result <- data[grepl(search_term, data$column_name, ignore.case = TRUE), ]

# Using dplyr
library(dplyr)
result <- data %>%
  filter(grepl(search_term, column_name, ignore.case = TRUE))

# Print the result
print(result)


# Supplement Figure 2 Final
# Determine the y-axis limits from the data
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Plot for Tillage_Grouped
plot_AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "", y = "Aggregate Stability", fill = NULL) +  # Remove legend title
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

# Plot for AP (Perennial vs Annual)
# Ensure that the levels for AP are in the correct order: "Perennial", "Annual"
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

plot_AgAP <- ggplot(data, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(width = 0.2, alpha = 0.7) +
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = NULL, y = NULL) +  # Remove y-axis label for this plot
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Set specific colors for the bars
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Ensure correct order of x-axis labels
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +
  ylim(y_limits)  # Set the same y-limits

plot_AgAP


# Remove rows where AP is NA (to exclude "NA" category)
data_clean <- data[!is.na(data$AP), ]

# Ensure 'AP' is a factor and levels are set correctly
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

# Determine the y-axis limits from the data (if needed)
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Plot for AP on x-axis and Aggregate Stability on y-axis
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot with no outliers
  geom_jitter(width = 0.2, alpha = 0.7) +  # Add jittered points for better visibility
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Crop Type", y = "Aggregate Stability") +  # Label x and y axes
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Color for Perennial and Annual
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Set labels for x-axis
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +  # Use minimal theme for better aesthetics
  ylim(y_limits)  # Set the same y-limits

# Display the plot
plot_AgAP






# Combine the two plots side by side with shared y-axis
combined_plot <- ggarrange(plot_AgTill, plot_AgAP,
                           labels = c("a", "b"),  # Add labels A and B
                           ncol = 2, nrow = 1,
                           align = "hv")  # Align both horizontally and vertically

# Print the combined plot
print(combined_plot)




#############################NewCode Updated Final Supplement Figure2#########

# Remove rows where Tillage_Grouped is NA
data_clean <- data[!is.na(data$Tillage_Grouped), ]

# Convert Tillage_Grouped to a factor and rename the levels
data_clean$Tillage_Grouped <- factor(data_clean$Tillage_Grouped,
                                     levels = c(1, 2, 3, 4), 
                                     labels = c("No-Till", "Till", "Till", "Till"))

# Create the plot
AgTill<-ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot with no outliers
  geom_jitter(width = 0.2, alpha = 0.7) +  # Add jittered points
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "", y = "Aggregate Stability", fill = NULL) +  # Axis labels and remove legend title
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +  # Use a minimal theme
  scale_x_discrete(labels = c("No-Till", "Till"))  # Rename x-axis labels


# Remove rows where AP is NA (to exclude "NA" category)
data_clean <- data[!is.na(data$AP), ]

# Ensure 'AP' is a factor and levels are set correctly
data_clean$AP <- factor(data_clean$AP, levels = c("Perennial", "Annual"))

# Determine the y-axis limits from the data (if needed)
y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# Plot for AP on x-axis and Aggregate Stability on y-axis
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +  # Boxplot with no outliers
  geom_jitter(width = 0.2, alpha = 0.7) +  # Add jittered points for better visibility
  stat_summary(fun = "mean", geom = "point", shape = 20, size = 3, color = "red") +  # Show mean in red
  labs(x = "Crop Type", y = "Aggregate Stability") +  # Label x and y axes
  scale_fill_manual(values = c("Perennial" = "blue", "Annual" = "orange")) +  # Color for Perennial and Annual
  scale_x_discrete(labels = c("Perennial", "Annual")) +  # Set labels for x-axis
  guides(fill = "none") +  # Remove the legend
  theme_minimal() +  # Use minimal theme for better aesthetics
  ylim(y_limits)  # Set the same y-limits

# Display the plot
plot_AgAP


############################# NewCode Updated Final Supplement Figure2 #########

# RECREATE the AP column based on Type.x
# (because your AP column is broken / inconsistent across all versions)
data_clean <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "Perennial",
    Type.x %in% c("Veg", "Corn", "Field Crop") ~ "Annual",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(Tillage_Grouped), !is.na(AP))  # Remove NAs in Tillage_Grouped and AP

# Make factors with correct capitalization
data_clean <- data_clean %>%
  mutate(
    Tillage_Grouped = factor(Tillage_Grouped, levels = c(1, 2, 3, 4),
                             labels = c("No-Till", "Till", "Till", "Till")),
    AP = factor(AP, levels = c("Perennial", "Annual"))  # Correct levels
  )

# --- Step 2: Set color schemes ---

fill_colors_Till <- c("No-Till" = "pink", "Till" = "darkgrey")
fill_colors_AP <- c("Perennial" = "pink", "Annual" = "darkgrey")

# --- Step 3: Set y-axis limits ---

y_limits <- range(data_clean$aggregate_stability, na.rm = TRUE)

# --- Step 4: Create the plots ---

# Plot 1: Tillage_Grouped
AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = aggregate_stability, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +  # BLACK points
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +  # Red means
  scale_fill_manual(values = fill_colors_Till) +
  scale_x_discrete(labels = c("No-Till", "Till")) +
  labs(x = "", y = "Aggregate Stability", fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black")
  ) +
  ylim(y_limits)

# Plot 2: AP (Perennial vs Annual)
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = aggregate_stability, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +  # BLACK points
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +  # Red means
  scale_fill_manual(values = fill_colors_AP) +
  scale_x_discrete(labels = c("Perennial", "Annual")) +
  labs(x = "", y = NULL, fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  ylim(y_limits)

# --- Step 5: Arrange and save plots ---

SF2 <- grid.arrange(AgTill, plot_AgAP,
                    ncol = 2, nrow = 1,
                    widths = c(1, 1),
                    heights = c(1))
SF2

# Save the plot
ggsave("SF2.jpeg", plot = SF2, width = 10, height = 6, dpi = 300)


###########NEW 4.26.25 percent CLAY 
# --- Step 1: Clean and set up your data ---

# RECREATE the AP column based on Type.x
data_clean <- data %>%
  mutate(AP = case_when(
    Type.x %in% c("Hay", "Pasture") ~ "Perennial",
    Type.x %in% c("Veg", "Corn", "Field Crop") ~ "Annual",
    TRUE ~ NA_character_
  )) %>%
  filter(!is.na(Tillage_Grouped), !is.na(AP))  # Remove NAs

# Make factors
data_clean <- data_clean %>%
  mutate(
    Tillage_Grouped = factor(Tillage_Grouped, levels = c(1, 2, 3, 4),
                             labels = c("No-Till", "Till", "Till", "Till")),
    AP = factor(AP, levels = c("Perennial", "Annual"))
  )

# --- Step 2: Set color schemes ---

fill_colors_Till <- c("No-Till" = "pink", "Till" = "darkgrey")
fill_colors_AP <- c("Perennial" = "pink", "Annual" = "darkgrey")

# --- Step 3: Set y-axis limits for soil_texture_clay ---

y_limits <- range(data_clean$soil_texture_clay, na.rm = TRUE)

# --- Step 4: Create the plots ---

# Plot 1: Tillage_Grouped
AgTill <- ggplot(data_clean, aes(x = Tillage_Grouped, y = soil_texture_clay, fill = Tillage_Grouped)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +
  scale_fill_manual(values = fill_colors_Till) +
  scale_x_discrete(labels = c("No-Till", "Till")) +
  labs(x = "", y = "Soil Texture Clay (%)", fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black")
  ) +
  ylim(y_limits)

# Plot 2: AP (Perennial vs Annual)
plot_AgAP <- ggplot(data_clean, aes(x = AP, y = soil_texture_clay, fill = AP)) +
  geom_boxplot(outlier.shape = NA, alpha = 0.5) +
  geom_jitter(color = "black", width = 0.2, alpha = 0.7) +
  stat_summary(fun = mean, geom = "point", shape = 20, size = 3, color = "red") +
  scale_fill_manual(values = fill_colors_AP) +
  scale_x_discrete(labels = c("Perennial", "Annual")) +
  labs(x = "", y = NULL, fill = NULL) +
  guides(fill = "none") +
  theme_minimal() +
  theme(
    axis.line = element_line(color = "black", size = 0.5),
    axis.ticks = element_line(color = "black", size = 0.5),
    axis.text = element_text(size = 14, color = "black"),
    axis.title = element_text(size = 16, color = "black"),
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank()
  ) +
  ylim(y_limits)

# --- Step 5: Arrange the two plots ---

SF3 <- grid.arrange(
  AgTill, plot_AgAP,
  ncol = 2,
  widths = c(1, 1),
  heights = c(1),
  top = ""  # optional title space
)
SF3
# Save the plot
ggsave("SF3_soil_texture_clay.jpeg", plot = SF3, width = 10, height = 6, dpi = 300)


#revisions looking at the relationship between crop type and climate:
view(data)
library(ggplot2)

# Temperature by Type
ggplot(data, aes(x = Type.x, y = tmeanC, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Mean Temperature (°C)") +
  theme_minimal()

# Precipitation by Type
ggplot(data, aes(x = Type.x, y = ppt.cm, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Precipitation (cm)") +
  theme_minimal()

# For temperature
anova_temp <- aov(tmeanC ~ Type.x, data = data)
summary(anova_temp)

# For precipitation
anova_ppt <- aov(ppt.cm ~ Type.x, data = data)
summary(anova_ppt)

TukeyHSD(anova_ppt)
TukeyHSD(anova_temp)

version
pkgbuild::find_rtools()
###Spatial Analysis 

install.packages("sf", type = "binary")
install.packages("sp")
install.packages("gstat")
# Install (only need to do once)
install.packages("sf", type = "binary")
install.packages("sp")
install.packages("gstat")

# Load libraries
library(sf)       # for spatial data handling
library(sp)       # for compatibility with gstat
library(gstat)    # for semivariogram analysis

# ---- Convert your data to spatial format ----
# Make sure your dataframe has: Latitude, Longitude, mgCpergSoilP, mgCpergSoilM
# Example structure: data <- data.frame(Longitude = ..., Latitude = ..., mgCpergSoilP = ..., mgCpergSoilM = ...)

# Convert to sf object (WGS84 coordinate system, EPSG:4326)
data_sf <- st_as_sf(data, coords = c("Longitude", "Latitude"), crs = 4326)

# Convert sf to sp (gstat requires sp objects)
data_sp <- as(data_sf, "Spatial")

# ---- Semivariogram for mgCpergSoilP ----
vgm_p <- variogram(mgCpergSoilP ~ 1, data_sp)   # empirical semivariogram
plot(vgm_p, main = "Semivariogram of mgCpergSoilP")

# ---- Semivariogram for mgCpergSoilM ----
vgm_m <- variogram(mgCpergSoilM ~ 1, data_sp)
plot(vgm_m, main = "Semivariogram of mgCpergSoilM")

# ---- (Optional) Fit models to the semivariograms ----
fit_p <- fit.variogram(vgm_p, model = vgm("Sph"))
fit_m <- fit.variogram(vgm_m, model = vgm("Sph"))

plot(vgm_p, model = fit_p, main = "Fitted Semivariogram - mgCpergSoilP")
plot(vgm_m, model = fit_m, main = "Fitted Semivariogram - mgCpergSoilM")


##############CREATE TABLE fore revisons#############

# Temperature by Type
ggplot(data, aes(x = Type.x, y = tmeanC, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Mean Temperature (°C)") +
  theme_minimal()

# Precipitation by Type
ggplot(data, aes(x = Type.x, y = ppt.cm, fill = Type.x)) +
  geom_boxplot() +
  labs(x = "Type", y = "Precipitation (cm)") +
  theme_minimal()

# For temperature
anova_temp <- aov(tmeanC ~ Type.x, data = data)
summary(anova_temp)

# For precipitation
anova_ppt <- aov(ppt.cm ~ Type.x, data = data)
summary(anova_ppt)

TukeyHSD(anova_ppt)
TukeyHSD(anova_temp)

####Table to respond to revisions################

# Load libraries

library(dplyr)
library(emmeans)
library(multcompView)
responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

results_list <- list()

for (var in responses) {
  
  # Fit ANOVA
  model <- aov(as.formula(paste(var, "~ Type.x")), data = data)
  
  # Mean and range per crop type
  summary_stats <- data %>%
    group_by(Type.x) %>%
    summarise(
      mean = mean(.data[[var]], na.rm = TRUE),
      range = paste0(range(.data[[var]], na.rm = TRUE), collapse = "–"),
      .groups = "drop"
    )
  
  # Tukey HSD
  tukey <- TukeyHSD(model)
  
  # Get significance letters
  tukey_letters <- multcompView::multcompLetters(tukey$Type.x[, "p adj"])
  groups_df <- data.frame(
    Type.x = names(tukey_letters$Letters),
    .group = tukey_letters$Letters
  )
  
  # Merge
  result <- summary_stats %>%
    left_join(groups_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- result
}

# Combine all
final_results <- bind_rows(results_list)
print(final_results)

library(dplyr)
library(tidyr)
library(knitr)

# Combine mean + range + significance
final_results_clean <- final_results %>%
  mutate(
    mean = round(mean, 2),
    range = sapply(strsplit(range, "–"), function(x) {
      paste(round(as.numeric(x), 2), collapse = "–")
    }),
    mean_range_sig = paste0(mean, " (", range, ", ", .group, ")")
  )

# Pivot: one row per variable, one column per crop type
final_wide <- final_results_clean %>%
  select(response, `Crop Type` = Type.x, mean_range_sig) %>%
  pivot_wider(
    names_from = `Crop Type`,
    values_from = mean_range_sig
  ) %>%
  arrange(response) %>%
  rename(Variable = response)

# Display nicely
final_wide %>%
  kable(caption = "Mean, range, and significance letters by crop type for each variable")


library(dplyr)
library(tidyr)
library(openxlsx)
# Step 1: Prepare data
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    mean_sig = paste0(mean_rounded, " (", .group, ")")
  )

# Step 2: Compute overall range per variable
ranges <- final_results_clean %>%
  group_by(response) %>%
  summarise(Full_Range = paste0(round(min(mean), 2), "–", round(max(mean), 2)), .groups = "drop")

# Step 3: Pivot to wide format: rows = Crop Type, columns = Variable
final_wide <- final_results_clean %>%
  select(Crop = Type.x, Variable = response, mean_sig) %>%
  pivot_wider(names_from = Variable, values_from = mean_sig)

# Step 4: Create a proper data frame for the range row
range_row <- data.frame(Crop = "Full Range", t(ranges$Full_Range))
names(range_row)[-1] <- ranges$response

# Step 5: Bind the range row on top of the crop rows
final_wide <- bind_rows(range_row, final_wide)

# Now you can continue with writing to Excel and coloring


# Step 4: Create workbook and write data
wb <- createWorkbook()
addWorksheet(wb, "Summary")

writeData(wb, "Summary", final_wide, startCol = 1, startRow = 1)

# Step 5: Define colors for letters
letters_colors <- c(
  "a" = "#D6EAF8",  # light blue
  "b" = "#F9E79F",  # light yellow
  "c" = "#F5B7B1",  # light red
  "ab" = "#D5F5E3", # light green
  "ac" = "#FADBD8", # light pink
  "bc" = "#FCF3CF"  # light cream
)

# Step 6: Apply coloring based on letters in each cell
for(col in 2:ncol(final_wide)) {  # skip first column (Crop)
  for(row in 2:nrow(final_wide)) {  # skip first row (range row)
    cell_val <- final_wide[row, col] %>% as.character()
    if(!is.na(cell_val) && grepl("\\(", cell_val)) {
      # Extract letters from cell
      letter <- sub(".*\\((.*)\\)", "\\1", cell_val)
      # If multiple letters, choose first for color (optional)
      first_letter <- strsplit(letter, "")[[1]][1]
      color <- letters_colors[first_letter]
      if(!is.na(color)) {
        addStyle(wb, "Summary",
                 style = createStyle(fgFill = color),
                 rows = row+1, cols = col, gridExpand = TRUE)
      }
    }
  }
}

# Step 7: Save workbook
saveWorkbook(wb, "CropType_as_Rows_Colored.xlsx", overwrite = TRUE)

###revised code
# Load libraries
library(dplyr)
library(emmeans)
library(multcompView)
library(tidyr)
library(openxlsx)
library(knitr)

responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

results_list <- list()

for (var in responses) {
  
  # Fit ANOVA
  model <- aov(as.formula(paste(var, "~ Type.x")), data = data)
  
  # Mean, range, SEM per crop type
  summary_stats <- data %>%
    group_by(Type.x) %>%
    summarise(
      mean = mean(.data[[var]], na.rm = TRUE),
      sem  = sd(.data[[var]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[var]]))),
      range = paste0(range(.data[[var]], na.rm = TRUE), collapse = "–"),
      .groups = "drop"
    )
  
  # Tukey HSD
  tukey <- TukeyHSD(model)
  
  # Get significance letters
  tukey_letters <- multcompView::multcompLetters(tukey$Type.x[, "p adj"])
  groups_df <- data.frame(
    Type.x = names(tukey_letters$Letters),
    .group = tukey_letters$Letters
  )
  
  # Merge
  result <- summary_stats %>%
    left_join(groups_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- result
}

# Combine all
final_results <- bind_rows(results_list)

# Clean + prepare display
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    sem_rounded  = round(sem, 2),
    # Include SEM + significance in parentheses
    mean_sem_sig = paste0(mean_rounded, " ±", sem_rounded, " (", .group, ")")
  )

# Compute overall range per variable
ranges <- final_results_clean %>%
  group_by(response) %>%
  summarise(Full_Range = paste0(round(min(mean), 2), "–", round(max(mean), 2)), 
            .groups = "drop")

# Pivot to wide format
final_wide <- final_results_clean %>%
  select(Crop = Type.x, Variable = response, mean_sem_sig) %>%
  pivot_wider(names_from = Variable, values_from = mean_sem_sig)

# Add range row
range_row <- data.frame(Crop = "Full Range", t(ranges$Full_Range))
names(range_row)[-1] <- ranges$response
final_wide <- bind_rows(range_row, final_wide)

# Write to Excel
wb <- createWorkbook()
addWorksheet(wb, "Summary")
writeData(wb, "Summary", final_wide, startCol = 1, startRow = 1)

# Colors for significance letters
letters_colors <- c(
  "a" = "#D6EAF8",
  "b" = "#F9E79F",
  "c" = "#F5B7B1",
  "ab" = "#D5F5E3",
  "ac" = "#FADBD8",
  "bc" = "#FCF3CF"
)

# Apply coloring
for(col in 2:ncol(final_wide)) {  # skip Crop column
  for(row in 2:nrow(final_wide)) {  # skip range row
    cell_val <- as.character(final_wide[row, col])
    if(!is.na(cell_val) && grepl("\\(", cell_val)) {
      # Extract significance letters
      letter <- sub(".*\\((.*)\\)", "\\1", cell_val)
      first_letter <- strsplit(letter, "")[[1]][1]
      color <- letters_colors[first_letter]
      if(!is.na(color)) {
        addStyle(wb, "Summary",
                 style = createStyle(fgFill = color),
                 rows = row+1, cols = col, gridExpand = TRUE)
      }
    }
  }
}

saveWorkbook(wb, "CropType_as_Rows_Colored_SEM.xlsx", overwrite = TRUE)

###########Adjusted Script #############
responses <- c("tmeanC", "ppt.cm", "aggregate_stability", 
               "active_carbon", "ph", "overall.score", "soil_texture_clay")

results_list <- list()

# Filter data once at the start to exclude Field crop
data_filtered <- data %>% filter(Type.x != "Field crops")

for (var in responses) {
  
  # Fit ANOVA
  model <- aov(as.formula(paste(var, "~ Type.x")), data = data_filtered)
  
  # Mean, SEM, Range per crop type
  summary_stats <- data_filtered %>%
    group_by(Type.x) %>%
    summarise(
      mean  = mean(.data[[var]], na.rm = TRUE),
      sem   = sd(.data[[var]], na.rm = TRUE) / sqrt(sum(!is.na(.data[[var]]))),
      range = paste0(round(min(.data[[var]], na.rm = TRUE), 2), "–",
                     round(max(.data[[var]], na.rm = TRUE), 2)),
      .groups = "drop"
    )
  
  # Tukey HSD
  tukey <- TukeyHSD(model)
  
  # Get significance letters
  tukey_letters <- multcompView::multcompLetters(tukey$Type.x[, "p adj"])
  groups_df <- data.frame(
    Type.x = names(tukey_letters$Letters),
    .group = tukey_letters$Letters
  )
  
  # Merge
  result <- summary_stats %>%
    left_join(groups_df, by = "Type.x") %>%
    mutate(response = var)
  
  results_list[[var]] <- result
}

# Combine all
final_results <- bind_rows(results_list)

# Add cleaned formatting
final_results_clean <- final_results %>%
  mutate(
    mean_rounded = round(mean, 2),
    sem_rounded  = round(sem, 2),
    mean_sem_sig = paste0(mean_rounded, " ±", sem_rounded, " (", .group, ")"),
    mean_range   = paste0(mean_sem_sig, " | Range: ", range)
  )

# Pivot to wide format with range included
final_wide <- final_results_clean %>%
  select(Crop = Type.x, Variable = response, mean_range) %>%
  pivot_wider(names_from = Variable, values_from = mean_range)

# Write to Excel
wb <- createWorkbook()
addWorksheet(wb, "Summary")
writeData(wb, "Summary", final_wide, startCol = 1, startRow = 1)

# Colors for significance letters
letters_colors <- c(
  "a" = "#D6EAF8",
  "b" = "#F9E79F",
  "c" = "#F5B7B1",
  "ab" = "#D5F5E3",
  "ac" = "#FADBD8",
  "bc" = "#FCF3CF"


# Apply coloring based on first letter
for(col in 2:ncol(final_wide)) {  # skip Crop column
  for(row in 2:nrow(final_wide)) {
    cell_val <- as.character(final_wide[row, col])
    if(!is.na(cell_val) && grepl("\\(", cell_val)) {
      # Extract significance letters
      letter <- sub(".*\\((.*)\\).*", "\\1", cell_val)
      first_letter <- strsplit(letter, "")[[1]][1]
      color <- letters_colors[first_letter]
      if(!is.na(color)) {
        addStyle(wb, "Summary",
                 style = createStyle(fgFill = color),
                 rows = row+1, cols = col, gridExpand = TRUE)
      }
    }
  }
}

saveWorkbook(wb, "CropType_as_Rows_Colored_SEM_with_Range.xlsx", overwrite = TRUE)


#revisions model code to add variance structure ##

m3P=gls(mgCpergSoilP~ppt.cm*tmeanC
        +aggregate_stability+active_carbon+ph,
        data=data, na.action=na.exclude, method="REML") 

m3P_var <- gls(mgCpergSoilP ~ ppt.cm * tmeanC
               + aggregate_stability + active_carbon + ph + Type.x,
               data = data,
               na.action = na.exclude,
               method = "REML",
               weights = varIdent(form = ~ 1 | Type.x))

anova(m3P)
summary(m3P)
###MAOC
m4M_var <- gls(mgCpergSoilM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC + 
               aggregate_stability + active_carbon + ph,
               data = data,
               na.action = na.exclude,
               method = "REML",
               weights = varIdent(form = ~ 1 | Type.x))

anova(m4M_var)
summary(m4M_var)

summary(m3P_var)
###MAOC
m4M <- gls(mgCpergSoilM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC + 
                 aggregate_stability + active_carbon + ph,
               data = data,
               na.action = na.exclude,
               method = "REML")

anova(m4M)
summary(m4M)
# Load needed packages
install.packages("MuMIn")
install.packages("performance")
library(MuMIn)       # for r.squaredGLS
library(performance) # for r2() function, if you prefer

## --- R2 for GLS models ---
# Using MuMIn
r.squaredGLS(m3P)       # marginal pseudo-R²
r.squaredGLS(m3P_var)
r.squaredGLS(m4M_var)

# Or using performance package (often more flexible)
r2(m3P)
r2(m3P_var)
r2(m4M_var)

## --- Degrees of freedom ---
# Number of parameters (coefficients)
length(coef(m3P))
length(coef(m3P_var))
length(coef(m4M_var))

# Residual degrees of freedom = n - p
df_resid_m3P     <- m3P$dims$N - length(coef(m3P))
df_resid_m3P_var <- m3P_var$dims$N - length(coef(m3P_var))
df_resid_m4M_var <- m4M_var$dims$N - length(coef(m4M_var))


df_resid_m3P_var
df_resid_m4M_var

AIC(m3P, m3P_var)
