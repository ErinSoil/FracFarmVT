print("Fitted values:")
print(fitted_values)
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
print(paste("SS_res:", ss_res))
print(paste("SS_tot:", ss_tot))
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
rsquared_value <- rsquared_gls(m4M)
print(rsquared_value)
#Print unique values of the response variable
unique_values <- unique(data$logitpropM)
print("Unique values of the response variable (logitpropM):")
print(unique_values)
# Check the variance of the response variable
response_variance <- var(data$logitpropM, na.rm = TRUE)
print(paste("Variance of the response variable (logitpropM):", response_variance))
rsquared_value <- rsquared_gls(m4M)
print(rsquared_value)
# Load necessary package
library(nlme)
# Load your actual data
data <- read.csv("path/to/your/data.csv")
Load necessary package
# Load necessary package
library(nlme)
# Ensure all necessary variables are numeric
data$logitpropM <- as.numeric(data$logitpropM)
data$ppt.cm <- as.numeric(data$ppt.cm)
data$soil_texture_clay <- as.numeric(data$soil_texture_clay)
data$tmeanC <- as.numeric(data$tmeanC)
data$active_carbon <- as.numeric(data$active_carbon)
# Print out the types of the variables to ensure they are numeric
str(data)
# Check unique values of the response variable
unique_values <- unique(data$logitpropM)
print("Unique values of the response variable (logitpropM):")
print(unique_values)
# Check the variance of the response variable
response_variance <- var(data$logitpropM, na.rm = TRUE)
print(paste("Variance of the response variable (logitpropM):", response_variance))
# Fit your GLS model
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data,
na.action = na.exclude,
method = "ML")
# Define the rsquared_gls function
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable
response_variable <- as.character(formula(model)[[2]])
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
print("Initial response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Check for NA values in response
if (any(is.na(response_values))) {
warning("NA values found in response variable, removing them")
response_values <- na.omit(response_values)
fitted_values <- fitted_values[!is.na(fitted_values)]
}
# Debugging: Print cleaned response values and fitted values
print("Cleaned response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
print(paste("SS_res:", ss_res))
print(paste("SS_tot:", ss_tot))
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared
rsquared_value <- rsquared_gls(m4M)
#R squared Code
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the model's data
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
print("Initial response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Handle NA values: remove corresponding elements from both response_values and fitted_values
na_indices <- is.na(response_values)
if (any(na_indices)) {
warning("NA values found in response variable, removing them")
response_values <- response_values[!na_indices]
fitted_values <- fitted_values[!na_indices]
}
# Debugging: Print cleaned response values and fitted values
print("Cleaned response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
print(paste("SS_res:", ss_res))
print(paste("SS_tot:", ss_tot))
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
#R squared Code
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the model's data
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
print("Initial response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Handle NA values: remove corresponding elements from both response_values and fitted_values
na_indices <- is.na(response_values)
if (any(na_indices)) {
warning("NA values found in response variable, removing them")
response_values <- response_values[!na_indices]
fitted_values <- fitted_values[!na_indices]
}
# Debugging: Print cleaned response values and fitted values
print("Cleaned response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
print(paste("SS_res:", ss_res))
print(paste("SS_tot:", ss_tot))
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data,
na.action = na.exclude,
method = "ML")
rsquared_value <- rsquared_gls(m4M)
# Ensure all necessary variables are numeric
data$logitpropM <- as.numeric(data$logitpropM)
data$ppt.cm <- as.numeric(data$ppt.cm)
data$soil_texture_clay <- as.numeric(data$soil_texture_clay)
data$tmeanC <- as.numeric(data$tmeanC)
data$active_carbon <- as.numeric(data$active_carbon)
# Print out the types of the variables to ensure they are numeric
str(data)
# Remove rows with any NA values before fitting the model
data_clean <- na.omit(data)
# Fit your GLS model with cleaned data
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data_clean,
method = "ML")
# Define the rsquared_gls function
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the model's data
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
print("Initial response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Handle NA values: remove corresponding elements from both response_values and fitted_values
na_indices <- is.na(response_values)
if (any(na_indices)) {
warning("NA values found in response variable, removing them")
response_values <- response_values[!na_indices]
fitted_values <- fitted_values[!na_indices]
}
# Debugging: Print cleaned response values and fitted values
print("Cleaned response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
print(paste("SS_res:", ss_res))
print(paste("SS_tot:", ss_tot))
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared
rsquared_value <- rsquared_gls(m4M)
# Ensure all necessary variables are numeric
data$logitpropM <- as.numeric(data$logitpropM)
data$ppt.cm <- as.numeric(data$ppt.cm)
data$soil_texture_clay <- as.numeric(data$soil_texture_clay)
data$tmeanC <- as.numeric(data$tmeanC)
data$active_carbon <- as.numeric(data$active_carbon)
# Remove rows with any NA values in the relevant columns before fitting the model
data_clean <- na.omit(data)
# Fit your GLS model with cleaned data
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data_clean,
method = "ML")
# Define the rsquared_gls function
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the original dataset used in the model fitting
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Handle NA values: remove corresponding elements from both response_values and fitted_values
na_indices <- is.na(response_values)
if (any(na_indices)) {
warning("NA values found in response variable, removing them")
response_values <- response_values[!na_indices]
fitted_values <- fitted_values[!na_indices]
}
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared
rsquared_value <- rsquared_gls(m4M)
# Remove rows with any NA values in the relevant columns before fitting the model
data_clean <- na.omit(data)
# Fit your GLS model with cleaned data
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data_clean,
method = "ML")
# Define the rsquared_gls function
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the cleaned data
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Ensure no NA values are in the response values or fitted values
valid_indices <- !is.na(response_values) & !is.na(fitted_values)
response_values <- response_values[valid_indices]
fitted_values <- fitted_values[valid_indices]
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared
rsquared_value <- rsquared_gls(m4M)
print(rsquared_value)
# Define the rsquared_gls function for model m3
rsquared_gls_m3 <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the original dataset used in the model fitting
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Ensure no NA values are in the response values or fitted values
valid_indices <- !is.na(response_values) & !is.na(fitted_values)
response_values <- response_values[valid_indices]
fitted_values <- fitted_values[valid_indices]
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared for model m3
rsquared_value_m3 <- rsquared_gls_m3(m3)
print(rsquared_value_m3)
# Define the rsquared_gls function for model m3P
rsquared_gls_m3P <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the original dataset used in the model fitting
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Ensure no NA values are in the response values or fitted values
valid_indices <- !is.na(response_values) & !is.na(fitted_values)
response_values <- response_values[valid_indices]
fitted_values <- fitted_values[valid_indices]
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared for model m3P
rsquared_value_m3P <- rsquared_gls_m3P(m3P)
print(rsquared_value_m3P)
