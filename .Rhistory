# Print the ANOVA table
print(anova_result)
# Extract the degrees of freedom for each variable
num_df <- anova_result$"numDF"  # Numerator degrees of freedom
den_df <- anova_result$"denDF"  # Denominator degrees of freedom
# Print the degrees of freedom
print(num_df)
print(den_df)
m3 = gls(mgCpergSoilM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon + aggregate_stability,
data = data,
na.action = na.exclude,
method = "ML")
summary(m3)
anova(m3)
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data,
na.action = na.exclude,
method = "ML")
summary(m4M)
anova(m4M)
# Perform linear regression
regression_model <- lm(mgCpergSoilM ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
# Perform linear regression
regression_model <- lm(mgCpergSoilP ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
# Perform linear regression
regression_model <- lm(logitpropM ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
#load your libraries
library(tidyverse)
library(ggplot2)
library(dplyr)
library(corrplot)
library(emmeans)
library(nlme)
library(ggeffects)
##call in the analytical data
data <- read.csv("data.csv")
View(data)
# Perform ANOVA
anova_result <- aov(OM30 ~ Type.x, data = data)
# Summary of ANOVA
summary(anova_result)
# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result, ~ Type.x)
# Print pairwise comparisons
print(posthoc, type = "compact")
# Use table() function to count occurrences of each field type
type_counts <- table(data$Type.x)
# Print the counts
print(type_counts)
library (gmodels)
# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)
# Print the contingency table
print(contingency_table)
# Perform chi-square test of independence
chi2_test <- chisq.test(contingency_table)
# Print the chi-square test results
print(chi2_test)
# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)
# Convert contingency table to data frame for plotting
contingency_df <- as.data.frame.matrix(contingency_table)
# Reshape data for plotting (optional, depending on how you want to visualize)
library(reshape2)
contingency_melted <- melt(contingency_df)
# Plot clustered bar plot
ggplot(contingency_melted, aes(x = soil_texture_class, y = value, fill = Type.x)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Soil Texture Class", y = "Count") +
ggtitle("Distribution of Field Types by Soil Texture") +
theme_minimal()
install.packages(reshape2)
library(reshape2)
# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)
# Convert contingency table to data frame for plotting
contingency_df <- as.data.frame.matrix(contingency_table)
# Reshape data for plotting (optional, depending on how you want to visualize)
contingency_melted <- melt(contingency_df)
# Plot clustered bar plot
ggplot(contingency_melted, aes(x = soil_texture_class, y = value, fill = Type.x)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Soil Texture Class", y = "Count") +
ggtitle("Distribution of Field Types by Soil Texture") +
theme_minimal()
# Plot heatmap of contingency table
heatmap.2(as.matrix(contingency_table),
trace = "none",
col = heat.colors(length(unique(data$Type.x))),
dendrogram = "row",
main = "Association between Field Type and Soil Texture",
xlab = "Soil Texture Class",
ylab = "Field Type")
library(gplots)
install.packages(gplots)
# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)
# Print the contingency table
print(contingency_table)
# Perform chi-square test of independence
chi2_test <- chisq.test(contingency_table)
# Print the chi-square test results
print(chi2_test)
# chi test shows that this is a significant assosiation between field trype and soil texture class
# Assuming your data frame is named 'data' and contains columns 'Type.x' and 'soil_texture_class'
# Make sure 'Type.x' and 'soil_texture_class' are factors for correct plotting
# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)
# Convert contingency table to data frame for plotting
contingency_df <- as.data.frame.matrix(contingency_table)
# Reshape data for plotting (optional, depending on how you want to visualize)
contingency_melted <- melt(contingency_df)
# Plot clustered bar plot
ggplot(contingency_melted, aes(x = soil_texture_class, y = value, fill = Type.x)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Soil Texture Class", y = "Count") +
ggtitle("Distribution of Field Types by Soil Texture") +
theme_minimal()
# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)
# Print the contingency table
print(contingency_table)
# Perform chi-square test of independence
chi2_test <- chisq.test(contingency_table)
# Create a contingency table
contingency_table <- table(data$Type.x, data$soil_texture_class)
# Convert contingency table to data frame for plotting
contingency_df <- as.data.frame.matrix(contingency_table)
# Example data generation (replace with your actual data)
set.seed(123)
data <- data.frame(
soil_texture_class = sample(c("Sandy", "Loamy", "Clayey"), 100, replace = TRUE),
Type.x = sample(c("Corn", "Field Crops", "Hay", "Pasture", "Veg"), 100, replace = TRUE),
mgCpergSoilP = rnorm(100, mean = 10, sd = 2)
)
# Create a violin plot with individual data points and mean line for soil texture and field type
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, fill = Type.x)) +
geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
geom_jitter(width = 0.2, size = 1, position = position_jitterdodge()) +  # Add jittered points, dodge by Type.x
stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow", position = position_dodge(width = 0.2)) +  # Add mean points, dodge by Type.x
labs(title = "Distribution of mgCpergSoilP by Soil Texture and Field Type",
x = "Soil Texture Class",
y = "mgC per g Soil POM",
fill = "Field Type") +
theme_minimal() +  # Apply a minimal theme for a clean look
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),  # Adjust text angle, justification, and size
plot.margin = margin(5, 5, 10, 5))  # Increase the bottom margin to give more space to labels
# Load necessary library
library(ggplot2)  # For plotting
# Example data generation (replace with your actual data)
set.seed(123)
data <- data.frame(
soil_texture_class = sample(c("Sandy", "Loamy", "Clayey"), 100, replace = TRUE),
Type.x = sample(c("Corn", "Field Crops", "Hay", "Pasture", "Veg"), 100, replace = TRUE),
mgCpergSoilP = rnorm(100, mean = 10, sd = 2)
)
# Get unique options in soil_texture_class
unique_soil_texture <- unique(data$soil_texture_class)
# Print the unique options
print(unique_soil_texture)
view(data$soil_texture_class)
# Create a boxplot or violin plot
ggplot(data, aes(x = cut(soil_texture_clay, breaks = 5), y = Type.x)) +
geom_boxplot() +  # or geom_violin() for a violin plot
labs(x = "Soil Texture Clay Levels", y = "Field Type") +
ggtitle("Comparison of Field Types across Soil Texture Clay Levels")
# Create a violin plot with individual data points and mean line for soil texture and field type
ggplot(data, aes(x = soil_texture_class, y = Type.x, fill = Type.x)) +
geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
geom_jitter(width = 0.2, size = 1, position = position_jitterdodge()) +  # Add jittered points, dodge by Type.x
stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow", position = position_dodge(width = 0.2)) +  # Add mean points, dodge by Type.x
labs(title = "Distribution of field type by Soil Texture and Field Type",
x = "Soil Texture Class",
y = "mgC per g Soil POM",
fill = "Field Type") +
theme_minimal() +  # Apply a minimal theme for a clean look
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),  # Adjust text angle, justification, and size
plot.margin = margin(5, 5, 10, 5))  # Increase the bottom margin to give more space to labels
# Create a violin plot with individual data points and mean line for soil texture and field type
ggplot(data, aes(x = soil_texture_class, y = mgCpergSoilP, fill = Type.x)) +
geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
geom_jitter(width = 0.2, size = 1, position = position_jitterdodge()) +  # Add jittered points, dodge by Type.x
stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow", position = position_dodge(width = 0.2)) +  # Add mean points, dodge by Type.x
labs(title = "Distribution of mgCpergSoilP by Soil Texture and Field Type",
x = "Soil Texture Class",
y = "mgC per g Soil POM",
fill = "Field Type") +
theme_minimal() +  # Apply a minimal theme for a clean look
theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 10),  # Adjust text angle, justification, and size
plot.margin = margin(5, 5, 10, 5))  # Increase the bottom margin to give more space to labels
# Create a boxplot or violin plot
ggplot(data, aes(x = cut(soil_texture_clay, breaks = 5), y = Type.x)) +
geom_boxplot() +  # or geom_violin() for a violin plot
labs(x = "Soil Texture Clay Levels", y = "Field Type") +
ggtitle("Comparison of Field Types across Soil Texture Clay Levels")
view(data$soil_texture_class)
view(data$soil_texture_clay)
view(data$soil_texture_clay)
View(data)
# Perform ANOVA
anova_result <- aov(soil_texture_class ~ Type.x, data = data)
# Perform ANOVA
anova_result <- aov(soil_texture_clay ~ Type.x, data = data)
##call in the analytical data
data <- read.csv("data.csv")
View(data)
# Perform ANOVA
anova_result <- aov(soil_texture_clay ~ Type.x, data = data)
# Summary of ANOVA
summary(anova_result)
# Conduct post-hoc tests using Tukey's HSD test for pairwise comparisons
posthoc <- emmeans(anova_result, ~ Type.x)
# Print pairwise comparisons
print(posthoc, type = "compact")
# Example scatter plot with jitter
ggplot(data, aes(x = Type.x, y = soil_texture_clay)) +
geom_jitter(width = 0.3, height = 0, alpha = 0.7) +
labs(x = "Field Type", y = "Soil Texture Clay") +
ggtitle("Relationship between Soil Texture Clay and Field Type") +
theme_minimal()
# Example contingency table
cont_table <- table(data$Type.x, data$soil_texture_class)
# View the contingency table
cont_table
# Load necessary library
library(vcd)  # For mosaic plot
install.packages(vcd)
install.packages("vcd")
# Load necessary library
library(vcd)  # For mosaic plot
# Load necessary library
library(vcd)  # For mosaic plot
# Example mosaic plot
mosaicplot(cont_table, main = "Mosaic Plot of Field Type vs. Soil Texture Class")
summary_data <- data %>%
group_by(soil_texture_class, Type.x) %>%
summarise(count = n()) %>%
mutate(percent = count / sum(count) * 100)  # Calculate percentage within each soil_texture_class
# Plot stacked bar plot
library(ggplot2)
ggplot(summary_data, aes(x = soil_texture_class, y = percent, fill = Type.x)) +
geom_bar(stat = "identity", position = "stack") +
labs(x = "Soil Texture Class", y = "Percentage", fill = "Field Type") +
ggtitle("Distribution of Field Type across Soil Texture Classes") +
theme_minimal()
# Plot grouped bar plot
ggplot(summary_data, aes(x = soil_texture_class, y = percent, fill = Type.x)) +
geom_bar(stat = "identity", position = "dodge") +
labs(x = "Soil Texture Class", y = "Percentage", fill = "Field Type") +
ggtitle("Distribution of Field Type across Soil Texture Classes") +
theme_minimal()
# Install and load waffle package
install.packages("waffle")
library(waffle)
# Create waffle chart for each soil_texture_class
waffle_list <- lapply(texture_classes, function(x) {
df_subset <- summary_data[summary_data$soil_texture_class == x, ]
waffle(df_subset$percent, rows = 5, size = 0.8, title = paste("Soil Texture Class:", x),
colors = brewer.pal(n = nlevels(factor(df_subset$Type.x)), name = "Set3"))
})
# Example of performing chi-square test
cont_table <- table(data$soil_texture_class, data$Type.x)
chi_square_test <- chisq.test(cont_table)
# View the contingency table
print(cont_table)
# View the chi-square test results
print(chi_square_test)
# Perform chi-square test
cont_table <- table(data$soil_texture_class, data$Type.x)
chi_square_test <- chisq.test(cont_table)
# Residual analysis
residuals <- residuals(chi_square_test)
# View residuals
print(residuals)
# Compute adjusted residuals
adjusted_res <- chisq.test(cont_table)$residuals
# View adjusted residuals
print(adjusted_res)
# Example of mosaic plot
library(vcd)
mosaicplot(cont_table, main = "Mosaic Plot of Field Type vs. Soil Texture Class")
# Example ANOVA
anova_model <- aov(soil_texture_clay ~ Type.x, data = data)
# Summary of ANOVA
summary(anova_model)
# Example linear regression
lm_model <- lm(soil_texture_clay ~ Type.x, data = data)
# Summary of linear regression
summary(lm_model)
# Example Tukey's HSD test for post-hoc analysis
tukey_test <- TukeyHSD(anova_model)
# View Tukey's HSD test results
print(tukey_test)
#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
#load your libraries
library(tidyverse)
library(ggplot2)
library(dplyr)
library(corrplot)
library(emmeans)
library(nlme)
library(ggeffects)
library (gmodels)
library(reshape2)
##call in the analytical data
data <- read.csv("data.csv")
summary(data$OM30)
summary(data$soil_texture_clay)
summary(data$tmeanC)
summary(data$ppt.cm)
length (Field_Code)
dim(data)
view(data)
summary(data$Owned)
summary(data$Acres)
#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
#load your libraries
library(tidyverse)
library(ggplot2)
library(dplyr)
library(openmeteo)
##call in the analytical data
Loc <- read.csv(file="Location.csv", header=TRUE, sep=",")
# work with Nclimgrid data
library(raster)
library(ggplot2)
library(sf)
library(maps)
library(mapdata)
# Get the map data for Vermont
vermont_map <- map_data("state")
vermont_map <- subset(vermont_map, region == "vermont")
# Plot the map and data points
ggplot() +
geom_polygon(data = vermont_map, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = Loc, aes(x = lon, y = lat), color = "red", size = 3) +
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude") +
theme_minimal()
data <- read.csv(file="fracData2.csv", header=TRUE, sep=",")
library(ggplot2)
# Assuming 'Type.x' is a column in your 'Loc' dataset
ggplot() +
geom_polygon(data = vermont_map, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = Loc, aes(x = lon, y = lat, color = Type.x), size = 3) +  # Mapping Type.x to color
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude") +
theme_minimal()
library(ggplot2)
# Assuming 'Type.x' is a column in your 'Loc' dataset
ggplot() +
geom_polygon(data = vermont_map, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = data, aes(x = lon, y = lat, color = Type.x), size = 3) +  # Mapping Type.x to color
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude") +
theme_minimal()
ggplot() +
geom_polygon(data = vermont_map, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = data, aes(x = long, y = lat, color = Type.x), size = 3) +  # Mapping Type.x to color
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude") +
theme_minimal()
Loc <- read.csv(file="Location.csv", header=TRUE, sep=",")
data <- read.csv("data.csv")
ibrary(ggplot2)
ggplot() +
geom_polygon(Loc = vermont_map, aes(x = lon, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = data, aes(x = lon, y = lat, color = Type.x), size = 3) +  # Mapping Type.x to color
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude") +
theme_minimal()
# Assuming 'Field_Code' is the shared column between vermont_map and data
merged_data <- merge(vermont_map, data, by = "Field_Code", all.x = TRUE)
# Assuming 'Field_Code' is the shared column between vermont_map and data
merged_data <- merge(Loc, data, by = "Field_Code", all.x = TRUE)
ggplot() +
geom_polygon(data = vermont_map, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = merged_data, aes(x = lon, y = lat, color = Type.x), size = 3) +  # Mapping Type.x to color
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude",
color = "Farm Type") +  # Legend title
scale_color_discrete(name = "Farm Type", labels = c("Type A", "Type B", "Type C")) +  # Custom legend labels
theme_minimal()
# Assuming 'Field_Code' is the shared column between vermont_map and data
merged_data <- merge(vermont_map, data, by = "Field_Code", all.x = TRUE)
# Assuming 'Field_Code' is the shared column between vermont_map and data
merged_data <- merge(Loc, data, by = "Field_Code", all.x = TRUE)
# Convert Type.x to a factor for correct color mapping
merged_data$Type.x <- factor(merged_data$Type.x)
ggplot() +
geom_polygon(data = vermont_map, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_point(data = merged_data, aes(x = lon, y = lat, color = Type.x), size = 3) +  # Mapping Type.x to color
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude",
color = "Farm Type") +  # Legend title
scale_color_discrete(name = "Farm Type", labels = levels(merged_data$Type.x)) +  # Custom legend labels
theme_minimal()
# Load soil data for Vermont (assuming it's named 'soil_data')
soil_data <- read.csv("soil_data.csv")  # Replace with your actual data loading method
View(data)
ggplot() +
geom_polygon(data = Loc, aes(x = long, y = lat, group = group), fill = "white", color = "black") +
geom_polygon(data = soil_texture_class, aes(x = long, y = lat, group = group, fill = soil_texture_class), color = "gray") +
geom_point(data = merged_data, aes(x = lon, y = lat, color = Type.x), size = 3) +  # Mapping Type.x to color
coord_fixed(1.3) +  # Fix aspect ratio
labs(title = "Latitude and Longitude Points on the Map of Vermont",
x = "Longitude",
y = "Latitude",
color = "Farm Type") +  # Legend title
scale_color_discrete(name = "Farm Type", labels = levels(merged_data$Type.x)) +  # Custom legend labels
scale_fill_manual(name = "Soil Type", values = c("brown", "yellow", "green", "blue")) +  # Custom soil legend colors
theme_minimal()
# Assuming 'soil_texture_class' is a column in the 'data' dataframe
# Load soil data for Vermont (assuming it's named 'soil_data')
soil_data <- read.csv("soil_data.csv")  # Replace with your actual data loading method
summary(data$ph)
# Count the number of data points with pH greater than 7
count <- sum(data$ph > 7)
# Print the result
print(count)
sum(data$ph > 7)
# Count the number of data points with pH greater than 7
count <- sum(data$ph > 7)
# Print the result
print(count)
# Count the number of data points with pH greater than 7
count <- sum(data$ph > 7.00)
# Print the result
print(count)
# Count the number of fields with pH greater than 7
count <- sum(data$pH > 7, na.rm = TRUE)
# Print the result
print(count)
# Count the number of fields with pH greater than 7
data$pH <- as.numeric(data$pH)
count <- sum(data$pH > 7, na.rm = TRUE)
# Print the result
print(count)
count <- sum(data$pH > 7.00, na.rm = TRUE)
# Print the result
print(count
# Print the result
print(count)
# Count the number of fields with pH greater than 7
data$pH <- as.numeric(data$pH)
# Count the number of fields with pH greater than 7
data$ph <- as.numeric(data$ph)
count <- sum(data$ph > 7.00, na.rm = TRUE)
# Print the result
print(count)
# Perform linear regression
regression_model <- lm(logitpropM ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line
ggplot(data, aes(x = overall.score, y = logitpropM)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of mgCpergSoilM on overall.score",
x = "Overall Score",
y = "logit proportion of MAOM") +
theme_minimal()
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line and colored points
ggplot(data, aes(x = overall.score, y = logitpropM, color = soil_texture_class)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of logitpropM on overall.score",
x = "Overall Score",
y = "Logit Proportion of MAOM") +
theme_minimal()
library(ggplot2)
library(dplyr)
# Create a new column for color based on soil_texture_class
data <- data %>%
mutate(color = ifelse(grepl("Clay", soil_texture_class), "red", "black"))
# Create a plot with the regression line and colored points
ggplot(data, aes(x = overall.score, y = logitpropM, color = color)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of logitpropM on overall.score",
x = "Overall Score",
y = "Logit Proportion of MAOM") +
theme_minimal() +
scale_color_identity()
