print(fitted_values)
# Handle NA values: remove corresponding elements from both response_values and fitted_values
na_indices <- is.na(response_values)
if (any(na_indices)) {
warning("NA values found in response variable, removing them")
response_values <- response_values[!na_indices]
fitted_values <- fitted_values[!na_indices]
}
# Debugging: Print cleaned response values and fitted values
print("Cleaned response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
print(paste("SS_res:", ss_res))
print(paste("SS_tot:", ss_tot))
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data,
na.action = na.exclude,
method = "ML")
rsquared_value <- rsquared_gls(m4M)
# Ensure all necessary variables are numeric
data$logitpropM <- as.numeric(data$logitpropM)
data$ppt.cm <- as.numeric(data$ppt.cm)
data$soil_texture_clay <- as.numeric(data$soil_texture_clay)
data$tmeanC <- as.numeric(data$tmeanC)
data$active_carbon <- as.numeric(data$active_carbon)
# Print out the types of the variables to ensure they are numeric
str(data)
# Remove rows with any NA values before fitting the model
data_clean <- na.omit(data)
# Fit your GLS model with cleaned data
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data_clean,
method = "ML")
# Define the rsquared_gls function
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the model's data
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
print("Initial response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Handle NA values: remove corresponding elements from both response_values and fitted_values
na_indices <- is.na(response_values)
if (any(na_indices)) {
warning("NA values found in response variable, removing them")
response_values <- response_values[!na_indices]
fitted_values <- fitted_values[!na_indices]
}
# Debugging: Print cleaned response values and fitted values
print("Cleaned response values:")
print(response_values)
print("Fitted values:")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
print(paste("SS_res:", ss_res))
print(paste("SS_tot:", ss_tot))
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared
rsquared_value <- rsquared_gls(m4M)
# Ensure all necessary variables are numeric
data$logitpropM <- as.numeric(data$logitpropM)
data$ppt.cm <- as.numeric(data$ppt.cm)
data$soil_texture_clay <- as.numeric(data$soil_texture_clay)
data$tmeanC <- as.numeric(data$tmeanC)
data$active_carbon <- as.numeric(data$active_carbon)
# Remove rows with any NA values in the relevant columns before fitting the model
data_clean <- na.omit(data)
# Fit your GLS model with cleaned data
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data_clean,
method = "ML")
# Define the rsquared_gls function
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the original dataset used in the model fitting
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Handle NA values: remove corresponding elements from both response_values and fitted_values
na_indices <- is.na(response_values)
if (any(na_indices)) {
warning("NA values found in response variable, removing them")
response_values <- response_values[!na_indices]
fitted_values <- fitted_values[!na_indices]
}
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared
rsquared_value <- rsquared_gls(m4M)
# Remove rows with any NA values in the relevant columns before fitting the model
data_clean <- na.omit(data)
# Fit your GLS model with cleaned data
m4M <- gls(logitpropM ~ ppt.cm * soil_texture_clay * tmeanC + ppt.cm * tmeanC +
active_carbon,
data = data_clean,
method = "ML")
# Define the rsquared_gls function
rsquared_gls <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the cleaned data
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Ensure no NA values are in the response values or fitted values
valid_indices <- !is.na(response_values) & !is.na(fitted_values)
response_values <- response_values[valid_indices]
fitted_values <- fitted_values[valid_indices]
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared
rsquared_value <- rsquared_gls(m4M)
print(rsquared_value)
# Define the rsquared_gls function for model m3
rsquared_gls_m3 <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the original dataset used in the model fitting
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Ensure no NA values are in the response values or fitted values
valid_indices <- !is.na(response_values) & !is.na(fitted_values)
response_values <- response_values[valid_indices]
fitted_values <- fitted_values[valid_indices]
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared for model m3
rsquared_value_m3 <- rsquared_gls_m3(m3)
print(rsquared_value_m3)
# Define the rsquared_gls function for model m3P
rsquared_gls_m3P <- function(model) {
# Extract fitted values
fitted_values <- fitted(model)
# Extract response variable name
response_variable <- as.character(formula(model)[[2]])
# Extract response values from the original dataset used in the model fitting
response_values <- model$data[[response_variable]]
# Ensure the response variable is numeric
if (!is.numeric(response_values)) {
response_values <- as.numeric(as.character(response_values))
}
# Debugging: Print initial response values and fitted values
cat("Initial response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Ensure no NA values are in the response values or fitted values
valid_indices <- !is.na(response_values) & !is.na(fitted_values)
response_values <- response_values[valid_indices]
fitted_values <- fitted_values[valid_indices]
# Debugging: Print cleaned response values and fitted values
cat("Cleaned response values:\n")
print(response_values)
cat("Fitted values:\n")
print(fitted_values)
# Verify lengths of response values and fitted values
if (length(response_values) != length(fitted_values)) {
stop("Length mismatch between response values and fitted values")
}
# Calculate residuals
residuals <- response_values - fitted_values
# Calculate the sum of squared residuals
ss_res <- sum(residuals^2)
# Calculate the total sum of squares
ss_tot <- sum((response_values - mean(response_values))^2)
# Debugging: Print sum of squared residuals and total sum of squares
cat("SS_res:", ss_res, "\n")
cat("SS_tot:", ss_tot, "\n")
# Check for zero variance in response values
if (ss_tot == 0) {
warning("Total sum of squares is zero, resulting in NaN R-squared")
return(NaN)
}
# Calculate R-squared
rsq <- 1 - (ss_res / ss_tot)
return(rsq)
}
# Calculate and print R-squared for model m3P
rsquared_value_m3P <- rsquared_gls_m3P(m3P)
print(rsquared_value_m3P)
#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
library(tidyverse)
library(ggplot2)
library(dplyr)
library(corrplot)
library(nlme)
library(ggeffects)
library(emmeans)
##call in the analytical data
data <- read.csv("data.csv")
view(data)
# Perform linear regression
regression_model <- lm(mgCpergSoilM ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line
ggplot(data, aes(x = overall.score, y = mgCpergSoilM)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of mgCpergSoilM on overall.score",
x = "Overall Score",
y = "mgC per g Soil M") +
theme_minimal()
# Perform linear regression try it the other way, to see!
regression_model <- lm(overall.score ~ mgCpergSoilM, data = data)
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line
ggplot(data, aes(x = mgCpergSoilM, y = overall.score)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of mgCpergSoilM on overall.score",
x = "mgC per g Soil M",
y = "Soil Health Score") +
theme_minimal()
# Perform linear regression
regression_model <- lm(logitpropM ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line
ggplot(data, aes(x = overall.score, y = logitpropM)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of mgCpergSoilM on overall.score",
x = "Overall Score",
y = "logit proportion of MAOM") +
theme_minimal()
# Perform linear regression
regression_model <- lm(overall.score ~ logitpropM, data = data)
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line
ggplot(data, aes(x = logitpropM, y = overall.score)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of soil health score on logitpropM",
x = "Proportion of MAOM",
y = "overall soil health score") +
theme_minimal()
#soil heath regression
# Perform linear regression
regression_model <- lm(logitpropM ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line
ggplot(data, aes(x = overall.score, y = logitpropM)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of mgCpergSoilM on overall.score",
x = "Overall Score",
y = "logit proportion of MAOM") +
theme_minimal()
# Perform linear regression
regression_model <- lm(mgCpergSoilP ~ overall.score, data = data)
# Summarize the regression model
summary(regression_model)
# Create a plot with the regression line
ggplot(data, aes(x = overall.score, y = mgCpergSoilP)) +
geom_point() +
geom_smooth(method = "lm", col = "blue") +
labs(title = "Linear Regression of mgCpergSoilP on overall.score",
x = "Overall Score",
y = "mgC per g Soil P") +
theme_minimal()
#analyze data by field type. group by and color by field type this code is in progress
#exploration
mgMAOM_active_carbonbyField <-data %>%
ggplot() +
geom_point(aes(x = active_carbon, y = mgCpergSoilM, color=Type.x),
size = 1.5, alpha = 0.5) +
#geom_smooth() +
own_theme+
#theme(legend.position = "none") +
scale_y_continuous(expression("mg C in MAOM per g soil"))+
scale_x_continuous(expression("active_carbon"),
label = scales::comma)
mgMAOM_active_carbonbyField <-data
ggplot() +
geom_point(aes(x = active_carbon, y = mgCpergSoilM, color=Type.x),
size = 1.5, alpha = 0.5) +
#geom_smooth() +
own_theme+
#theme(legend.position = "none") +
scale_y_continuous(expression("mg C in MAOM per g soil"))+
scale_x_continuous(expression("active_carbon"),
label = scales::comma)
#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
#load your libraries
library(tidyverse)
library(ggplot2)
library(dplyr)
library(corrplot)
library(nlme)
library(ggeffects)
library(emmeans)
##call in the analytical data
data <- read.csv("data.csv")
ggplot(data, aes(x = Type.x, y = mgCpergSoilM)) +
geom_violin(trim = FALSE, fill = "lightblue") +  # Create the violin plot
geom_jitter(width = 0.2, size = 1, color = "darkblue") +  # Add jittered points
labs(title = "Distribution of mgCpergSoilM by Field Type",
x = "Field Type",
y = "mgC per g Soil M") +
theme_minimal()  # Apply a minimal theme for a clean look
ggplot(data, aes(x = Type.x, y = logitpropM)) +
geom_violin(trim = FALSE, fill = "lightblue") +  # Create the violin plot
geom_jitter(width = 0.2, size = 1, color = "darkblue") +  # Add jittered points
labs(title = "Proporation of MAOM by Field Type",
x = "Field Type",
y = "MAOM Proportion (logit)") +
theme_minimal()  # Apply a minimal theme for a clean look
# Create a violin plot with individual data points
ggplot(data, aes(x = Type.x, y = mgCpergSoilP)) +
geom_violin(trim = FALSE, fill = "lightblue") +  # Create the violin plot
geom_jitter(width = 0.2, size = 1, color = "darkblue") +  # Add jittered points
labs(title = "Distribution of mg POM by Field Type",
x = "Field Type",
y = "mgC per g Soil POM") +
theme_minimal()  # Apply a minimal theme for a clean look
# Create a violin plot with individual data points and mean line
ggplot(data, aes(x = Type.x, y = mgCpergSoilM, color = Type.x, fill = Type.x)) +
geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
geom_jitter(width = 0.2, size = 1) +  # Add jittered points
stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
labs(title = "Distribution of mgCpergSoilM by Field Type",
x = "Field Type",
y = "mgC per g Soil M") +
theme_minimal()  # Apply a minimal theme for a clean look
#setwd("/Users/f003833/Documents/GitHub/FracFarmVT") #caitlin
setwd("C:/Users/F004SPC/Documents/GitHub/FracFarmVT") #erin
library(tidyverse)
library(ggplot2)
library(dplyr)
library(corrplot)
library(nlme)
library(ggeffects)
library(emmeans)
##call in the analytical data
data <- read.csv("data.csv")
# Create a violin plot with individual data points and mean line
ggplot(data, aes(x = Type.x, y = mgCpergSoilM, color = Type.x, fill = Type.x)) +
geom_violin(trim = FALSE, alpha = 0.5) +  # Create the violin plot with semi-transparent fill
geom_jitter(width = 0.2, size = 1) +  # Add jittered points
stat_summary(fun = mean, geom = "point", shape = 23, size = 2, color = "black", fill = "yellow") +  # Add mean points
labs(title = "Distribution of mgCpergSoilM by Field Type",
x = "Field Type",
y = "mgC per g Soil M") +
theme_minimal()  # Apply a minimal theme for a clean look
#transform data logit
#data <- data %>%
# dplyr::mutate(logitpropM = logit(propM))
#write.csv(data,"data.csv")
#hist(data$logitpropM)
#summary(data$logitpropM)
hist(data$propM, main = "Histogram of propM", xlab = "propM Values", ylab = "Frequency")
